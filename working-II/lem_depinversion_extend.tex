%
\begin{lem}[Control Dependency Inversion]
	\label{lem:ctldep_inv}
	For every $c \in \cdom$, $D \in \dbdom, \trace \in \mathcal{T}$ and two assignment events $\event_1, \event_2 \in \eventset^{\asn} $, if they are in the second case of the \emph{Event May-Dependency} relation from Definition.~\ref{def:event_dep},
	$\eventdep(\event, \event, c, \trace, D)$ as Eq.~\ref{eq:ctlflowsto_inv},
	then for all  $z \in VAR(\pi_1(\event_b))$ there exists a label $i \in \mathbb{N}$ such that 
	$\flowsto(z^i, \pi_1(\event)^{\pi_2(\event)}, c)$
	\begin{equation}
		\label{eq:ctlflowsto_inv},		
		\begin{array}{l}
			\forall D \in \dbdom , c \in \cdom, \trace \in \mathcal{T},
			\event_1, \event_2 \in \eventset^{\asn} \st 
			\\ 
			\exists \vtrace_0,
			\vtrace_1, \vtrace', \vtrace_3, \vtrace_3' \in \mathcal{T},\event_1' \in \eventset^{\asn}, {c}_1, {c}_2  \in \cdom, 
			\event_b \in \eventset^{\test},
			\trace_{ih} \in \mathcal{T} \st 
		\trace = [\event_1] \tracecat \trace_{ih} \tracecat [\event_2]
		\\ \quad \implies	  
			  \config{{c}, \vtrace_0} \rightarrow^{*} 
				\config{{c}_1, \vtrace_1 \tracecat [\event_1]}  \rightarrow^{*} 
				\config{c_2,  \vtrace_1 \tracecat [\event_1] \tracecat \trace \tracecat [\event_b] \tracecat  \trace_3} 
			  \\ \qquad \land
			  \config{{c}_1, \vtrace_1 \tracecat [\event_1']}  \rightarrow^{*} 
			  \config{c_2,  \vtrace_1 \tracecat [\event_1'] \tracecat \trace' \tracecat [(\neg \event_b)] \tracecat \trace_3'} 
			  \\ \qquad \land
			\tlabel_{\trace_3} \cap \tlabel_{\trace_3'} = \emptyset
			   \land \vcounter(\trace') ~  \pi_2(\event_b) = \vcounter(\trace) ~  \pi_2(\event_b)
				\land \event_2 \eventin \trace_3
			  \land \event_2 \not\eventin \trace_3'
		\\ \quad \implies	
		\forall z \in VAR(\pi_1(\event_b)) \st 
		\exists l \in \mathbb{N} \st 
		\flowsto(z^l, \pi_1(\event_2)^{\pi_2(\event_2)},c)
	\end{array}
\end{equation}
	\end{lem}
	Proof Summary:
	\\
	Proving by using the Inversion Lemmas~\ref{lem:inv_expr}, \ref{lem:inv_expr_gnl}, 
	\ref{lem:inv_event}, and \ref{lem:inv_live}, and the \emph{Event May-Dependency} definition of the second case.
%
	\begin{proof}
		Take arbitrary $D \in \dbdom , c \in \cdom, \trace \in \mathcal{T},
		\event_1, \event_2 \in \eventset^{\asn} $,
%
let $\vtrace_0,
\vtrace_1, \vtrace', \vtrace_3, \vtrace_3' \in \mathcal{T}, 
\event_2' \in \eventset, \event_1' \in \eventset^{\asn}, \event_b, {c}_1, {c}_2$ be the traces, 
events and commands satisfying the executions,
by Inversion Lemma~\ref{lem:inv_event} on 
$\event_2$, and $\event_b$,
we have the following instance of the first execution in Eq.~\ref{eq:ctlflowsto_inv},
 %
%
% Let $\event_{ih} = (b, l_b, n_b, v_b)$, by Eq.~\ref{eq:ctldep_inv1} and {Inversion Lemma~\ref{lem:inv_test}}, we have:
\begin{equation}
% \label{eq:ctldep_inv1}
  \begin{array}{l}   
\config{{c}, \vtrace_0} \rightarrow^{*} 
% \config{[\assign{{x}_1}{\expr_1 / \query(\qexpr_1)}]^{l_1} ; {c}_1, \vtrace_1}  
% \rightarrow^{\rname{assn/query}}
%  \config{c_1, \vtrace_1 \tracecat [\event_1]} 
%  \\ \qquad 
%  \rightarrow^{*} 
  \config{\eif ([b]^{l_b}, c_t, c_f) / \ewhile [b]^{l_b} \edo c_w;{c}_3', 
  \vtrace_1 \tracecat [\event_1] \tracecat \trace} 
  \\
  \qquad 
   \rightarrow^{\rname{if-b / while-b}} 
  \config{(c_t;c_3' / c_f;c_3') /(c_w; \ewhile [b]^{l_b} \edo c_w;c_3'/[\eskip]; c_3'), 
  \trace_1 \tracecat [\event_1] \tracecat \trace \tracecat [\event_b]} 
  \\
  \qquad  \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2}; c_{3b}', 
  \trace_1 \tracecat [\event_1] \tracecat \trace \tracecat [\event_b] \tracecat  \trace_{3a}}
  \\ \qquad \rightarrow^{\rname{assn/query}}
  \config{ c_{3b}', 
  \trace_1 \tracecat [\event_1] \tracecat \trace \tracecat [\event_b] \tracecat  \trace_{3a} \tracecat [\event_2]}
  \rightarrow^{*} 
  \config{c_3, 
  \trace_1 \tracecat [\event_1] \tracecat \trace \tracecat [\event_b] \tracecat  \trace_{3a} \tracecat [\event_2] \tracecat \trace_{3b}}
  % 
\end{array}
\end{equation}
%  %
, where $\trace_3 = \trace_{3a} \tracecat [\event_2] \tracecat \trace_{3b}$,
% $x_1 = \pi_1(\event_1)$, $l_1 = {\pi_2(\event_1)}$, 
$x_2 = \pi_1(\event_2)$, $l_2 = \pi_2(\event_2)$, 
and $\eif ([b]^{l_b}, c_t, c_f) / \ewhile [b]^{l_b} \edo c_w$ 
is the conditional command of the assignment commands associated to the 
$\event_b$ from Inversion Lemma~\ref{lem:inv_event} of testing event.
\\
% \[\begin{array}{l}   
% 	  \config{\eif ([b]^{l_b}, c_t, c_f) / \ewhile [b]^{l_b} \edo c_w;{c}_3', 
% 	  \vtrace_1 \tracecat [\event_1] \tracecat \trace} 
% 	  \\
% 	  \qquad 
% 	   \rightarrow^{\rname{if-b / while-b}} 
% 	  \config{(c_t;c_3' / c_f;c_3') /(c_3' / c_w; \ewhile [b]^{l_b} \edo c_w;{c}_3'), 
% 	  \trace_1 \tracecat [\event_1] \tracecat \trace \tracecat [\event_b]} 
% 	  % 
% 	\end{array}
% 	\]
% $\config{\eif ([b]^{l_b}, c_t, c_f) / \ewhile [b]^{l_b} \edo c_w;{c}_3', 
% \vtrace_1 \tracecat [\event_1] \tracecat \trace} 
%  \rightarrow^{\rname{if-b / while-b}} 
% \config{(c_t;c_3' / c_f;c_3') /(c_3' / c_w; \ewhile [b]^{l_b} \edo c_w;{c}_3'), 
% \trace_1 \tracecat [\event_1] \tracecat \trace \tracecat [\event_b]} 
% $
The notation $(c_t;c_3' / c_f;c_3') /(c_w; \ewhile [b]^{l_b} \edo c_w;c_3' / [\eskip]; c_3')$ represents:
\\
In case of $\eif ([b]^{l_b}, c_t, c_f)$, if $\pi_3(\event_b) = \etrue$, we have the evaluation:
$$
\config{\eif ([b]^{l_b}, c_t, c_f) ;{c}_3', 
\vtrace_1 \tracecat [\event_1] \tracecat \trace} 
 \rightarrow^{\rname{if-b}} 
\config{c_t;c_3' 
\trace_1 \tracecat [\event_1] \tracecat \trace \tracecat [\event_b]} 
$$
%
The same for case of $\eif ([b]^{l_b}, c_t, c_f)$ with $\pi_3(\event_b) = \efalse$,
and case of $\ewhile [b]^{l_b} \edo c_w$ with $\pi_3(\event_b) = \etrue$ and $\pi_3(\event_b) = \efalse$.
%
\\
By the command label consistency,
we also have the instance of second execution as follows:
\begin{equation}
\label{eq:ctldep_inv2}
\begin{array}{l}   
  \config{{c}, \vtrace_0} \rightarrow^{*} 
%   \config{[\assign{{x}_1}{\expr_1 / \query(\qexpr_1)}]^{l_1} ; {c}_1, \vtrace_1}  
%   \rightarrow^{\rname{\rname{assn/query}}}
%    \config{c_1, \vtrace_1 \tracecat [\event_1]} 
%    \\
%     \qquad \rightarrow^{*} 
    \config{\eif ([b]^{l_b}, c_t, c_f) / \ewhile [b]^{l_b} \edo c_w;{c}_3', 
    \vtrace_1 \tracecat [\event_1] \tracecat \trace'} 
    \\
    \qquad 
     \rightarrow^{\rname{if-b / while-b}} 
    \config{(c_f;c_3' / c_t;c_3') /([\eskip]; c_3' / c_w; \ewhile [b]^{l_b} \edo c_w;{c}_3' ), 
    \trace_1 \tracecat [\event_1]  \tracecat \trace' \tracecat [\neg \event_b]} 
    \\
    \qquad   \rightarrow^{*} 
    \config{c_3, 
    \trace_1 \tracecat [\event_1]  \tracecat \trace' \tracecat [\neg \event_b] \tracecat  \trace_3'}
    % 
  \end{array}
\end{equation}
%
By the label consistency, and $\tlabel_{\trace_3} \cap \tlabel_{\trace_3'} = \emptyset$, 
% i.e., 
% $ \trace_{3a} \tracecat [\event_2] \tracecat \trace_{3b} \cap \tlabel_{\trace_3'} = \emptyset$
we know $\trace_3$ and $\trace_3'$ doesn't contain any event of evaluating the commands in $c_3'$.
Otherwise, $\tlabel_{\trace_3} \cap \tlabel_{\trace_3'} \neq \emptyset$, which is a contradiction.
\\
Since $\trace_3= \trace_{3a} \tracecat [\event_2] \tracecat \trace_{3b} $, we know $\event_2$ doesn't comes from evaluating
of $c_3'$, i.e.,:
\\
In the case of $\eif ([b]^{l_b}, c_t, c_f)$, $\event_2$ comes from the evaluation of $c_t$ or $c_f$,
i.e., $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_t$ or $c_f$;
\\
and in the case of $\ewhile [b]^{l_b} \edo c_w$, $\event_2$ comes from the evaluation of $c_w$,
i.e., $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_w$.
\\
In both of the two cases, we know $\forall z \in VAR(\pi_1(\event_b)) $ there is a label $l \in \mathbb{N}$ for this variable,
and by the $\flowsto$ definition, 
$\flowsto(z^l, \pi_1(\event_2)^{\pi_2(\event_2)},c)$.
\\
This lemma is proved.
	\end{proof}
	%
	% \begin{lem}[One Step Dependency Inversion]
	% 	\label{lem:onestepdep_inv}
	% For all $ c \in \cdom, D \in \dbdom, x^i \in \lvar_c$, and $\event_y \in \eventset^{\asn}$, 
	% if $x^i \in VAR(\expr_y)$, 
	% or there exists $\event_b \in \eventset^{\test}$ such that 
	% $x^i \in VAR(\pi_1(\event_b)$ and 
	% $\eventdep^{\ctl}(\event_b, \event_y, c, D)$, then $\flowsto(x^i, \pi_1(\event_y)^{\pi_2(\event_y)}, c)$.
	% %
	% 	\[
	% 	\begin{array}{l}
	% 		\forall c \in \cdom, D \in \dbdom, x^i \in \lvar_c, \event_y \in \eventset^{\asn}
	% 		\st
	% 		\\ \quad
	% 		(x^i \in VAR(\expr_y)\lor 
	% 		(\exists \event_b \in \eventset^{\test} \st x^i \in VAR(\pi_1(\event_b)) 
	% 		\land \eventdep^{\ctl}(\event_b, \event_y, c, D)))
	% 		\implies \flowsto(x^i, \pi_1(\event_y)^{\pi_2(\event_y)}, c)
	% 	\end{array}
	% \]
	% \end{lem}
	% \begin{proof}
	% 	proving by using the Inversion Lemmas~\ref{lem:inv_expr_gnl}, ~\ref{lem:inv_expr},
	% 	\ref{lem:inv_event}, and \ref{lem:inv_live}, 
	% 	and Control Dependency Inversion Lemmas~\ref{lem:ctldep_inv}.
	% \end{proof}
	%
	%
\begin{lem}[The Multiple-Steps Event Dependency Inversion]
	\label{lem:depevents_exist}
For every $D \in \dbdom , c \in \cdom, \trace \in \mathcal{T}$, and two assignment events 
$\event_1, \event_2 \in \eventset^{\asn}$,
if the trace $trace$ has the form $\trace = [\event_1] \tracecat \trace' \tracecat [\event_2]$ with $\trace' \in \mathcal{T}$, and $\eventdep(\event_1, \event_2, \trace, c, D)$
then $\flowsto(\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c) $,
or otherwise there exists
$\event \in \trace'$ such that
$\left( 		
   \eventdep(\event_1, \event, \trace[\event_1:\event], c, D)
\land 
\flowsto(\pi_1(\event)^{\pi_2(\event)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c) 
\right)$.
%
	\[
	\begin{array}{l}
		\forall D \in \dbdom , c \in \cdom, \trace \in \mathcal{T} \st \forall \event_1, \event_2 \in \eventset^{\asn} \st
		 \exists \trace' \in \mathcal{T} \st \trace = [\event_1] \tracecat \trace' \tracecat [\event_2]
		\implies
		\eventdep(\event_1, \event_2, \trace, c, D) 
		\\ \quad 
		\implies 
		\flowsto(\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c) 
		\\ \qquad \quad \lor
		\exists \event \in \trace' \st 
		\left( 		
			\eventdep(\event_1, \event, \trace[\event_1:\event], c, D)
		\land 
		\flowsto(\pi_1(\event)^{\pi_2(\event)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c) 
	\right) 
		% \\ \qquad \qquad \lor
		% \flowsto(\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c) 
	\end{array}
	\]
\end{lem}
Proof Summary: 
\\
Proving by using Lemma~\ref{lem:inv_indepevents}, Lemma~\ref{lem:ctldep_inv}, and the Inversion Lemmas~\ref{lem:inv_expr}, \ref{lem:inv_expr_gnl},
\ref{lem:inv_event}, and \ref{lem:inv_live}
and showing a contradiction.
\begin{proof}
	Taking arbitrary 
	$ D \in \dbdom , c \in \cdom, \trace \in \mathcal{T} $ and two events 
	$\event_1, \event_2 \in \eventset^{\asn}$, where $\trace$ has the form 
	$\trace = [\event_1] \tracecat \trace' \tracecat [\event_2]$ 
	for some 
	$\trace' \in \mathcal{T}$ and $\eventdep(\event_1, \event_2, \trace, c, D)$
	\\ 
	Assume 
	\[
		\begin{array}{l}
	\neg \flowsto(\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c) ~ (1)
	\\ \quad 
	\land 
	\forall \event \in \trace' \st 
	\left( 		
		\neg \eventdep(\event_1, \event, \trace[\event_1:\event], c, D)
	\lor 
		\neg \flowsto(\pi_1(\event)^{\pi_2(\event)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c) 
	\right) ~ (2)
	\end{array}
	\]
	Then, by Lemma~\ref{lem:inv_indepevents} and $(2)$, we know 
	$$\flowsto(\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c)$$
	, which is contradict to $(1)$.
	\\
	This Lemma is proved.
\end{proof}
%
%
%
%
\begin{lem}[Independent Events Doesn't Block $\flowsto$ ]
		\label{lem:inv_indepevents}
		For every $D \in \dbdom , c \in \cdom, \trace \in \mathcal{T}$, one assignment events 
		$\event_1\in \eventset^{\asn}$, and another event $\event_2 \in \eventset$,
		if the trace $\trace$ has the form $\trace = [\event_1] \tracecat \trace' \tracecat [\event_2]$ with $\trace' \in \mathcal{T}$, 
		and $\eventdep(\event_1, \event_2, \trace, c, D)$,
		then the following two conclusions hold when $\event_2$ is an assignment event and a testing event respectively.
	\begin{itemize}
		\item
		If $\event_2 \in \eventset^{\asn}$,
		% For every $D \in \dbdom , c \in \cdom, \trace \in \mathcal{T}$, and two assignment events 
		% $\event_1, \event_2 \in \eventset^{\asn}$,
		% if the trace $\trace$ has the form $\trace = [\event_1] \tracecat \trace' \tracecat [\event_2]$ with $\trace' \in \mathcal{T}$, and $\eventdep(\event_1, \event_2, \trace, c, D)$,
		then for every $\event \in \trace'$, if it either doesn't have the \emph{Event May-Dependency} relation on $\event_1$, 
		or $\pi_1(\event)^{\pi_2(\event)}$ doesn't have the $\flowsto$ relation with $ \pi_1(\event_2)^{\pi_2(\event_2)}$,
		then the labelled variable $\pi_1(\event_1)^{\pi_2(\event_1)}$ directly flows to the other one $\pi_1(\event_2)^{\pi_2(\event_2)}$, 
		i.e., $\flowsto(\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c)$.
		%
		\[
		\begin{array}{l}
			\forall D \in \dbdom , c \in \cdom, \trace \in \mathcal{T} \st \forall \event_1, \event_2 \in \eventset^{\asn} \st
			 \exists \trace' \in \mathcal{T} \st \trace = [\event_1] \tracecat \trace' \tracecat [\event_2]
			\implies
			\eventdep(\event_1, \event_2, \trace, c, D) 
			\\ \quad 
			\implies 
			\left( \forall \event \in \trace' \st \neg \eventdep(\event_1, \event, \trace[\event_1:\event], c, D)
			\lor \neg \flowsto(\pi_1(\event)^{\pi_2(\event)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c) 
			\right) 
			\\ \quad 
			\implies 
			\flowsto(\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c)
		\end{array}
		\]
		\item
If $\event_2 \in \eventset^{\test}$, 
then for every $\event \in \trace'$, if it either doesn't have the \emph{Event May-Dependency} relations on $\event_1$,
or $\pi_1(\event) \notin VAR(\pi_1(\event_2)) $,
then 
$\pi_1(\event_1) \in VAR(\pi_1(\event_2))$, and $ {\pi_2(\event_1)} = \llabel(\trace)$
%
\[
\begin{array}{l}
	\forall D \in \dbdom , c \in \cdom, \trace \in \mathcal{T} \st \forall \event_1,\in \eventset^{\asn}, \event_2 \in \eventset^{\test} \st
	 \exists \trace' \in \mathcal{T} \st \trace = [\event_1] \tracecat \trace' \tracecat [\event_2]
	\implies
	\eventdep(\event_1, \event_2, \trace, c, D) 
	\\ \quad 
	\implies 
	\left( \forall \event \in \trace' \st 
	\neg \eventdep(\event_1, \event, \trace[\event_1:\event], c, D)
	\lor  \pi_1(\event) \notin VAR(\pi_1(\event_2))
	\right) 
	\\ \quad 
	\implies 
	\pi_1(\event_1) \in VAR(\pi_1(\event_2)) \land {\pi_2(\event_1)} = \llabel(\trace)
\end{array}
\]
\end{itemize}
\end{lem}
%
\begin{proof}
Taking arbitrary $D \in \dbdom , c \in \cdom$, and an assignment events $\event_1 \in \eventset^{\asn}$ and another event 
$\event_2\in \eventset$.
\\
Without loss of generalization, 
taking arbitrary trace has the form $\trace = [\event_1; \cdots; \event_2]$ for arbitrary $\trace_2 \in \mathcal{T}$,
 then we know $\exists \trace' \in \mathcal{T} \st \trace = [\event_1] \tracecat \trace' \tracecat [\event_2]$, let $\trace_2$ be this $\trace'$.
%
\caseL{$\event_2 \in \eventset^{\asn}$}
%
By the definition of $\eventdep(\event_1, \event_2, \trace, c, D)$, 
taking $ \event_1', \event_2' \in \eventset^{\asn},
\trace_2' \in \mathcal{T}, c_1, c_2 \in \cdom$ as the events, traces and commands satisfying the definition,
 we have following two executions:
% \[
%   \exists \event_1', \event_2' \in \eventset^{\asn},
%   \trace_2' \in \mathcal{T}, c_1, c_2 \in \cdom \st
% \]
%
\[
\begin{array}{l}
\config{c, \trace_0} \rightarrow^{*}
\config{c_1, \trace_1 \tracecat [\event_1]} \rightarrow^{*} \config{c_2, \trace_1 \tracecat [\event_1] \tracecat \trace_2 \tracecat [\event_2]} 
\\ \quad
% \land
\config{c_1, \trace_1 \tracecat [\event_1']} \rightarrow^{*} \config{c_2, \trace_1 \tracecat [\event_1'] \tracecat \trace_2' \tracecat [\event_2']} 
\end{array}
\]
%
%
By inversion Lemma.~\ref{lem:inv_event} on $\event_2$ and $\event_2'$ in the two executions
and $\diff(\event_2, \event_2)$,
 we have the following two execution instances:
\[
\config{c_1, \trace_1 \tracecat [\event_1]} \rightarrow^{*} \config{[\assign{\pi_1(\event_2)}{\expr_2 / \query(\qexpr_2)}]{}^{\pi_2(\event_2)};c_2, \trace_1 \tracecat [\event_1] \tracecat \trace_2} 
\rightarrow^\rname{asn / query} \config{c_2, \trace_1 \tracecat [\event_1] \tracecat \trace_2 \tracecat [\event_2]}  
\]
%
\[
\config{c_1, \trace_1 \tracecat [\event_1']} \rightarrow^{*} \config{[\assign{\pi_1(\event_2)}{\expr_2 / \query(\qexpr_2)}]{}^{\pi_2(\event_2)};c_2, \trace_1 \tracecat [\event_1'] \tracecat \trace_2'} 
\rightarrow^\rname{asn / query} \config{c_2, \trace_1 \tracecat [\event_1'] \tracecat \trace_2' \tracecat [\event_2']}  
\]
, where $\expr_2 / \qexpr_2$ is the expression of the assignment command associated to the $\event_2$ and $\event_2'$ by the Inversion Lemma.~\ref{lem:inv_event}.
\\
Taking arbitrary $\event_z \in \trace_2$, we know 
$\neg \eventdep(\event_1, \event, \trace[\event_1:\event_z], c, D)
\lor  \pi_1(\event_z) \notin VAR(\expr_2 / \qexpr_2)$.
\\
In case of $\neg \eventdep(\event_1, \event, \trace[\event_1:\event_z], c, D)$,
by Definition~\ref{def:event_dep}, we know $\event_z \in \trace_2'$ and 
\[
	\env(\trace_1 \tracecat \trace[\event_1:\event_z]) \pi_1(\event_z) = \env(\trace_1 \tracecat \trace[\event_1':\event_z]) \pi_1(\event_z)
	\]
%
In case of $ \pi_1(\event_z) \notin VAR(\expr_2 / \qexpr_2)$, by Inversion Lemma~\ref{lem:inv_expr}
 of arithmetic and query expression cases, we know:
%
\[
	\forall x^i \in \lvar, \trace, \trace' \in \mathcal{T}, v, v' \st
	\Big( \forall z^j \in \lvar / \{\pi_1(\event_z)^{\pi_2(\event_z)} \} \st 
	\env(\trace) z = \env(\trace') z \Big) \land 
	\config{\trace, \expr_2 / \qexpr_2} \aarrow v \land \config{\trace', \expr_2} \aarrow  v' \implies v = v'
	\]
	\[
		\forall x^i \in \lvar, \trace, \trace' \in \mathcal{T}, \qval, \qval' \st
		\Big( \forall z^j \in \lvar / \{\pi_1(\event_z)^{\pi_2(\event_z)} \} \st 
		\env(\trace) z = \env(\trace') z \Big) \land 
		\config{\trace, \qexpr_2} \qarrow \qval \land \config{\trace', \qexpr_2} \qarrow \qval' \implies \qval =_{q} \qval'
		\]
for $\expr_2$ or $\qexpr_2$ respectively.
\\
Let $\kw{use}_{\trace_2}$ a subset of the events in $\trace_2$, satisfying: 
\[
	\begin{array}{l}
		\forall \event \in \eventset^{\asn} \st 
	\event \in \kw{use}_{\trace_2} \Longleftrightarrow 
	\event \in \trace_2 \land
	\pi_1(\event) \in VAR(\expr_2 / \qexpr_2)
\end{array}		
\]
Then we also know for every $\event_z \in \kw{use}_{\trace_2}$, 
$\neg \eventdep(\event_1, \event_z, \trace[\event_1:\event_z], c, D)$, i.e.,:
\[
	\forall z^l \in \lvar \setminus 
	\big( 
		( \lvar_{\trace_2} \setminus \lvar_{\kw{use}_{\trace_2}}) \cup \{\pi_1(\event_1)^{\pi_2(\event_1)}\} \big)
	\st
	\env(\trace_1 \tracecat [\event_1] \tracecat \trace_2) z = \env(\trace_1 \tracecat [\event_1'] \tracecat \trace_2') z
	~ (1)
\]
 and
 \\ 
$
	\forall z^l \in \lvar \setminus ( \lvar_{\trace_2} \setminus \lvar_{\kw{use}_{\trace_2}}), 
	\trace, \trace' \in \mathcal{T}, v, v' \st 
	\env(\trace) z = \env(\trace') z 
	\land 
	\config{\trace, \expr_2} \aarrow v 
	\land 
	\config{\trace', \expr_2} \aarrow v'
	\implies 
	v = v' 
	~ (2a)
$;
\\
$
	\forall z^l \in \lvar \setminus ( \lvar_{\trace_2} \setminus \lvar_{\kw{use}_{\trace_2}}), 
	\trace, \trace' \in \mathcal{T}, \qval, \qval' \st 
	\env(\trace) z = \env(\trace') z 
	\land 
	\config{\trace, \qexpr_2} \qarrow \qval 
	\land 
	\config{\trace', \qexpr_2} \qarrow \qval'
	\implies 
	\qval =_q \qval' 
	~ (2q)
$,
\\
where $\lvar_{\trace_2}$ and $\lvar_{\kw{use}_{\trace_2}}$ are
 the sets of labelled variables of every event in $\trace_2$ and $\kw{use}_{\trace_2}$ respectively .
 %
Since $\diff(\event_2, \event_2')$, we also know:
%
\[	
\config{\trace_1 \tracecat [\event_1] \tracecat \trace_2, \expr_2} \aarrow \pi_3(\event_2)
\land 
\config{\trace_1 \tracecat [\event_1'] \tracecat \trace_2', \expr_2} \aarrow \pi_3(\event_2') 
\land 
\pi_3(\event_2) \neq \pi_3(\event_2')
\]
%
We know $\event_1$ is the only cause of the difference in $\event_y$ and $\event_y'$ when evaluating 
$[\assign{\pi_1(\event_2)}{\expr_2 / \query(\qexpr_2)}]{}^{\pi_2(\event_2)}$.
%
\\
By inversion Lemma.~\ref{lem:inv_expr_gnl} of arithmetic and query expression cases, 
given the two traces
$\trace_1 \tracecat [\event_1'] \tracecat \trace_2'$ and 
$\trace_1 \tracecat [\event_1'] \tracecat \trace_2'$ 
satisfying this lemma by $(1)$, $(2a)$ and $(2q)$, 
we know
\[
  \pi_1(\event_1) \in VAR(\expr_2 / \qexpr_2) \land {\pi_2(\event_1)} = \llabel(\trace_1 \tracecat [\event_1] \tracecat \trace_2) \pi_1(\event_1) 
\]
%
By $\flowsto$ definition:
% \todo{add the Liveness inversion}
\[
  \flowsto(\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_y)^{\pi_2(\event_y)}, c)
\]
This case is proved.
%
\caseL{$\event_2 \in \eventset^{\test}$}
\\
By the definition of $\eventdep(\event_1, \event_2, \trace, c, D)$, 
taking $ \event_1' \in \eventset^{\asn},
\trace_2' \in \mathcal{T}, c_1, c_2 \in \cdom$ and $\event_2' \in \eventset^{\test}$
 as the events, traces and commands satisfying the definition,
 we have following two executions:
% \[
%   \exists \event_1', \event_2' \in \eventset^{\asn},
%   \trace_2' \in \mathcal{T}, c_1, c_2 \in \cdom \st
% \]
%
\[
\begin{array}{l}
\config{c, \trace_0} \rightarrow^{*}
\config{c_1, \trace_1 \tracecat [\event_1]} \rightarrow^{*} \config{c_2, \trace_1 \tracecat [\event_1] \tracecat \trace_2 \tracecat [\event_2]} 
\\ \quad
% \land
\config{c_1, \trace_1 \tracecat [\event_1']} \rightarrow^{*} \config{c_2, \trace_1 \tracecat [\event_1'] \tracecat \trace_2' \tracecat [\event_2']} 
\end{array}
\]
%
Taking arbitrary $\event_z \in \trace_2$, we know 
$\neg \eventdep(\event_1, \event, \trace[\event_1:\event_z], c, D)
\lor  \pi_1(\event_z) \notin VAR(\expr_2 / \qexpr_2)$.
\\
Then by the same proof in \textbf{case: $\event_2 \in \eventset^{\asn}$}, and applying the Inversion Lemma~\ref{lem:inv_expr} and \ref{lem:inv_expr_gnl} of the boolean expression case,
we have:
\[ 
	\pi_1(\event_1) \in VAR(\pi_1(\event_2)) \land {\pi_2(\event_1)} = \llabel(\trace)
	\]
	This case is proved.
\end{proof}
%
%
\begin{lem}[While Loop Inversion]
	\label{lem:inv_while}
	For every $\trace, \trace' \in \mathcal{T}, c, c_1, c_2 \in \cdom$ 
	if $ \config{c, \trace} \rightarrow^* \config{c_1; c_2, \trace'}$ and 
	$c_1 \in_c c_2$, 
	then there must exist a $\ewhile$ command in $c_2$ and $c_1$ must shows up in the body of that $\ewhile$ command,
	 i.e., $\exists l \in \mathbb{N}, b \in \mathcal{B}, c_w \in \cdom \st 
	(\ewhile [b]^l \edo c_w) \in_c c_2 \land c_1 \in_c c_w$.
	%
	\[
	\begin{array}{l}
	\forall \trace, \trace' \in \mathcal{T}, c, c_1, c_2 \in \cdom \st
		\\ \quad
		\config{c, \trace} \rightarrow^* \config{c_1; c_2, \trace'}
		\implies
		c_1 \in_c c_2
		\implies
		\exists l \in \mathbb{N}, b \in \mathcal{B}, c_w \in \cdom \st 
		(\ewhile [b]^l \edo c_w) \in_c c_2 \land c_1 \in_c c_w
	\end{array}
	\]
	\end{lem}	
	Proof Summary: trivially by induction on $c$ and enumerate all operational semantic rules.
\begin{proof}
	Take arbitrary $\trace \in \mathcal{T}$, by induction on $c$, we have following cases:
		\caseL{$c = [\assign{x}{\expr}]^l$}
		By the evaluation rule $\rname{assn}$, we have
		$
		{
		\config{[\assign{{x}}{\aexpr}]^{l},  \trace } 
		\xrightarrow{} 
		\config{\eskip, \trace \tracecat [({x}, l, v) ]}
		}$.
		\\
		Since there doesn't exist $c_1, c_2 \in \cdom$ satisfying $\eskip = c_1; c_2$, this theorem is vacuously true.
		\caseL{$c = [\assign{x}{\query(\qexpr)}]^l$}
		By the evaluation rule $\rname{query}$, we have
		$
		{
		\config{[\assign{{x}}{\query(\qexpr)}]^{l},  \trace } 
		\xrightarrow{} 
		\config{\eskip, \trace \tracecat [({x}, l, \qval, v) ]}
		}$.
		\\
		Since there doesn't exist $c_1, c_2 \in \cdom$ satisfying $\eskip = c_1; c_2$, this theorem is vacuously true.
		\caseL{$c = \eif([b]^{l}, c_1, c_2)$}
		By the evaluation rule $\rname{query}$ and $\rname{if-f}$, and the label consistency, we know:
		\\
		for all possible $c_{t1}$ and $c_{t2}$ 
		such that $c_t$ has the form $c_t = c_{t1};c_{t2}$;
		\\
		all possible $c_{f1}$ and $c_{f2}$ 
		such that $c_f$ has the form $c_f = c_{f1};c_{f2}$,
		\\
		$c_{t1} \notin c_{t1}$ and $c_{f1} \notin c_{f2}$.
		\\
		Then this theorem is vacuously true.
		\caseL{$c = c_{s1};c_{s2}$}
		By label consistency, we know for every $c_1' \in_c c_{s1}$, $c_1' \notin c_{s2}$.
		\\
		Then by the induction hypothesis on $c_{s1}$ and $c_{s2}$ separately, we have this case proved.
		\caseL{$\ewhile [b]^{l} \edo c$}
		By rule $\rname{while-t}$, we have:
		\[
			\config{{\ewhile [b]^{l} \edo c_w, \trace}}
			\xrightarrow{} 
			\config{{
			c_w; \ewhile [b]^{l} \edo c_w,  \eskip),
			\trace \tracecat [\event]}}
		\]
		%
		If $c_w$ is a sequence command,
		let $c_1 = c_{w1}$ be the any possible command in this sequence, for all possible $c_{w1}$ and $c_{w2}$ 
		such that $c_w$ has the form $c_w = c_{w1};c_{w2}$.
		\\
		Then we have $c_2 = c_{w2};\ewhile [b]^{l} \edo c_w,  \eskip)$ and $c_1 \in_c c_2$.
		\\
		And we also have the existence of $l = l_b, b$ and $c_w$, and $\ewhile [b]^{l} \edo c_w \in_c c_2$ and  $c_1 \in c_w$.
		\\
		If $c_w$ isn't a sequence command, let $c_1 = c_w$, then we have $c_2 = \ewhile [b]^{l} \edo c_w,  \eskip)$ 
		and $c_1 \in_c c_2$.
		\\
		And we also have the existence of $l = l_b, b$ and $c_w$, and $\ewhile [b]^{l} \edo c_w \in_c c_2$ and  $c_1 \in c_w$.
		\\
		This case is proved.
		\\
		By the evaluation rule $\rname{while-f}$, we have
		$
		{
			\config{{\ewhile [b]^{l}, \edo c_w, \trace}}
			\xrightarrow{} 
			\config{{
			[\eskip]^l ,
			\trace \tracecat [((b, l, \efalse))]}}
		}$.
		\\
		Since there doesn't exist $c_1, c_2 \in \cdom$ satisfying $\eskip = c_1; c_2$, this theorem is vacuously true.
	\end{proof}
%
%
\begin{lem}[Only $\eskip$ Command doesn't Produce Event].
	\label{lem:inv_skip}
	For all trace $\trace\in \mathcal{T}$, and $c, c' \in \cdom$,  
	$\config{c, \trace} \rightarrow \config{c', \trace}$ if and only if $c = [\eskip];c'$. 
	\[
		\forall \trace\in \mathcal{T}, c, c' \in \cdom \st
		\config{c, \trace} \rightarrow \config{c', \trace}
		\Leftrightarrow 
		c = [\eskip];c'
	% \footnote{$([\eskip];){}^*$ denotes a sequence command only composed of $[\eskip]$ commands.}
	\]
	\end{lem}
\begin{proof}
	Proved trivially by induction on $c$ and enumerate all operational semantic rules.
\end{proof}
%
