%
%
%
\subsection{Dependency}
  
 To define the may dependency relation on two labeled variables, we rely on the limited information at hand - the trace generated by the operational semantics. In this end, we first define the \emph{May-Dependency} between events, and use it as a foundation of the variable may-dependency relation.
 
%  In order to distinguish if a query's choice is affected by previous values, 
% % \jl{we need to be able to identify whether two queries are the equivalent or not, so that when we change the result of one query, whether another query is affected. For the equivalence of queries, } 
% we need to be able to identify whether two queries are the equivalent or not,
%  by quantifying over all values returned from database on a certain form of query value and check the equivalence of the query value of different quantification, formally as follows.
% \begin{defn}[Equivalence of Query Expression]
% %
% \label{def:query_equal}
% % \mg{Two} \sout{2} 
% Two query expressions $\qexpr_1$, $\qexpr_2$ are equivalent, denoted as $\qexpr_1 =_{q} \qexpr_2$, if and only if
% % $$
% %  \begin{array}{l} 
% %   \exists \qval_1, \qval_2 \in \mathcal{QVAL} \st \forall \trace \in \mathcal{T} \st
% %     (\config{\trace,  \qexpr_1} \qarrow \qval_1 \land \config{\trace,  \qexpr_2 } \qarrow \qval_2) 
% %     \\
% %     \quad \land (\forall D \in \dbdom, r \in D \st 
% %     \exists v \in \mathcal{VAL} \st 
% %           \config{\trace, \qval_1[r/\chi]} \aarrow v \land \config{\trace,  \qval_2[r/\chi] } \aarrow v)  
% %   \end{array}.
% % $$
% $$
%  \begin{array}{l} 
%   \forall \trace \in \mathcal{T} \st \exists \qval_1, \qval_2 \in \mathcal{QVAL} \st
%     (\config{\trace,  \qexpr_1} \qarrow \qval_1 \land \config{\trace,  \qexpr_2 } \qarrow \qval_2) 
%     \\
%     \quad \land (\forall D \in \dbdom, r \in D \st 
%     \exists v \in \mathcal{VAL} \st 
%           \config{\trace, \qval_1[r/\chi]} \aarrow v \land \config{\trace,  \qval_2[r/\chi] } \aarrow v)  
%   \end{array}.
% $$
% % \mg{$$
% %  \begin{array}{l} 
% %    \forall \trace \in \mathcal{T} \st \exists \qval_1, \qval_2 \in \mathcal{QVAL} \st
% %     (\config{\trace,  \qexpr_1} \qarrow \qval_1 \land \config{\trace,  \qexpr_2 } \qarrow \qval_2) 
% %     \\
% %     \quad \land (\forall D \in \dbdom, r \in D \st 
% %     \exists v \in \mathcal{VAL} \st 
% %           \config{\trace, \qval_1[r/\chi]} \aarrow v \land \config{\trace,  \qval_2[r/\chi] } \aarrow v)  
% %   \end{array}.
% % $$
% % }
%  %
%  where $r \in D$ is a record in the database domain $D$. 
%   We denote by $\qexpr_1 \neq_{q} \qexpr_2$  the negation of the equivalence relation.
% % \\ 
% % where $r \in D$ is a record in the database domain $D$,
% % \mg{is  $FV(\qexpr)$ being defined here? If yes, I suggest to put it in a different place, rather than in the middle of another definition.} 
% % $FV(\qexpr)$ is the set of free variables in the query expression $\qexpr$.
% % \sout{$\qexpr_1 \neq_{q}^{\trace} \qexpr_2$  is defined vice versa.}
% % \mg{As usual, we will denote by $\qexpr_1 \neq_{q}^{\trace} \qexpr_2$  the negation of the equivalence.}
% %
% \end{defn}
%

% \mg{In the next definition you donâ€™t need the subscript e, it is clear that it is equivalence of events by the fact that the elements on the two sides of = are events. That is also true for query expressions. Also, I am confused by this definition. What happen for two query events?}
% \\
% \jl{The last component of the event is equal based on Query equivalence, $\pi_{4}(\event_1) =_q \pi_{4}(\event_2)$.
% In the previous version, the query expression is in the third component and I defined $v \neq \qexpr$ for all $v$ that isn't a query value.}
% \begin{defn}[Event Equivalence $\eventeq$]
% Two events $\event_1, \event_2 \in \eventset$ \mg{are equivalent, \sout{is in \emph{Equivalence} relation,}} denoted as $\event_1 \eventeq \event_2$ if and only if:
% \[
% \pi_1(\event_1) = \pi_1(\event_2) 
% \land  
% \pi_2(\event_1) = \pi_2(\event_2) 
% \land
% \pi_{3}(\event_1) = \pi_{3}(\event_2)
% \land 
% \pi_{4}(\event_1) =_q \pi_{4}(\event_2)
% \]
% %
% % \sout{The $\event_1 \eventneq \event_2$ is defined as vice versa.}
% % \mg{As usual, we will denote by $\event_1 \eventneq \event_2$  the negation of the equivalence.}
% \end{defn}
% \wq{Now we can compare two events by defining the event equivalence and difference relation.}
 We compare two events by defining the $\diff(\event_1, \event_2)$, we use $\qexpr_1 =_{q} \qexpr_2$ and $\qexpr_1 \neq_{q} \qexpr_2$ to notate query expression equivalence and inquivalence. 
% by defining the event equivalence and difference relation based on the query equivalence.
% \begin{defn}[Event Equivalence]
% \label{def:event_eq}
%   Two events $\event_1, \event_2 \in \eventset$ are equivalent, 
%   % denoted as $\event_1 \eventeq \event_2$ 
%   denoted as $\event_1 = \event_2$ 
%   if and only if:
%   \[
%   \pi_1(\event_1) = \pi_1(\event_2) 
%   \land  
%   \pi_2(\event_1) = \pi_2(\event_2) 
%   \land
%   \pi_{3}(\event_1) = \pi_{3}(\event_2)
%   \land 
%   \pi_{4}(\event_1) =_q \pi_{4}(\event_2)
%   \]
%   %
%   As usual, we will denote by $\event_1 \neq \event_2$  the negation of the equivalence.
%   % As usual, we will denote by $\event_1 \eventneq \event_2$  the negation of the equivalence.
%   % When it is clear from the context, we omit the subscript $\kw{e}$ and use 
%   % $\event_1 = \event_2$ (and $\event_1 \neq \event_2$) for event equivalent
% \end{defn}
%
%
% \begin{defn}[Signature Equivalence of Events $\sigeq$]

% Two events $\event_1, \event_2 \in \eventset$ is in \emph{signature equivalence} relation, denoted as $\event_1 \sigeq \event_2$ if and only if:
% \[
% \forall i \in \{1, 2, 3\} \st \pi_{\sig}(\event_1) = \pi_{\sig}(\event_2) 
% \]
% The $\event_1 \signeq \event_2$ is defined as vice versa.
% \end{defn}
%
% \begin{defn}[Events Different up to Value ($\diff$)]
% Two events $\event_1, \event_2 \in \eventset$ \mg{are \sout{is}} \emph{Different up to Value}, 
% denoted as $\diff(\event_1, \event_2)$ if and only if:
% \[
% \pi_1(\event_1) = \pi_1(\event_2) 
% \land  
% \pi_2(\event_1) = \pi_2(\event_2) 
% \land  
% \pi_3(\event_1) \neq_q \pi_3(\event_2)
% \]
% \end{defn}
\begin{defn}[Events Different up to Value ($\diff$)]
  Two events $\event_1, \event_2 \in \eventset$ are  \emph{Different up to Value}, 
  denoted as $\diff(\event_1, \event_2)$ if and only if:
  \[
    \begin{array}{l}
  \pi_1(\event_1) = \pi_1(\event_2) 
  \land  
  \pi_2(\event_1) = \pi_2(\event_2) \\
  \land  
  \big(
    (\pi_3(\event_1) \neq \pi_3(\event_2)
  \land 
  \pi_{4}(\event_1) = \pi_{4}(\event_2) = \bullet )
  % \qquad \qquad 
  \lor 
  (\pi_4(\event_1) \neq \bullet
  \land 
  \pi_4(\event_2) \neq \bullet
  \land 
  \pi_{4}(\event_1) \neq_q \pi_{4}(\event_2)) 
  \big)
  \end{array}
  \]
  \end{defn}
 %
For a program, its labeled variables and assigned variables are sub set of 
the labeled variables $\mathcal{LV}$.
% annotated by a label. 
We use  
%$\mathcal{LVAR} = \mathcal{VAR} \times \mathcal{L} $ 
% $\mathcal{LV}$ represents the universe of all the labeled variables and 
$\avar(c) \in \mathcal{P}(\mathcal{VAR} \times \mathbb{N}) \subset \mathcal{LV}$ and 
$\lvar(c) \in \mathcal{P}(\mathcal{VAR} \times \mathcal{L}) \subseteq \mathcal{LV}$ for them. $FV: \expr \to \mathcal{P}(\mathcal{VAR})$, computes the set of free variables in an expression. We also define the set of query variables for a program $c$, $\qvar: \cdom \to 
\mathcal{P}(\mathcal{LV})$.
% defined in Definition~\ref{def:lvar}.
% \begin{defn}[Assigned Variables (
% % $\avar_{c} \subseteq \mathcal{VAR} \times \mathbb{N}$ or 
% $\avar : \cdom \to \mathcal{P}(\mathcal{VAR} \times \mathbb{N})$,
% labelled Variables 
% (
% % $\lvar_{c} \subseteq \mathcal{VAR} \times \mathbb{N}$ or 
% $\lvar : \cdom \to \mathcal{P}(\mathcal{VAR} \times \mathcal{L})$]
% \label{def:avar}
% {\footnotesize
% $$ \avar_{c} \triangleq
%   \left\{
%   \begin{array}{ll}
%       \{{x}^l\}                   
%       & {c} = [{\assign x e}]^{l} 
%       \\
%       \{{x}^l\}                   
%       & {c} = [{\assign x \query(\qexpr)}]^{l} 
%       \\
%       \avar_{{c_1}} \cup \avar_{{c_2}}  
%       & {c} = {c_1};{c_2}
%       \\
%       \avar_{{c}} \cup \avar_{{c_2}} 
%       & {c} =\eif([\bexpr]^{l}, c_1, c_2) 
%       \\
%       \avar_{{c}'}
%       & {c}   = \ewhile ([\bexpr]^{l}, {c}')
% \end{array}
% \right.
% $$
% }
% \end{defn}
% %
% \begin{defn}[labelled Variables 
% (
% % $\lvar_{c} \subseteq \mathcal{VAR} \times \mathbb{N}$ or 
% $\lvar : \cdom \to \mathcal{P}(\mathcal{VAR} \times \mathcal{L})$]
% \label{def:lvar}
% {\footnotesize
% $$
%   \lvar_{c} \triangleq
%   \left\{
%   \begin{array}{ll}
%       \{{x}^l\} \cup FV(\expr)^{in}                  
%       & {c} = [{\assign x e}]^{l} 
%       \\
%       \{{x}^l\}   \cup FV(\qexpr)^{in}                
%       & {c} = [{\assign x \query(\qexpr)}]^{l} 
%       \\
%       \lvar_{{c_1}} \cup \lvar_{{c_2}}  
%       & {c} = {c_1};{c_2}
%       \\
%       \lvar_{{c}} \cup \lvar_{{c_2}} \cup FV(\bexpr)^{in}
%       & {c} =\eif([\bexpr]^{l}, c_1, c_2) 
%       \\
%       \lvar_{{c}'} \cup FV(\bexpr)^{in}
%       & {c}   = \ewhile ([\bexpr]^{l}, {c}')
% \end{array}
% \right.
% $$
% }
% \end{defn}
% \begin{defn}[
% Assigned Variables
% % ($\avar:\cdom \to \mathcal{P}(\mathcal{VAR} \times \mathbb{N})$,
% and Labeled Variables 
% % ($\lvar : \cdom \to \mathcal{P}(\mathcal{VAR} \times \mathcal{L})$
% ]
% \label{def:lvar}
% {\footnotesize
% $$ \avar_{c} \triangleq
%   \left\{
%   \begin{array}{ll}
%       \{{x}^l\}                   
%       & {c} = [{\assign x e}]^{l} 
%       \\
%       \{{x}^l\}                   
%       & {c} = [{\assign x \query(\qexpr)}]^{l} 
%       \\
%       \avar_{{c_1}} \cup \avar_{{c_2}}  
%       & {c} = {c_1};{c_2}
%       \\
%       \avar_{{c}} \cup \avar_{{c_2}} 
%       & {c} =\eif([\bexpr]^{l}, c_1, c_2) 
%       \\
%       \avar_{{c}'}
%       & {c}   = \ewhile ([\bexpr]^{l}, {c}')
% \end{array}
% \right.
% ~~
%   \lvar_{c} \triangleq
%   \left\{
%   \begin{array}{ll}
%       \{{x}^l\} \cup FV(\expr)^{in}                  
%       & {c} = [{\assign x e}]^{l} 
%       \\
%       \{{x}^l\}   \cup FV(\qexpr)^{in}                
%       & {c} = [{\assign x \query(\qexpr)}]^{l} 
%       \\
%       \lvar_{{c_1}} \cup \lvar_{{c_2}}  
%       & {c} = {c_1};{c_2}
%       \\
%       \lvar_{{c}} \cup \lvar_{{c_2}} \cup FV(\bexpr)^{in}
%       & {c} =\eif([\bexpr]^{l}, c_1, c_2) 
%       \\
%       \lvar_{{c}'} \cup FV(\bexpr)^{in}
%       & {c}   = \ewhile ([\bexpr]^{l}, {c}')
% \end{array}
% \right.
% $$
% }
% \end{defn}
% Free Variables:
% To be precise,
% $FV(\aexpr)$, $FV(\bexpr)$ and $FV(\qexpr)$ represent the set of free variables in arithmetic
% expression $\aexpr$, boolean expression $\bexpr$ and query expression $\qexpr$ respectively.
% Labeled variables in $c$ is the set of assigned variables and all the free variables
% showing up in $c$ with a default label $in$. 
% The free variables
% showing up in $c$, which aren't defined before be used, are actually the input variables of this program.
% \\
% It is easy to see that for any program $c$ in the {\tt Query While} language, its every labeled variable is unique.
% %
% \begin{lem}[Uniqueness of the Labeled Variables]
%   For every program $c \in \cdom$ and every two labeled variables such that
%   $x^i, y^j \in \lvar(c)$, then $x^i \neq y^j$.
% \end{lem}
%
% formally in Definition~\ref{def:qvar}.
% \mg{In the next definition, why do you call it a vector? It seems that you define it as a set.}\\
% \jl{fixed}\\
%
% \begin{defn}[Query Variables ($\qvar_{c} \subseteq \mathcal{VAR} \times \mathbb{N}$)].
  % \\
% \begin{defn}[Query Variables ($\qvar: \cdom \to \mathcal{P}(\mathcal{LV})$)] 
%   \label{def:qvar}
% Given a program $c$, its query variables 
% % \mg{it seems you are missing the $_c$ subscript. Also, this is a minor point but I don't think it is a good idea to use a subscript, cannot you just use $\qvar(c)$.}
% $\qvar(c)$ is the set of variables set to the result of a query in the program.
% % \jl{fixed}
% It is defined as follows:
% {\footnotesize
% $$
%   % \qvar_{{c}} \triangleq
%   \qvar(c) \triangleq
%   \left\{
%   \begin{array}{ll}
%       \{\}                  
%       & {c} = [{\assign x \expr}]^{l} 
%       \\
%       \{{x}^l\}                  
%       & {c} = [{\assign x \query(\qexpr)}]^{l} 
%       \\
%       \qvar(c_1) \cup \qvar(c_2)  
%       & {c} = {c_1};{c_2}
%       \\
%       \qvar(c_1) \cup \qvar(c_2) 
%       & {c} =\eif([\bexpr]^{l}, c_1, c_2) 
%       \\
%       \qvar(c')
%       & {c}   = \ewhile ([\bexpr]^{l}, {c}')
% \end{array}
% \right.
% $$
% }
% \end{defn}
%
It is easy to see that a program $c$'s query variables is a subset of 
its labeled variables, $\qvar(c) \subseteq \lvar(c)$. We have the operator $\tlabel : \mathcal{T} \to \ldom$, which gives the set of labels in every event belonging to a trace.
Then we introduce a counting operator $\vcounter : \mathcal{T} \to \mathbb{N} \to \mathbb{N}$, 
% \wq{which counts the occurrence of of a variable in the trace,} 
which counts the occurrence of of a labeled variable in the trace,
whose behavior is defined as follows,
% \[
% \begin{array}{lll}
% \vcounter(\trace :: (x, l, v, \bullet) ) l \triangleq \vcounter(\trace) l + 1
% &
% \vcounter(\trace  ::(b, l, v, \bullet) ) l \triangleq \vcounter(\trace) l + 1
% &
% \vcounter(\trace  :: (x, l, v, \qval) ) l \triangleq \vcounter(\trace) l + 1
% \\
% \vcounter(\trace  :: (x, l', v, \bullet) ) l \triangleq \vcounter(\trace ) l, l' \neq l
% &
% \vcounter(\trace  :: (b, l', v, \bullet) ) l \triangleq \vcounter(\trace ) l, l' \neq l
% &
% \vcounter(\trace  :: (x, l', v, \qval)) l \triangleq \vcounter(\trace ) l, l' \neq l
% \\
% \vcounter({[]}) l \triangleq 0
% &&
% \end{array}
% \]
\[
\begin{array}{lll}
\vcounter(\trace :: (\_, l, \_, \_), l ) \triangleq \vcounter(\trace, l) + 1
&
% \vcounter(\trace  ::(b, l, v, \bullet), l) \triangleq \vcounter(\trace, l) + 1
% &
% \vcounter(\trace  :: (x, l, v, \qval), l) \triangleq \vcounter(\trace, l) + 1
% \\
\vcounter(\trace :: (\_, l', \_, \_), l ) \triangleq \vcounter(\trace, l), l' \neq l 
&
% \vcounter(\trace, l) + 1
% \vcounter(\trace  :: (x, l', v, \bullet), l) \triangleq \vcounter(\trace, l), l' \neq l
% &
% \vcounter(\trace  :: (b, l', v, \bullet), l) \triangleq \vcounter(\trace, l), l' \neq l
% &
% \vcounter(\trace  :: (x, l', v, \qval), l) \triangleq \vcounter(\trace, l), l' \neq l
% \\
\vcounter({[]}, l) \triangleq 0
\end{array}
\]
The full definitions of these above operators can be found in the appendix.
%
\highlight{
\begin{defn}[Value Sequence $\seq(\trace, x^l)$]
  \label{def:vseq}
  \[
\begin{array}{l}
  \seq(\trace :: (x, l, v, \bullet), x^l) \triangleq \seq(\trace)::v  \qquad
  \seq(\trace :: (x, l, v, \qval), x^l) \triangleq \seq(\trace):: \qval \qquad
  \seq([]) \triangleq []\\
  \seq(\trace :: (y, j, \_, \_), x^l) \triangleq \seq(\trace) \quad y \neq x \lor j \neq l 
\end{array}
\]
\end{defn}
%
\begin{defn}[Difference Sequence $\sdiff(\trace_1, \trace_2, x^l )$]
  \label{def:diffseq}
  Let $ s_1 = \seq(\trace_1, x^l) \land s_2 = \seq(\trace_2, x^l)$ be the value sequence of $x^l$ 
  on $\trace_1$ and $\trace_2$, and $s_{max}$ be the sequence with longer length and $s_{min}$ the 
  shorter one,
  then their difference sequence is defined as follows,
  \[
    \sdiff(\trace_1, \trace_2, x^l) \triangleq
    \begin{array}{l}
      \{ (s_{min}[k], s_{max}[k]) ~|~ 
      % \land 
      % \land 
      s_{min}[k] \neq s_{max}[k], k = 0, \ldots, len(s_{min})
      \}
      \\
      \cup 
      \{ (\cdot, s_{max}[k]) ~|~ 
      \len(s_{min}) \leq \len(s_{max})k = len(s_{min}), \ldots \len(s_{max})
      \}
    \end{array}
    \]
\end{defn}
}
%
%  based on the trace-based operational semantics,
% by considering all the possible execution traces.
%   as well as the program's \emph{Adaptivity} based on this \emph{May-Dependency} relation. \wq{   }
% \\
% \mg{Also, is $\event_2$ or $\event_2'$ in the last line of the first block?}
% \jl{$\event_2'$, fixed}
\begin{defn}[Event May-Dependency].
\label{def:event_dep}
\\ 
  An event $\event_2$ is in the \emph{event may-dependency} relation with an assignment
  event $\event_1 \in \eventset^{\asn}$ in a program ${c}$
  with a hidden database $D$ and a trace $\trace \in \mathcal{T}$ denoted as 
  %
  $\eventdep(\event_1, \event_2, [\event_1 ] \tracecat \trace \tracecat [\event_2], c, D)$, iff
  %
  \[
    \begin{array}{l}
  \exists \vtrace_0,
  \vtrace_1, \vtrace' \in \mathcal{T},\event_1' \in \eventset^{\asn}, {c}_1, {c}_2  \in \cdom  \st
  \diff(\event_1, \event_1') \land 
      \\ \quad
      (
        \exists  \event_2' \in \eventset \st 
    \left(
    \begin{array}{ll}   
   & \config{{c}, \vtrace_0} \rightarrow^{*} 
  \config{{c}_1, \vtrace_1 \tracecat [\event_1]}  \rightarrow^{*} 
    \config{{c}_2,  \vtrace_1 \tracecat [\event_1] \tracecat \vtrace \tracecat [\event_2] } 
    % 
   \\ 
   \bigwedge &
    \config{{c}_1, \vtrace_1 \tracecat [\event_1']}  \rightarrow^{*} 
    \config{{c}_2,  \vtrace_1 \tracecat[ \event_1'] \tracecat \vtrace' \tracecat [\event_2'] } 
  \\
  \bigwedge & 
  \diff(\event_2,\event_2' ) \land 
  \vcounter(\vtrace, \pi_2(\event_2))
  = 
  \vcounter(\vtrace', \pi_2(\event_2'))\\
  \end{array}
  \right)
  \\ \quad
  \lor 
  \exists \vtrace_3, \vtrace_3'  \in \mathcal{T}, \event_b \in \eventset^{\test} \st 
  \\ \quad
  \left(
  \begin{array}{ll}   
    & \config{{c}, \vtrace_0} \rightarrow^{*} 
      \config{{c}_1, \vtrace_1 \tracecat [\event_1]}  \rightarrow^{*} 
      \config{c_2,  \vtrace_1 \tracecat [\event_1] \tracecat \trace \tracecat [\event_b] \tracecat  \trace_3} 
    \\ 
    \bigwedge &
    \config{{c}_1, \vtrace_1 \tracecat [\event_1']}  \rightarrow^{*} 
    \config{c_2,  \vtrace_1 \tracecat [\event_1'] \tracecat \trace' \tracecat [(\neg \event_b)] \tracecat \trace_3'} 
    \\
    \bigwedge &  \tlabel_{\trace_3} \cap \tlabel_{\trace_3'} = \emptyset
     \land \vcounter(\trace', \pi_2(\event_b)) = \vcounter(\trace, \pi_2(\event_b)) 
    %   \land \event_2 \eventin \trace_3
    % \land \event_2 \not\eventin \trace_3'
    \land \event_2 \in \trace_3
    \land \event_2 \not\in \trace_3'
  \end{array}
  \right)
  )
\end{array}
   \]
% , where ${\tt label}(\event_2) = \pi_2(\event_2)$.
  %  
%
\end{defn}
% \todo{add explnanation}
% \jl{
Our event \emph{May-Dependency} relation of 
two events $\event_1 \in \eventset^{\asn}$ and $\event_2 \in \eventset$, 
for a program $c$ and hidden data base $D$ is w.r.t to
a trace $[\event_1 ] \tracecat \trace \tracecat [\event_2]$.
$\event_1 \in \eventset^{\asn}$ is an assignment event, because only a change on the assignment event will affect the execution trace, according to our operational semantics.
In order to observe the changes of $\event_2$ under the modification of $\event_1$, this trace 
$[\event_1 ] \tracecat \trace \tracecat [\event_2]$
starts with $\event_1$ and ending with $\event_2$.
% }
{The \emph{May-Dependency} relation considers both the value dependency and value control dependency as discussed above.
% in Section~\ref{sec:design_choice}. 
The relation can be divided into two parts naturally in Definition~\ref{def:event_dep}(line $2-4$, $5-8$ respectively, we think it start from line $1$). The idea of the event $\event_1$ may depend on $\event_2$ can be briefly described:
We have one execution of the program as reference (See line $2$ and $6$ , for the two kinds of dependency). 
When the value assigned to the 
% first variable 
first variable in $\event_1$ is modified, the reference trace $\trace_1 \tracecat [\event_1]$ is modified correspondingly as $\trace_1 \tracecat [\event_1']$.
We use $\diff(\event_1, \event_1')$ at line $1$ to express this modification, which guarantees that $\event_1$ and $\event_1'$ only differ in their assigned value and are equal on variable name and label. We perform a second run of the program by continuing the execution of the same program from the same execution point, 
but with the modified trace $\trace_1 \tracecat [\event_1']$ (See line $3$, $7$). 
The expected may dependency will be caught by observing two different possible changes (See line $4, 8$ respectively) when comparing the second execution with the reference one. 

% \wq{
% In the first situation, we are witnessing 
In the first part, (line $2-4$ of Definition~\ref{def:event_dep}) we witness
% that the value assigned to the second variable in $\event_2$
the appearance of $\event_2'$ in the second execution, and
% a variation in $\event_2$, which changes into $\event_2'$.
a variation between $\event_2$ and $\event_2'$ on their value.
% changes in $\event_2'$.
% \jl{
We have special requirement $\diff(\event_2, \event_2')$,
, which guarantees that they
have the same variable name and label but only differ 
% % in their assigned value. 
in their evaluated values.
% assigned to the same variable. 
In particularly for query, if $\event_2$ and $\event_2'$ are 
% query assignment events, then 
generated from query requesting, then $\diff(\event_2, \event_2)$ guarantees that
they differ in their query value rather than the 
% query requesting value. 
query requesting result. 
Additionally, in order to handle the multiple occurrence of the same event through iterations of the while loop,
 where  $\event_2$ and $\event_2'$ could be 
in different while loop,
we restrict the occurrence times of $\event_2$'s label in the first(reference) trace equals to the occurrence times of $\event_2'$'s label in the second trace,
through $\vcounter(\vtrace, \pi_2(\event_2))
= 
\vcounter(\vtrace', \pi_2(\event_2'))$.
% }
% }

% \wq{
In the second part (line $5-8$ of Definition~\ref{def:event_dep}) , we 
% are witnessing 
witness
the disappearance of $\event_2$ through observing the change of a testing event $\event_b$.
In order to change the appearance of 
% and event, the command that generating $\event_2$ must not be executed in 
5yhan event, the command that generates $\event_2$ must not be executed in 
the second execution. 
The only way to control whether a command will be executed, is through the change of a guard's 
evaluation result in the if or while command.
So we first observe the testing event $\event_b$ changes into $\neg \event_b$ in the second execution, 
following with the disappearance of $\event_2$ in the second trace.
\\
In the same way, we restrict the occurrence times of $\event_b$'s label in the two traces being equal
}
% s to the occurrence times of $\event_2'$'s label in the second trace,
through $\vcounter(\trace', \pi_2(\event_b)) = \vcounter(\trace, \pi_2(\event_b)) $ to handle the while loop.
% changes in $\event_2'$, have the same variable and label and only differ in their assigned value. 
Again, in particularly for query, we observe the disappearance based on the query value equivalence.
% if $\event_2$ and $\event_2'$ are query assignment events, then 
% they differ in their query value rather than the assigned value. 
% }
%
% \mg{I don't understand this explanation. What are the ``assignment commands associated to the two labelled variables''}
% \jl{revised but need more think}
% Explanation: 
{Considering a program's all possible executions(with respect to initialized user input),
among all events generated during these executions
and the variables and labels of these events are 
corresponding to the two labeled variables,
% evaluations of the assignment commands associated to the two labelled variables respectively, 
as long as there is one pair of events satisfying the \emph{Event May-Dependency} relation in Definition~\ref{def:event_dep}, 
then we say the two variables satisfy \emph{Variable May-Dependency} relation in Definition~\ref{def:var_dep}.
}

\begin{defn}[Variable May-Dependency].
  \label{def:var_dep}
  \\
  A variable ${x}_2^{l_2} \in \lvar(c)$ is in the \emph{variable may-dependency} relation with another
  variable ${x}_1^{l_1} \in \lvar(c)$ in a program ${c}$, denoted as 
  %
  $\vardep({x}_1^{l_1}, {x}_2^{l_2}, {c})$, if an only if.
  %
\[
  \begin{array}{l}
\exists 
\event_1, \event_2 \in \eventset^{\asn}, \trace \in \mathcal{T} , 
D \in \dbdom \st
% (\pi_{1}{(\event_1)}, \pi_{2}{(\event_1)}) = ({x}_1, l_1)
% \land
% (\pi_{1}{(\event_2)}, \pi_{2}{(\event_2)}) = ({x}_2, l_2)
\pi_{1}{(\event_1)}^{\pi_{2}{(\event_1)}} = {x}_1^{l_1}
\land
\pi_{1}{(\event_2)}^{\pi_{2}{(\event_2)}} = {x}_2^{l_2}% \\ \quad 
\land 
\eventdep(\event_1, \event_2, \trace, c, D) 
  \end{array}
\]  
\highlight{
  A variable $y^j \in \lvar(c)$ is in the \emph{may-dependency} relation with another
  variable $x^i \in \lvar(c)$ in a program ${c}$, w.r.t. an initial trace $\trace_0 \in \mathcal{T_0}(c)$
  and two witness traces $\trace_1, \trace_2 \in \mathcal{T}$,
  denoted as 
  %
  $\dep(x^i, y^j, \trace_1, \trace_2, \trace_0, {c})$, if an only if
  \[
    \begin{array}{l}
  \exists 
  % \event_1, \event_2 \in \eventset^{\asn}, \trace \in \mathcal{T} , 
  D \in \dbdom, 
  \trace_0' \in \mathcal{T} \st
  % \event_1' \in \eventset^{\asn}, {c}_1  \in \cdom \st
  % \\ \quad 
  % (\pi_{1}{(\event_1)}, \pi_{2}{(\event_1)}) = ({x}_1, l_1)
  % \land
  % (\pi_{1}{(\event_2)}, \pi_{2}{(\event_2)}) = ({x}_2, l_2)
  % \pi_{1}{(\event_1)}^{\pi_{2}{(\event_1)}} = {x}_1^{l_1}
  % \land
  % \pi_{1}{(\event_2)}^{\pi_{2}{(\event_2)}} = {x}_2^{l_2}% 
  % \land 
  % % \exists \vtrace_0' \in \mathcal{T},\event_1' \in \eventset^{\asn}, {c}_1  \in \cdom  \st
  % \diff(\event_1, \event_1') 
  % \env(\trace_0, x^i) \neq   \env(\trace_0', x^i) 
  % \land 
  (\forall z^l \neq x^i \st   \env(\trace_0, z^l ) =   \env(\trace_0',z^l) )
  \land 
  % \\ \quad \land 
   \config{{c}, \vtrace_0} \rightarrow^{*} 
  % \config{{c}_1, \vtrace_0' \tracecat [\event_1]}  \rightarrow^{*} 
    \config{\clabel{\eskip}^l, \vtrace_0  \tracecat \trace_1 } 
    % \vtrace_0' \tracecat [\event_1] \tracecat \trace_1 } 
    % 
    % \\ \quad 
    \land 
    % \config{{c}_1, \vtrace_0' \tracecat [\event_1']}  \rightarrow^{*} 
    % \config{\clabel{\eskip}^l,  
    % \vtrace_0' \tracecat [\event_1] \tracecat \trace_2 }   
    \config{{c}, \vtrace_0'} \rightarrow^{*} 
    % \config{{c}_1, \vtrace_0' \tracecat [\event_1]}  \rightarrow^{*} 
      \config{\clabel{\eskip}^l, \vtrace_0'  \tracecat \trace_2} 
    \\ \quad \land 
      \sdiff(\trace_1, \trace_2, y^j ) \neq \emptyset
    \end{array}
  \]  
}%
% , where $\eventdep$ is defined in Definition~\ref{def:event_dep}.
  % , where $\eventdep^{val}$ and $\eventdep^{\test}$ is defined in \ref{def:event_valdep} and \ref{def:event_ctldep}.
  % %
  %
  \end{defn}
%
We denote $\mathcal{T}_0(c)$ as the set of initial traces in which all the input variables in $c$ are initialized.
%
\subsection{Execution Based Dependency Graph}
\label{sec:execution-base-graph-def}
%
%
%
%
The variable \emph{May-Dependency} relation gives us the edges, we define the execution based dependency graph.
% \wq{Just a few sentences here, some overview of this subsection. See 4.2 for instance.}
\begin{defn}[Execution Based Dependency Graph]
\label{def:trace_graph}
Given a program ${c}$,
its \emph{Execution-Base Dependency Graph} 
$\traceG({c}) = (\traceV({c}), \traceE({c}), \traceW({c}), \traceF({c}))$ is defined as follows,
% over all possible traces,
%
\highlight{\small
\[
\begin{array}{rlcl}
  \text{Vertices} &
  \traceV({c}) & := & 
  \{ 
  (x^l, w) 
  % \in \mathcal{LV} \times \mathbb{N}
  ~ \vert ~ 
  w : \mathcal{T} \to \mathbb{N}
  \land
  x^l \in \lvar(c) 
  \\ & & &
  \land
  % n = \max \left\{ 
    % ~ \middle\vert~
  \forall \trace \in \mathcal{T}_0(c), \trace' \in \mathcal{T} \st \config{{c}, \trace} \to^{*} \config{\eskip, \trace\tracecat\vtrace'} 
  \implies w(\trace) = \vcounter(\vtrace', l) 
  %  \right\}
%   \right
\}
  \\
  \text{Edges} &
  \traceE({c}) & := & 
  \{ 
  (x^i, w, y^j) 
%   \in \mathcal{LV} \times \mathcal{LV}
  ~ \vert ~
  x^i, y^j \in \lvar(c)
  \land w \in \mathcal{P}( \mathcal{T} \to \mathbb{N})
  \land 
  \exists \trace \in \mathcal{T}_0(c), 
  \trace_1, \trace_2 \in \mathcal{T} \st \dep(x^i, y^j,\trace_1, \trace_2, \trace_0, c)
  \\ & & &
  \forall \trace_0 \in \mathcal{T}_0(c) \st
  w (\trace_0) = \max\{|\sdiff(\trace_1, \trace_2, y)|
  \forall \trace_1, \trace_2 \in \mathcal{T} \st \dep(x^i, y^j,\trace_1, \trace_2, \trace_0, c) \}
  % \text{\mg{$\land$ instead of ,}}
  \}
\end{array}.
\]
}
\end{defn}
There are two components of the execution-based dependency graph. 
\highlight{
The vertices $\traceV(c)$  is a set of pairs, $(x^l, w) \in \mathcal{LV} \times (\mathcal{T} \to \mathbb{N})$,
with a labeled variable as first component and
its weight $w$ the second component.
Weight $w$ for
% a labeled variable 
$x^l$ is a function $w : \mathcal{T} \to \mathbb{N}$
mapping from a starting trace to a natural number.
When program executes under this starting trace $\trace$,
$\config{{c}, \trace} \to^{*} \config{\eskip, \trace\tracecat\vtrace'} $, it generates an execution trace $\trace'$.
This natural number is the evaluation times of the labeled command corresponding to the vertex, 
computed by the counter operator $w(\trace) = \vcounter(\vtrace', l)$.
We can see in the execution-based dependency graph of $\kw{twoRounds}$ in
 Figure~3(b) in main paper, the weight of vertices in the while loop is  $\env(\trace) k$, which depends on the value of the user input $k$ specified in the starting trace $\tau$.
The directed edges $\traceE({c})$ is also a set of pairs with two labeled variables $ (x^i, y^j) \in \mathcal{LV} \times \mathcal{LV}$, from $x^i$ pointing to $y^j$ in the graph.
% with The directed edges $E$ 
% comes 
The edges are constructed directly from our variable may-dependency relation. 
For any two vertices $x^{i}$ and $y^{j}$ in $\traceV(c)$, if there exists two witness traces $\trace_1, \trace_2$ and an initial trace $\trace_0 \in \mathcal{T}_0$ such that,
they satisfy the variable may-dependency relation 
$\dep(x^i, y^j, \trace_1, \trace_2, \trace_0, c)$ , 
there is a direct edge. 
The weight of the edge is a function $w: \mathcal{T}_0 \to \mathbb{N}$,
where given an initial trace $\trace_0$,
it  of the edge is the maximum length of their difference sequence between all pairs of the witness traces $\trace_1, \trace_2$ of their dependency relation.
}
In most data analysis programs $c$ we are interested, there are usually some user input variables, such as $k$ in $\kw{twoRounds}$. 
We denote $\mathcal{T}_0(c)$ as the set of initial traces in which all the input variables in $c$ are initialized, it is also reflected in $\traceW({c})$.    


\subsection{Trace-based Adaptivity}
Given 
a program $c$'s execution-based dependency graph 
% $G_{trace}(c)(\trace) = (\vertxs, \edges, \weights, \qflag)$,
$\traceG({c})$,
we define adaptivity 
with respect to an initial trace $\trace_0 \in \mathcal{T}_0(c)$ by the finite walk in the graph, which has the most query requests along the walk.
We show the definition of a finite walk as follows.
%
% The query length of a walk $k$ is the number of vertices which correspond to query variables in the vertices sequence of this walk. 
% Instead of counting all 
% the vertices in $k$'s vertices sequence, i

  \begin{defn}[Finite Walk (k)].
  \label{def:finitewalk}
  \\
  Given the execution-based dependency graph $\traceG({c}) = (\traceV({c}), \traceE({c}), \traceW({c}), \traceF({c}))$ of a program $c$,
  a \emph{finite walk} $k$ in $\traceG({c})$ is a 
  function $k: \mathcal{T} \to $ sequence of edges.
  For a initial trace $\trace_0 \in \mathcal{T}_0(c)$, 
  $k(\trace_0)$ is a sequence of edges $(e_1 \ldots e_{n - 1})$ 
  for which there is a sequence of vertices 
  $(v_1, \ldots, v_{n})$ such that:
  \begin{itemize}
      \item \highlight{
        $e_i = (v_{i}, w_i, v_{i + 1}) \in \traceE(c)$ for every $1 \leq i < n$, 
        and $e_i$ appears in $(e_1 \ldots e_{n - 1})$  at most $w_i(\trace_0)$
        times.
      }
      \item every $(v_i, w_i) \in \traceV(c)$
      % and $(v_i, w_i) \in \traceW(c)$, 
       and $v_i$ appears in $(v_1, \ldots, v_{n})$ at most 
    %   \wq{$\traceW({c})(\trace)$} 
    $w_i(\trace_0)$
      times.  
  \end{itemize}
  %
  The length of $k(\trace_0)$ is the number of vertices in its vertices sequence, i.e., $\len(k)(\trace_0) = n$.
 \end{defn}

We use $\walks(\traceG(c))$ to denote 
% \mg{``the set'', not ``a set''}a set containing all finite walks $k$ in $G$;
the set containing all finite walks $k$ in $\traceG(c)$;
and $k_{v_1 \to v_2} \in \walks(\traceG(c))$ with $v_1, v_2 \in \traceV(c)$ denotes the walk from vertex $v_1$ to $v_2$ . 
\\
We are interested in queries, so we need to recover the 
variables corresponding to queries from the walk. We define the query length of a walk, 
instead of counting all 
the vertices in $k$'s vertices sequence, we just count the number of vertices which correspond to query variables in this sequence.
%
% \mg{I don't understand this definition. Is wrt a single query?if yes, who is chosing the query? Or is it any query?}
% \jl{It is for any query, as long as the vertex is a query variable, in another worlds, this length just counting the number of query variables in the walk, instead of counting all 
% the vertices.}
% \todo{Make the definition clear}
\begin{defn}[Query Length of the Finite Walk($\qlen$)].
\label{def:qlen}
\\
Given 
% labelled weighted graph $G = (\vertxs, \edges, \weights, \qflag)$, 
the execution-based dependency graph $\traceG({c}) = (\traceV({c}), \traceE({c}), \traceW({c}), \traceF({c}))$ of a program $c$,
 and a \emph{finite walk} 
%  $k$ in $\traceG(c)(\trace)$
 $k \in \walks(\traceG(c))$. 
%  with its vertex sequence $(v_1, \ldots, v_{n})$, 
%  the length of $k$ w.r.t query is defined as:
The query length of $k$ is a function $\qlen(k): \mathcal{T} \to \mathbb{N}$, such that with an initial trace  $\trace_0 \in \mathcal{T}_0(c)$, $\qlen(k)(\trace_0)$ is
the number of vertices which correspond to query variables in the vertices sequence of the walk $k(\trace_0)$
$(v_1, \ldots, v_{n})$ as follows, 
\[
  \qlen(k)(\trace_0) = |\big( v \mid v \in (v_1, \ldots, v_{n}) \land \qflag(v) = 1 \big)|.
\]
% , where $\trace_0 \in \mathcal{T}$ is the initial trace and $\big(v \mid v \in (v_1, \ldots, v_{n}) \land \qflag(v) = 1 \big)$ is a subsequence of $(v_1, \ldots, v_{n})$.
%  $k$'s vertex sequence.
% \mg{If I understand where you want to go, why don't you just use the cardinality of the set above, rather than taking the length of a subsequence?}
% \jl{because the same vertex could have multiple occurrence in the sequence, and we will count all the occurrence instead of just once.
% So the cardinality of set doesn't work.}
\end{defn}
%
\subsection{Example From Limitation}
% \input{multipleRoundsSingleAccurate}
