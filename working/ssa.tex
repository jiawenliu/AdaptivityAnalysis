\section{Labeled SSA Language}
%
{
\subsection{The Limit of {\tt While} Language}
we see the power of the labelled loop language to achieve the adaptivity semantically, from its being capable to express many adaptive data analysis algorithm,  allowing the construction of the query-based dependency graph using traces from the execution, and so on.
However, it is not powerful enough to reach the adaptivity syntactically. The main difficulty is its implicit control flow which raises extra complexity to figure out where some variables used come from. We use three simple but relevant examples to show why the loop language suffers. We use $\query(0),\query(1)$ to represent linear queries.
%
\[
 c_1 = \begin{array}{l}
      \clabel{ \assign{x}{\query(0)}}^{1} ; \\
      \eif  [(x < 0 )]^{2} \\
      \ethen \clabel{\assign{x}{\query(1)}}^{3}\\
      \eelse \clabel{\eskip}^{4} ; \\
      \clabel{\assign{y}{\query(x+\chi(3))}}^{5}
 \end{array}
 ~~~~~
 c_2 = \begin{array}{l}
      \clabel{ \assign{x}{\query(0)}}^{1} ; \\
      \eif  [(x < 0 )]^{2} \\
      \ethen \clabel{\assign{x}{\query(1)}}^{3}\\
      \eelse \clabel{\assign{x}{\query(2)}}^{4} ; \\
      \clabel{\assign{y}{\query(x+\chi(3))}}^{5}
 \end{array}
 ~~~~~~~~
  c_3 = \begin{array}{l}
      \clabel{ \assign{x}{\query(0)}}^{1} ; \\
      \eif  [(x < 0 )]^{2} \\
      \ethen \clabel{\assign{z}{\query(1)}}^{3}\\
      \eelse \clabel{\eskip}^{4} ; \\
      \clabel{\assign{y}{\query(x+\chi(3)}}^{5}
 \end{array}
\]
In these three examples, the variable $x$ at line $5$ is implicit. In program $c_1$, it refers to the either $x$ at line $1$, or $x$ at line $3$, which means the result of query request $\query(x+\chi(3))$ assigned to the variable $y$ may depend on $\query(0)$(bound to $x$ at line $1$) or $\query(1)$($x$ at line $3$). When we have a look at the other two programs $c_2$ and $c_3$, it is another talk. We think $\query(x+\chi(3))$ may depend on either $\query(1)$($x$ at line $3$) or $\query(x+\chi(3))$($x$ at line $4$) in $c_2$,     
while $\query(x+\chi(3))$ only depends on $\query(0)$ at line $1$ in program $c_3$. 
These three examples are structural similar in loop language, however, the dependency between variables are quite dissimilar. We consider variables here because query request is also bound to variables. To solve this dilemma, we move to single static assignment as follows.   
\[
 c_1^{ssa} = \begin{array}{l}
      \clabel{ \assign{{\ssa{x}_1}}{\query(0)}}^{1} ; \\
      \eif  [({\ssa{x_1} }< 0 )]^{2}\\
      ([], [{ \ssa{x_3, x_1,x_2} }], []) \\
      \ethen \clabel{\assign{{\ssa{x_2}}}{\query(1)}}^{3}\\
      \eelse \clabel{\eskip}^{4} ; \\
      \clabel{\assign{{\ssa{y_1}}}{\query({\ssa{x_3} + \chi(3)})}}^{5}
 \end{array}
 ~~~~~
  c_2^{ssa} = \begin{array}{l}
      \clabel{ \assign{{\ssa{x_1}}}{\query(0)}}^{1} ; \\
      \eif  [({\ssa{x_1}} < 0 )]^{2}, \\
      ( [{\ssa{x_4, x_2,x_3}}], [], [] ) \\
      \ethen \clabel{\assign{{\ssa{x_2}}}{\query(1)}}^{3}\\
      \eelse \clabel{\assign{{\ssa{x_3}}}{\query(2)}}^{4} ; \\
      \clabel{\assign{{\ssa{y_1}}}{\query({\ssa{x_4}}+\chi(3))}}^{5}
 \end{array}
 ~~~~~~~~
  c_3^{ssa} = \begin{array}{l}
      \clabel{ \assign{{\ssa{x_1}}}{\query(0)}}^{1} ; \\
      \eif  [({\ssa{x_1}} < 0 )]^{2} \\
       ( [], [], [] ) \\
      \ethen \clabel{\assign{{\ssa{z_1}}}{\query(1)}}^{3}\\
      \eelse \clabel{\eskip}^{4} ; \\
      \clabel{\assign{{\ssa{y_1}}}{\query({\ssa{x_1}}+\chi(3))}}^{5}
 \end{array}
\]
To distinguish between the loop language and in ssa form, we denote the ssa variable ${\ssa{x_1}}$ in bold. As we can see, the data flow becomes explicit in ssa form and the analysis on the dependency between variables in the program becomes much clear now. Considering this advantage, we aim to estimate the adaptivity through an analysis on program in ssa form. 
}
%s
%
\subsection{SSA form Language}
\[
\begin{array}{llll}
 \mbox{Arithmetic Operators} 
& \oplus_a & ::= & + ~|~ - ~|~ \times 
%
~|~ \div \\  
\mbox{Boolean Operators} 
& \oplus_b & ::= & \lor ~|~ \land
\\
  %
\mbox{Relational Operators} 
& \sim & ::= & < ~|~ \leq ~|~ == 
\\  
%
\mbox{Label} 
& l & := & \mathbb{N} 
\\ 
%
\mbox{SSA Arithmetic Expression} 
& \saexpr & ::= & 
n ~|~ \ssa{x} ~|~ \saexpr \oplus_a \saexpr  
\\
%
\mbox{SSA Boolean Expression} & \sbexpr & ::= & 
	%
	\etrue ~|~ \efalse  ~|~ \neg \sbexpr
	 ~|~ \sbexpr \oplus_b \sbexpr
	%
	~|~ \saexpr \sim \saexpr 
	\\
%
\mbox{SSA Query Expression} 
& \ssa{\qexpr} & ::= 
& { \qval ~|~ \saexpr ~|~ \qexpr \oplus_a \qexpr} 
\\
%
\mbox{Query Value} & \qval & ::= 
& {n ~|~ \chi[n] ~|~ \chi[n] \oplus_a  \chi[n] ~|~ n \oplus_a  \chi[n]
~|~ \chi[n] \oplus_a  n}
\\
%
\mbox{Value} 
& v & ::= & { n \sep \etrue \sep \efalse ~|~ [] ~|~ [v, \dots, v]}  
\\
%
\mbox{SSA Expression} & \sexpr & ::= & v ~|~ \saexpr \sep \sbexpr ~|~ [\expr, \dots, \expr]
\\	
%
\mbox{Labeled SSA Command} 
& \ssa{c} & ::= &   [\assign {\ssa{x}}{ \ssa{\expr}}]^{l} ~|~  [\assign {\ssa{x} } {\ssa{\query(\qexpr)}}]^{l}
%
~|~  {{\eifvar(\bar{\ssa{x}}, \bar{\ssa{x}}')}} 
%
\\ 
&&& 
{\ewhile ~ [ \sbexpr ]^{l} , n,
~ 
[\bar{\ssa{x}}, \bar{\ssa{x_1}}, \bar{\ssa{x_2}}] 
~ \edo ~  \ssa{c} }
\\
&&&
~|~ \ssa{c};\ssa{c}  
~|~ [\eif(\sbexpr, [\bar{\ssa{x}}, \bar{\ssa{x_1}}, \bar{\ssa{x_2}}] , \ssa{c}, \ssa{c})]^l 
~|~ [\eskip]^{l} 
\\
%
\mbox{SSA Memory} 
& \ssa{m} & ::= & [] ~|~  (\ssa{x} \to v) :: \ssa{m } 
\\
%
\mbox{Annotated Variable / Event} 
& \av & ::= & (\ssa{x}, v, l, n) | (\ssa{x}, \qval, l, n)
\\
%
\mbox{Trace} & \vtrace
& ::= & [] | \av :: \vtrace
\\
%
\mbox{Variable Counter} & \vcounter
& ::= & \mathcal{SVAR} \to \mathbb{N}
\end{array}
\]
We use following notations to represent the set of corresponding definitions:
\[
\begin{array}{lll}
\mathcal{SVAR} & : & \mbox{Set of Variables}  
\\ 
%
\mathcal{VAL} & : & \mbox{Set of Values} 
\\ 
%
%
 \mathcal{AV}  & : & \mbox{Set of Annotated Variables}  
\\
%
\mathcal{SM}  & : & \mbox{{Set of SSA Memories}} 
\\
%
\dbdom  & : & \mbox{{Set of Databases}} 
\\
%
\qdom = {[-1,1]} & : & \mbox{{Domain of Query Results}}
\end{array}
\]
%
%
\paragraph{Consistences to the {\tt While} Language}
Each command is labeled with a label $l$, a natural number standing for the line of code where the command appears. Notice that we associate the label $l$ to the conditional predicate $\bexpr$ in the if statement, and to the guard $\bexpr$ in the while statement. 
\\
  %%% trace, queries
A memory is standard, a map from labeled variables to values. 
%
\\
%
The variable counter $\vcounter$ maps every variable to a natural number $n \in \mathbb{N}$ in a certain execution of program $\ssa{c}$. This natural number $n$ represents the visiting times of this variable in this certain execution.
%
We use variable name $x$ within parenthesis to denote the access to the associated natural number of this variable in the variable counter $\vcounter_{c}$, 
$\vcounter_{c}(x)$ denote the visiting times of variable $x$.
%
\\
The annotated variable / event $\av = (x, l, n, v) $ or $\av = (x, l, n, \qval) $  is a quaternary tuple contains 4 elements. 
$\qval$ is a query value representing the corresponding query request $\assign{x}{\query(\qval)}$ during the execution of the program.
%
\\
A variable trace $\vtrace$ is a list of annotated queries accumulated along the execution of the program. 
A trace can be regarded as the program history, where this history consists of all the queries asked by the analyst during the execution of the program. 
%
\\
A configuration, $\config{\ssa{m, c, \vtrace, \vcounter}}$, contains four elements: a SSA memory $\ssa{m}$, the command $\ssa{c}$ to be evaluated, a trace $t$ and variable $\vcounter$. 
%
\\
 %% trace
We collect the trace with a trace-based small-step operational semantics based on transitions of the program configuration $\config{m, c, \vtrace, \vcounter}$,
of form $ \config{m,c, \vtrace, \vcounter} \to \config{m', \eskip, \vtrace', \vcounter'} $. 
%
\\
%
\paragraph{Differences in SSA form Language}
We use $\ssa{\aexpr}$ to express arithmetic expressions which now contains ssa variable $\ssa{x} \in \mathcal{SVAR}$, 
and the boolean expression as $\ssa{\bexpr}$. 
%
The ssa expression can be either $\ssa{a}$ and $\ssa{b}$. 
We also have the ssa variables annotated in a similar way as the annotated queries in the while language.
%
The labeled commands $\ssa{c}$ are now in the ssa form. 
% assignment
In the assignment command $[\assign {\ssa{x}}{ \ssa{\expr}}]^{l}$ and query request command 
$[\assign {{\ssa{x}} } {\query({\ssa{\qexpr}})}]^{l}$ , 
the expression ${\ssa{\expr}}$ and query expression 
$\ssa{\qexpr}$ is now in their corresponding ssa forms. 

{
% if
The if command now contains the extra part 
$([\bar{\ssa{x}}, \bar{\ssa{x_1}}, \bar{\ssa{x_2}}] , 
[\bar{\ssa{y}}, \bar{\ssa{y_1}}, \bar{\ssa{y_2}}],
[\bar{\ssa{z}}, \bar{\ssa{z_1}}, \bar{\ssa{z_2}}] )$, 
which helps to track the dependency of new assigned variables in both branches($[\bar{\ssa{x}}, \bar{\ssa{x_1}}, \bar{\ssa{x_2}}]$), 
then branch $[\bar{\ssa{y}}, \bar{\ssa{y_1}}, \bar{\ssa{y_2}}]$, 
and else branch $[\bar{\ssa{z}}, \bar{\ssa{z_1}}, \bar{\ssa{z_2}}] $. 
The $\bar{\ssa{x}}$ is a list of ssa variables, in which every element $\ssa{x}$ may depends on the corresponding element $\ssa{x_1}$ from $\bar{\ssa{x_1}}$ collected in the then branch or the corresponding element $\ssa{x_2}$ from $\bar{\ssa{x_2}}$ collected in the else branch. 
%
Every tuple $(\ssa{x,x_1,x_2 })$ from $[\bar{\ssa{x}}, \bar{\ssa{x_1}}, \bar{\ssa{x_2}}]$ can be understood as $\ssa{x} = \phi(\ssa{x_1,x_2})$ in the normal ssa form. 
The previous example $c_2^{s}$ can be used for reference. 
The second part $[\bar{\ssa{y}}, \bar{\ssa{y_1}}, \bar{\ssa{y_2}}]$ focuses on the then branch. 
The list of ssa variables $y_1$ stores the assigned ssa variables before the if command, whose non-ssa version (variables in the while language) will be modified only in the then branch. 
We can look at program $c_1$ as a reference,in which $x$ at line $1$ may be modified only in the then branch at line $3$. 
The list $\bar{\ssa{y_2}}$ tracks the ssa variables assigned only in the then branch. 
If the variables are assigned in both branches such as in the program $c_2$, they goes into $[\bar{\ssa{x}}, \bar{\ssa{x_1}}, \bar{\ssa{x_2}}]$. Then we think every ssa variable in $\bar{\ssa{y}}$ may come from the corresponding variable $\ssa{y_1}$ in $\bar{\ssa{y_1}}$ before the if command or $\ssa{y_2}$ in $\bar{\ssa{y_2}}$ in the then branch. 
In this sense, we can also regard every tuple $(\ssa{y,y_1,y_2 })$ from $[\bar{\ssa{y}}, \bar{\ssa{y_1}}, \bar{\ssa{y_2}}]$ as $\ssa{y} = \phi(\ssa{y_1,y_2})$. 
The rest part $[\bar{\ssa{z}}, \bar{\ssa{z_1}}, \bar{\ssa{z_2}}]$ focus on the else branch and can be understood similarly. 
}

The while command also has similar part $ [\bar{\ssa{x}}, \bar{\ssa{x_1}}, \bar{\ssa{x_2}}]$, focusing on the while body. 
The new command ${{\eifvar(\bar{\ssa{x}}, \bar{\ssa{x}}')}}$ does not have explicit label because it is only used for evaluation internally, we will discuss more about it when in the 
small-step operational semantics for SSA language. 
%
\\
The SSA memory $\ssa{m}$ is a map from SSA variables $\ssa{x}$ to values.
%
\\
The others remain the same in SSA form language as in the {\tt While} language.
%
%
%
\subsection{Trace-based Operational Semantics for SSA Language}
{
%
%
The small-step transition states that a configuration $\config{m,c, \vtrace, \vcounter}$ evaluates to another configuration with the trace and while map updated along with the evaluation of the command $c$ to the normal form of the command $\eskip$.  
We define rules of the trace-based operational semantics in Figure~\ref{fig:evaluation}.
%
%
The rule $\textbf{query-e}$ evaluates the argument of a query request. When the argument is in normal form, this query will be answered.
%
The rule $\textbf{query-v}$ modifies the starting memory $m$ to $m[\qval/x]$ using the answer $\qval$ of the query $\query(\qval)$ from the mechanism, 
with the trace expanded by appending the query $\query(\qval)$ with the current annotation $(l,w)$. 
%
The rule for assignment is standard and the trace remains unchanged.%
The sequence rule keeps tracking the modification of the trace, and the evaluation rule for if conditional goes into one branch based on the result of the conditional predicate $\bexpr$. 
%
The rules for while modify the while map $w$. 
In the rule $\textbf{ifw-true}$, the while map $w$ is updated by $w + l$ because the execution goes into another iteration when the condition $n >0$ is satisfied. 
%
When $n$ reaches $0$, the loop exits and the while map $w$ eliminates the label $l$ of this while statement by $w - l$ in the rule $\textbf{ifw-false}$.  
With the operational semantics and relations between annotated queries, we restrict the well-formed trace w.r.t. the execution of a program $c$ in Definition~\ref{def:wf_trace}.
%
%
%
%
\begin{figure}
\jl{
  \begin{mathpar}
  \boxed{
  Memory  \times Command \times VTrace \times VCounter
  \xrightarrow{}
  Memory  \times Command \times VTrace \times VCounter
  }
  \\
  \boxed{\config{\ssa{m, c, \vtrace, \vcounter}}
  \xrightarrow{} 
  \config{\ssa{m', c',  \vtrace', \vcounter'}}
  }
  \\
  \inferrule
  {
   \config{\ssa{m, \expr}} \xrightarrow{}  \ssa{\expr'}
  }
  {
  \config{\ssa{m, [\assign{x}{\ssa{\expr}}]^{l},  \vtrace, \vcounter}}
  \xrightarrow{} 
  \config{\ssa{m, [\assign{x}{\ssa{\expr}'}]^{l}, \vtrace, \vcounter}}
  }
  ~\textbf{assn-e}
  %
  ~~~~~~~
  %
  \inferrule
  {
  \vcounter'[\ssa{x}] = \vcounter(\ssa{x}) + 1
  \and 
  \av = (\ssa{x}, l, \vcounter'(\ssa{x}), v)
  }
  {
  \config{\ssa{m}, [\assign{\ssa{x}}{v}]^{l},  \vtrace, \vcounter} 
  \xrightarrow{} 
  \config{\ssa{m}[v/\ssa{x}], [\eskip]^{l}, \vtrace ++ [\av], \vcounter'}
  }
  ~\textbf{assn-v}
  %
  \and
  %
  \inferrule
  {
   \empty
  }
  {
  \config{\ssa{m, \ewhile ~ [b]^{l}, n, [\bar{{x}}', \bar{{x_1}}, \bar{{x_2}}] ~ \edo ~ c, \vtrace, \vcounter}}
  \\
  \xrightarrow{} 
  \config{\ssa{ m, 
  \eif_w (b, n, [\bar{x_i}/\bar{x'}],  [\bar{{x}}', \bar{{x_1}}, \bar{{x_2}}], 
  c[\bar{x_i}/\bar{x'}]; \ewhile ~ [b]^{l}, (n + 1), [\bar{{x}}', \bar{{x_1}}, \bar{{x_2}}]  ~ \edo ~ c,  \eskip),
  \vtrace, \vcounter}}
  }
  ~\textbf{ssa-while-b}
  %
  \and
  %
  \inferrule
  {
   \ssa{\config{m, b} \xrightarrow{} b'}
  }
  {
  \config{\ssa{m, \eif_w (b, n, [\bar{{x}}', \bar{{x_1}}, \bar{{x_2}}] , n,  c_1,  c_2)} ,  \vtrace, \vcounter}
  \xrightarrow{} 
  \config{\ssa{m, 
   \eif_w (b', n, [\bar{{x}}',\bar{{x_1}}, \bar{{x_2}}] , n , c_1 , c_2 )}, \vtrace, \vcounter}
  }
  ~\textbf{ssa-ifw-b}
  %
  \and
  %
 \inferrule
  {
   \empty
  }
  {
  \config{
  \ssa{
  m, 
  \eif_w (\etrue, [\bar{{x}}', \bar{{x_1}}, \bar{{x_2}}], n,  
  c; \ssa{\ewhile ~ [b]^{l}, n, [\bar{{x}}', \bar{{x_1}}, \bar{{x_2}}]  ~ \edo ~ c},
  \eskip), \vtrace, \vcounter
  }}
  \\
  \xrightarrow{} 
  \config{
  \ssa{m, 
  {
  \eif_w (\etrue, [\bar{{x}}', \bar{{x_1}}, \bar{{x_2}}], n,  
  c; \ssa{\ewhile ~ [b]^{l}, n, [\bar{{x}}', \bar{{x_1}}, \bar{{x_2}}]  ~ \edo ~ c},
  }
  }
  \vtrace, \vcounter}
  }
  ~\textbf{ssa-ifw-true}
%
  \and
  %
  \inferrule
  {
  { n = 0 \rightarrow i = 1 }
  \and
  {n > 0 \rightarrow i =2}
  }
  {
  \config{\ssa{
  m, \eif_w (
  \efalse, [\bar{{x}}', \bar{{x_1}}, \bar{{x_2}}],  n, 
  c; \ssa{\ewhile ~ [b]^{l}, n, [\bar{{x}}', \bar{{x_1}}, \bar{{x_2}}]  ~ \edo ~ c},
  \eskip)),\vtrace, \vcounter }}
  \\
  \xrightarrow{} 
  \config{\ssa{m, {\eskip}; \eifvar(\bar{x'}, \bar{x_i}) }, \vtrace, \vcounter }
  }
  ~\textbf{ssa-ifw-false}
  %
  \and
  %
  {
  \inferrule
  {
  \config{\ssa{m,\qexpr}} \qarrow \qexpr'
  }
  {
  \config{\ssa{m, [\assign{x}{\query(\qexpr)}]^l, \vtrace, \vcounter}} \xrightarrow{}  
  \config{\ssa{m, [\assign{x}{\query(\qexpr')}]^l, \vtrace, \vcounter}}
  }
  ~\textbf{ssa-query-e}
  }
  \and
  {
  \inferrule
  {
  \query(\qval) = v
  \and
  \vcounter'[\ssa{x}] = \vcounter[\ssa{x}] + 1
  \and 
  \av = (\ssa{x}, \qval, l, \vcounter'[\ssa{x}])
  }
  {
  \config{\ssa{m, [\assign{x}{\query(\qval)}]^l, \vtrace, \vcounter}}
  \xrightarrow{} 
  \config{\ssa{m[v/ x], \eskip,  \vtrace ++ [\av], \vcounter'} }
  }
  ~\textbf{ssa-query-v}
  }
  %
  \and
  %
  %
  \inferrule
  {
  \config{\ssa{m, c_1, \vtrace, \vcounter}}
  \xrightarrow{}
  \config{\ssa{m', c_1',  \vtrace', \vcounter'}}
  }
  {
  \config{\ssa{m, c_1; c_2, \vtrace, \vcounter}} 
  \xrightarrow{} 
  \config{\ssa{m', c_1'; c_2, \vtrace', \vcounter'}}
  }
  ~\textbf{ssa-seq1}
  %
  ~~~~~~~
  %
  \inferrule
  {
  }
  {
  \config{\ssa{m, [\eskip]^{l} ; c_2, \vtrace, \vcounter}} \xrightarrow{} \config{\ssa{m, c_2, \vtrace, \vcounter}}
  }
  ~\textbf{ssa-seq2}
  %
  \and
  %
  \inferrule
  {
  \config{\ssa{m, \sbexpr}} \barrow \sbexpr'
  }
  {
  \config{\ssa{m, 
  \eif([\sbexpr]^l, [\bar{{x}}, \bar{{x_1}}, \bar{{x_2}}],
  [\bar{\ssa{y}}, \bar{\ssa{y_1}}, \bar{\ssa{y_2}}],
  [\bar{\ssa{z}},\bar{\ssa{z_1}}, \bar{\ssa{z_2}}], c_1, c_2), 
  \vtrace, \vcounter}} 
  \\
  \xrightarrow{} 
  \config{\ssa{m,  
  [\eif([\sbexpr']^l,[ \bar{{x}}, \bar{{x_1}}, \bar{{x_2}}],
  [\bar{\ssa{y}}, \bar{\ssa{y_1}}, \bar{\ssa{y_2}}],
  [\bar{\ssa{z}},\bar{\ssa{z_1}}, \bar{\ssa{z_2}}] , c_1, c_2)]^{l}, 
  \vtrace, \vcounter}}
  }
  ~\textbf{ssa-if-b}
  %
  \and
  %
  \inferrule
  {
  }
  {
  \config{\ssa{m, 
  \eif([\etrue]^{l}, [\bar{{x}}, \bar{{x_1}}, \bar{{x_2}}],
  [\bar{\ssa{y}}, \bar{\ssa{y_1}}, \bar{\ssa{y_2}}],
  [\bar{\ssa{z}},\bar{\ssa{z_1}}, \bar{\ssa{z_2}}], c_1, c_2), 
  \vtrace, \vcounter}}
  \\
  \xrightarrow{} 
  \config{\ssa{m, 
  c_1; 
  \eifvar(\bar{\ssa{x}},\bar{\ssa{x_2}}); 
  \eifvar(\bar{\ssa{y}},\bar{\ssa{y_1}});
  \eifvar(\bar{\ssa{z}},\bar{\ssa{z_2}}), 
  \vtrace, \vcounter}}
  }
  ~\textbf{ssa-if-t}
  %
  \and
  %
  \inferrule
  {
  }
  {
  \config{\ssa{m, 
  \eif([\efalse]^{l},[\bar{{x}}, \bar{{x_1}}, \bar{{x_2}}],
  [\bar{\ssa{y}}, \bar{\ssa{y_1}}, \bar{\ssa{y_2}}],
  [\bar{\ssa{z}},\bar{\ssa{z_1}}, \bar{\ssa{z_2}}], c_1, c_2), \vtrace, \vcounter}}
  \\
  \xrightarrow{} 
  \config{\ssa{m, 
  c_2;
  \eifvar(\bar{\ssa{x}},\bar{\ssa{x_2}}); 
  \eifvar(\bar{\ssa{y}},\bar{\ssa{y_1}});
  \eifvar(\bar{\ssa{z}},\bar{\ssa{z_2}}), 
  \vtrace, \vcounter}}
  }
  ~\textbf{ssa-if-f}
  %
  \and
  %
  \inferrule
  {
  }
  {
   \config{\ssa{m}, \eifvar(\ssa{\bar{x}, \bar{x}'}), \ssa{\vtrace, \vcounter}} 
   \to 
   \config{\ssa{(\bar{x} \to m(\bar{x}'))::m, \eskip, \vtrace, \vcounter}}
  }~\textbf{ssa-\eifvar}
  % %
  %
  %
  \end{mathpar}
}
  % \end{subfigure}
      \caption{Trace-based Operational Semantics for SSA Language.}
      \label{fig:os_ssa}
  \end{figure}
  %
%
{
When switching to the SSA language, we show that we are still able to achieve what we can get in Section~\ref{sec:while_language}. 
The operational semantics of the SSA language mimics its counterpart, of the form $\config{\ssa{m}, \ssa{c}, t, w} \to \config{\ssa{m'}, \eskip, t', w'}$. 
The SSA memory $\ssa{m}$ is a map from SSA variable $\ssa{x}$ to values.
It still uses a trace to track the query requests during the execution, starting from an SSA configuration with an SSA memory $\ssa{m}$ and a program in its SSA form $\ssa{c}$, 
which allows a similar construction of the query-based dependency graph in the SSA language as in the {\tt While} language.
We show the evaluation rules in Figure~\ref{fig:os_ssa}.
}
%
The command 
$\mathsf{\eifvar}(\bar{x},\bar{x}')$ stores the variable map during the run time, which is a map from ssa variable $\ssa{x}$ to variable $\ssa{x}_i$. 
This map is designed for $\eif$ command, when the variable may comes from two branches and this command records which branch the variable comes from. 
%
%
{
The key idea underneath the operational semantics is to have the trace and the execution path being constructed in a similar way as in the loop language.
Take the query request as an example, the argument $\ssa{\expr}$ which contains ssa variables will be evaluated to a value $v$ first before the request is sent to the database in rule $\textbf{ssa-query-arg}$. 
The trace expands in the rule $\textbf{ssa-query}$ likewise in the loop language. 
The query $q$, a primitive symbol representing the abstract query in both the ssa language and  the loop language, makes no difference in the two languages. 
Since we add the extra part $[\bar{\ssa{x}}, \bar{\ssa{x_1}}, \bar{\ssa{x_2}}] ,[\bar{\ssa{y}}, \bar{\ssa{y_1}}, \bar{\ssa{y_2}}] ,[\bar{\ssa{z}},\bar{\ssa{z_1}}, \bar{\ssa{z_2}}]  $ 
in the if command compared to its counterpart in the while language, 
the rules relevant to the if condition ($\textbf{ssa-if-t}$ and $\textbf{ssa-if-f}$) use the command $\eifvar(\ssa{\bar{x}, \bar{x}'})$ to update the ssa memory $\ssa{m}$ with the mapping from the new generated variable $\ssa{x}$ in $\bar{\ssa{x}}$ to the appropriate value $\ssa{m(x')}$ where $\ssa{x'}$ is the corresponding variable w.r.t $\ssa{x}$ in $\bar{\ssa{x'}}$.
%
The rule $\textbf{ssa-\eifvar}$ reflects the usage of $\eifvar(\ssa{\bar{x}, \bar{x}'})$.
%
It is easier to understand the usage of $\eifvar(\ssa{\bar{x}, \bar{x}'})$ in the rule $\textbf{ssa-if-t}$ when we think about how ssa works: 
in the ssa form, when a variable to be used may come from two sources (e.g. $\ssa{x_1}$ and $\ssa{x_2}$ in the rule), it generates a new variable $\ssa{x}$, assigning it with $\phi(\ssa{x_1}, \ssa{x_2})$,  and replaces the variable to be used with newly assigned $\ssa{x}$. 
We know that in the future program after the if command, 
only the variables $\bar{\ssa{x}}$ will be available instead of $\bar{\ssa{x_1}}, \bar{\ssa{x_2}}$ from two branches.
For the evaluation of the program after the if command, we need to tell the memory the exact value of the newly generated variable $\ssa{x}$, which is the value stored in $\ssa{x_1}$ when the conditional $\ssa{b}$ is true, 
or the value in $\ssa{x}_2$ when $\sbexpr$ is false. To this end, the internal command $\eifvar(\ssa{\bar{x}, \bar{x}'})$ plays its role. 
For the if rule, w
e need to instantiate the variables from $\bar{\ssa{x}}$ whose values come from two branches, 
$\bar{\ssa{y}}$ whose values from then branch or assignment before the if command, and $\bar{\ssa{z}}$ whose values from else branch or before the if command. 
Correspondingly, we need to have three ifvar commands.   
}
\\
  The evaluation of while depends on the while iteration counter $\ssa{n}$ and the guard $\ssa{\bexpr}$. 
  When $\ssa{\bexpr}$ is evaluated to $\etrue$, the while is still executing, and all the variables $\ssa{x}$ in $\bar{\ssa{x}}$ of the loop body $\ssa{c}$ are replaced as the corresponding variables in $\bar{\ssa{x_1}}$ in the first iteration($n=0$), or $\bar{\ssa{x_2}}$ in other iterations($n > 0$). 
  The while turns to an exit when $\ssa{n} > 0$, 
  and the memory $\ssa{m}$ updates the mapping of variables in $\bar{\ssa{x}}$ with $\bar{\ssa{x_1}}$ if the guard $\bexpr$ evaluates to $\efalse$, 
  which means the while body is not executed once. 
  When the while enters the exit after executing the body a few times($n$), the variables in $\bar{\ssa{x}}$ is instantiated with the value from the body $\ssa{m}(\bar{\ssa{x_2}})$. 
%
%
\subsection{Event and Trace}
%
%
\todo{
%
Events preserve the order of execution. The order relation is defined in Definition~\ref{def:query_dir}.
%
\begin{defn}[Order of Annotated Variables / Events].
\label{def:query_dir}
\\
Given 2 annotated queries 
$\av_1 = (x_1, v_1, l_1, n_1), 
\av_2 = (x_2, v_2, l_2, n_2)$
:
%
\[
\av_1 \avlt \av_2
 \triangleq 
 \left\{
 \begin{array}{ll}
    n_1 < n_2  
    & l_1 = l_2
    \\
    w_1 <_w w_2 & o.w.
\end{array}  
\right.
\]
%
$\av_1 \avgeq \av_2$  is defined vice versa.
\end{defn}
}
%
%
%
Given the evaluation rules for query expression, we define its equivalence relation in Definition~\ref{def:query_equal}.
%
\begin{defn}[Equivalence of Query].
%
\label{def:query_equal}
 Given a memory $m$ and 2 query expressions $\qexpr_1$, $\qexpr_2$ s.t., $FV(\qexpr_1) \in \dom(m)$ and $FV(\qexpr_2) \in \dom(m)$:
$$
\qexpr_1 =_{q}^{m} \qexpr_2 \triangleq
\left\{
    \begin{array}{ll} 
      \etrue      
      & 
    \exists \qval_1, \qval_2.
    \begin{array}{l} 
      (\config{m,  \qexpr_1} \qarrow \qval_1 \land \config{m,  \qexpr_2 } \qarrow \qval_2) 
      \\
      \land (\forall r \in \qdom. \exists v. ~ s.t., ~ 
            \config{m, \qval_1[r/\chi]} \aarrow v \land \config{m,  \qval_2[r/\chi] } \aarrow v)  
    \end{array}\\
      \efalse         
      & \text{o.w.} 
    \end{array}
    \right.
$$
%
, where $FV(\qexpr)$ is the set of free variables in the query expression $\qexpr$.
$\qexpr_1 \neq_{q}^{m} \qexpr_2$  is defined vice versa.
%
We use $=_{q}$  and $\neq_{q}$ as the shorthands for $=_{q}^{[]}$ and $\neq^{[]}_{q}$.
\end{defn}
%
Then, we have the corresponding equivalence relation between 2 annotated queries defined in Definition~\ref{def:av_equal}:
%
\todo{
\begin{defn}[Equivalence of Annotated Variables / Events]
%
\label{def:av_equal}
Given 2 annotated queries 
$ \av_1 = (x_1, v_1, l_1, n_1), 
\av_2 = (x_2, v_2, l_2, n_2)$
:
%
\[
\av_1 \aveq \av_2
 \triangleq (l_1 = l_2 \land  w_1 =_w w_2 \land 
 \qval_1 =_q \qval_2) 
\]
%
$\av_1 \avneq \av_2$  is defined vice versa.
%
\end{defn}
}
%
%
%
\todo{
Given an annotated variable $\av$ and a trace $t$,
the appending operation $\av :: t$ is 
the standard list appending operation, appends $\av$ to the head of trace $t$.
%
The concatenation operation between 2 traces $t_1$ and $t_2$, i.e., $t_1 ++ t_2$ is the standard list concatenation operation as follows:
\begin{equation}
    t_1 ++ t_2  
    \triangleq \left\{
    \begin{array}{ll} 
      t_2         & t_1 = []\\
      \av::(t_1' ++ t_2)  & t_1 = \av::t_1'
    \end{array}
    \right.
  \end{equation}
%
%
The subtraction operation between 2 traces $t_1$ and $t_2$, i.e., $t_1 - t_2$ is defined as follows:
\begin{equation}
    t_1 - t_2  
    \triangleq t_3 ~ s.t., t_2 ++ t_3 = t_1
  \end{equation}
%
Given an annotated query $\av$, $\av$ belongs to a trace $t$, i.e., $\av \avin t$ are defined as follows:
    %
\begin{equation}
    \av \avin t  
    \triangleq \left\{
    \begin{array}{ll} 
      \efalse       & t = []      \\
      \etrue        & t = \av'::t'  \quad \av \aveq \av'\\ 
      \av \in t'      & t = \av'::t'  \quad \av \avneq \av'
    \end{array}
    \right.
  \end{equation}
  %
  %
}
%
\todo{
\begin{defn}[Equivalence of Program]
%
\label{def:aq_prog}
Given 2 programs $c_1$ and $c_2$:
\[
c_1 =_{c} c_2
 \triangleq 
 \left\{
    \begin{array}{ll} 
      \etrue        
      & c_1 = \eskip \land c_2 = \eskip
      \\ 
      \forall m. \exists v. ~ \config{m, \expr_1} \aarrow^{*} v \land \config{m, \expr_1} \aarrow^{*} v     
      & c_1 = \assign{x}{\expr_1} \land c_2 = \assign{x}{\expr_2} 
      \\ 
      \qexpr_1 =_{q} \qexpr_2       
      & c_1 = \assign{x}{\query(\qexpr_1)} \land c_1 = \assign{x}{\query(\qexpr_2)} 
      \\
      c_1^f =_{c} c_2^f \land c_1^t =_{c} c_2^t
      & c_1 = \eif(b, c_1^t, c_1^f) \land c_2 = \eif(b, c_2^t, c_2^f)
      \\ 
      c_1' =_{c} c_2'         
      & c_1 = \ewhile b \edo c_1' \land c_2 = \ewhile b \edo c_2'
      \\ 
      c_1^h =_{c} c_2^h \land c_1^t =_{c} c_2^t
      & c_1 = c_1^h;c_1^t \land c_2 = c_2^h;c_2^t 
    \end{array}
    \right.
\]
%
$c_1 \neq_{c} c_2$  is defined vice versa.
%
\end{defn}
%
Given 2 programs $c$ and $c'$, $c'$ is a sub-program of$c$, i.e., $c' \in_{c} c$ is defined as:
\begin{equation}
c' \in_{c} c \triangleq \exists c_1, c_2, c''. ~ s.t.,~
c =_{c} c_1; c''; c_2 \land c' =_{c} c''
\end{equation} 
}
%
\todo{
\begin{defn}[Assigned Variables ($\avar$)]
Given a program $\ssa{c}$, its assigned variables $\avar$ is a vector containing all variables newly assigned in the program preserving the order. 
It is defined as follows:
$$
  \avar_{\ssa{c}} \triangleq
  \left\{
  \begin{array}{ll}
      [\ssa{x}]                   
      & \ssa{c} = [\ssa{\assign x e}]^{(l, w)} 
      \\
      \left[ \ssa{x} \right]                  
      & \ssa{c} = [\ssa{\assign x \query(\qexpr)}]^{(l, w)} 
      \\
      \avar_{\ssa{c_1}} ++ \avar_{\ssa{c_2}}  
      & \ssa{c} = \ssa{c_1};\ssa{c_2}
      \\
      \avar_{\ssa{c_1}} ++ \avar_{\ssa{c_2}} ++ \ssa{[\bar{x}, \bar{y}, \bar{z}]} 
      & \ssa{c} =\eif([\sbexpr]^{(l, w)} , \ssa{[\bar{x}, \bar{x_2}, \bar{x_2}], 
      [\bar{y}, \bar{y_2}, \bar{y_3}], 
      [\bar{z}, \bar{z_2}, \bar{z_3}], c_1, c_2}) 
      \\
      \avar_{\ssa{c}'} ++ [\ssa{\bar{x}}]
      & \ssa{c}   = \ewhile ([\sbexpr]^{(l, w)}, [\ssa{\bar{x}, \bar{x_2}, \bar{x_2}}], \ssa{c}')
\end{array}
\right.
$$
\end{defn}
%
\begin{defn}[Query Variables ($\qvar$)].
\\
Given a program $c$, its query variables $\qvar$ is a vector containing all variables newly assigned by a query in the programm, $\qvar \subset \mathcal{VAR}$.
It is defined as follows:
$$
  \qvar_{\ssa{c}} \triangleq
  \left\{
  \begin{array}{ll}
      []                  
      & \ssa{c} = [\ssa{\assign x e}]^{(l, w)} 
      \\
      \left[ \ssa{x} \right]                  
      & \ssa{c} = [\ssa{\assign x \query(\qexpr)}]^{(l, w)} 
      \\
      \avar_{\ssa{c_1}} ++ \avar_{\ssa{c_2}}  
      & \ssa{c} = \ssa{c_1};\ssa{c_2}
      \\
      \avar_{\ssa{c_1}} ++ \avar_{\ssa{c_2}} ++ \ssa{[\bar{x}, \bar{y}, \bar{z}]} 
      & \ssa{c} =\eif([\sbexpr]^{(l, w)} , \ssa{[\bar{x}, \bar{x_2}, \bar{x_2}], 
      [\bar{y}, \bar{y_2}, \bar{y_3}], 
      [\bar{z}, \bar{z_2}, \bar{z_3}], c_1, c_2}) 
      \\
      \avar_{\ssa{c}'} ++ [\ssa{\bar{x}}]
      & \ssa{c}   = \ewhile ([\sbexpr]^{(l, w)}, [\ssa{\bar{x}, \bar{x_2}, \bar{x_2}}], \ssa{c}')
\end{array}
\right.
$$
\end{defn}
%
We are abusing the notations and operators from list here. 
The notation $[]$ represents an empty vector
and $x::A$ represents add an element $x$ to the head of the vector $A$.
The concatenation operation between 2 vectors $A_1$ and $A_2$, i.e., $A_1 ++ A_2$ is mimic the standard list concatenation operations as follows:
%
\begin{equation}
    A_1 ++ A_2  
    \triangleq \left\{
    \begin{array}{ll} 
      A_2         & A_1 = []\\
      x::(A_1' ++ A_2)  & A_1 = x::A_1'
    \end{array}
    \right.
\end{equation}
%
We use index within parenthesis to denote the access to the element of corresponding location,
$A(i)$ denotes the element at location $i$ in the vector $A$ and 
$M(i, j)$ denotes the element at location $i$-th raw, $i$-th column in the matrix $M$. 
%
%
%
\begin{defn}[Initial Variable Counter $\vcounter^0_{c}$]
Given a program $c$ with its assigned variables $\avar_{c}$ of length $N$, its initial variable counter $\vcounter^0_{c}$ maps all the variable to $0$, i.e.:
\[
  \vcounter^0_{c}(x) = 0, x = \avar_{c}(i) \forall i = 1, \ldots, N 
\]
\end{defn}
%
We define some properties and prove lemmas for trace and event w.r.t. the operational semantics as follows.
%
\todo{
\begin{defn}[Well-formed Trace]
\label{def:wf_trace}
A trace $t$ is well formed if and only if it preserves the following two properties:
\begin{itemize}
  \item{\emph{(Uniqueness)}} $\forall \av_1, \av_2 \avin t. ~ (\av_1 \avneq \av_2)$
  %
  \item{\emph{(Ordering)}} $\forall \av_1, \av_2 \avin t. ~ 
  (\av_1 \avlt \av_2) \Longleftrightarrow
  \exists t_1, t_2, t_3, \av_1', \av_2'. ~ s.t.,~ 
  (\av_1 \aveq \av_1') \land (\av_2 \aveq \av_2') \land t_1 ++ [\av_1'] ++ t_2 ++ [\av_2'] ++ t_3 = t$
\end{itemize}
\end{defn}
}
\\
\todo{
\begin{thm}[Variable Trace Generated from Operational Semantics is Well-formed].
\label{thm:os_wf_trace}
\\
Given a program $c$, 
with arbitrary starting memory $m$, trace $\vtrace$ and variable counter $\vcounter$
if $\config{m, c, \vtrace, \vcounter} \to^{*} 
\config{m', \eskip, \vtrace', \vcounter'}$, then $(\vtrace' - \vtrace)$ is a well formed trace with respect to program $c$, $m$ and $w$, denoted as $m, c \vDash \vtrace' - \vtrace$.
% \wq{ we call a trace $t$ satisfies the program $c$ in the memory $m$, denoted as $m, c \vDash t$, if
% there exists the evaluation 
% $\config{m, c, [], []} \to^{*} \config{m', \eskip, t, w}$, and
% $t$ is well-formed. }
\end{thm}
\begin{proof}
Proof in File: {\tt ``thm\_os\_wf\_trace.tex''}.
% \input{thm_os_wf_trace}
\end{proof}
}
%
% \\
%
%
\todo{
\begin{lem}[While Map Remains Unchanged (Invariant)]
\label{lem:wunchange}
Given a program $c$ with a starting memory $m$, trace $t$ and while map $w$, s.t.,
$\config{m, c, t, w} \to^{*} \config{m', \eskip, t', w'}$ and $Labels(c) \cap Keys(w) = \emptyset$, then 
\[
  w = w'
\]
\end{lem}
\begin{subproof}[Proof of Lemma~\ref{lem:wunchange}]
%
Proof in File: {\tt ``lem\_wunchange.tex''}
% \input{lem_wunchange}
%
\end{subproof}
}
%
\todo{
\begin{lem}[Trace is Written Only]
\label{lem:twriteonly}
Given a program $c$ with starting trace $t_1$ and $t_2$,
for arbitrary starting memory $m$ and while map $w$,
if there exist evaluations
$$\config{m, c, t_1, w} \to^{*} \config{m_1', \eskip, t_1', w_1'}$$
% 
$$\config{m, c, t_2, w} \to^{*} \config{m_2', \eskip, t_2', w_2'}$$
%
then:
%
\[
  m_1' = m_2' \land w_1' = w_2'
\]
\end{lem}
%
\begin{subproof}[Proof of Lemma~\ref{lem:twriteonly}]
%
Proof in File: {\tt ``lem\_twriteonly.tex''}
% \input{lem_twriteonly}
\end{subproof}
}
%
\todo{
\begin{lem}[Trace Uniqueness]
\label{lem:tunique}
Given a program $c$ with a starting memory $m$, \wq{a while map w,}
for any starting trace $t_1$ and $t_2$, if there exist evaluations
$$\config{m, c, t_1, w} \to^{*} \config{m_1', \eskip, t_1', w_1'}$$
% 
$$\config{m, c, t_2, w} \to^{*} \config{m_2', \eskip, t_2', w_2'}$$
%
then:
%
\[
  t_1' - t_1 = t_2' - t_2
\]
\end{lem}
%
\begin{subproof}[Proof of Lemma~\ref{lem:tunique}]
%
Proof in File: {\tt ``lem\_tunique.tex''}
% \input{lem_tunique}
\end{subproof}
}
%
\todo{
\begin{coro}
\label{coro:aqintrace}
\[
\av \avin t \implies \exists t_1, t_2, \av'. ~ s.t., ~ (\av \aveq \av') \land t_1 ++ [\av'] ++ t_2 = t  
\]
\end{coro}
\begin{subproof}
Proof in File: {\tt ``coro\_aqintrace.tex''}
% \input{coro_aqintrace}
%
\end{subproof}
}
%
\begin{lem}
[Trace Non-Decreasing].
\\
\jl{
For any program $c$ with a starting memory $m$, trace $t$ and while map $w$: 
$$
\config{m, c, t, w} 
\rightarrow
\config{m, c', t', w'} \implies \exists ~ t'', ~ s.t., ~ t ++ t'' = t'
$$
}
\end{lem}
%
\begin{proof}
{
Proof is obvious by induction on the operational semantic rules applied in the transition 
.
\\
By induction on the operational semantic rules applied in the transition $\config{m, c, t, w} 
\rightarrow
\config{m, c', t', w'}$, 
we have cases for each rule.
By observation on the rules, 
the trace $t$ remains unchanged in all the rules except the only one \textbf{query-v}.
So, the rule \textbf{query-v} is the only interesting case to be discussed as following.
\begin{itemize}
\caseL{
\[
  \inferrule
  {
  \query(\qval) = v
  }
  {
  \config{m, [\assign{x}{\query(\qval)}]^l, t, w} \xrightarrow{}  
  \config{m, \eskip, t ++ [(\qval, l, w)], w}
  }
  ~\textbf{query-v}
\]
}
%
In this case, we have $c' = \eskip$, 
$t' = t ++ [(\qval, l, w)]$, $m' = m[v/x]$ and $w' = w$.
\\
Let $t'' = [(\qval, l, w)]$, we have $t ++ [(\qval, l, w)] = t'$,
i.e., $t ++ t'' = t'$. This case is proved.
\end{itemize}
}
\end{proof}
%
}
%
\subsection{ Trace-based Adaptivity}
%
We define adaptivity through a query-based dependency graph. In our model, an \emph{analyst} asks a sequence of queries to the mechanism, and the analyst receives the answers to these queries from the mechanism. A query is adaptively chosen by the analyst when the choice of this query is affected by answers from previous queries. In this model, the adaptivity we are interested in is the length of the longest sequence of such adaptively chosen queries, among all the queries the data analyst asks to the mechanism.  Also, when the analyst asks a query, the only information the analyst will have will be the answers to previous queries and the state of the program. It means that when we want to know if this query is adaptively chosen, we only need to check whether the choice of this query will be affected by changes of answers to previous queries. There are two possible situations that can  affect the choice of a query,  
either the query argument directly uses the results of previous queries (data dependency), or the control flow of the program with respect to a query (whether to ask this query or not) depends on the results of previous queries (control flow dependency).

{
As a first step, we give a definition of when one query may depend on a previous query, which is supposed to consider both control dependency and data dependency. We first look at two possible candidates:
\begin{enumerate}
    \item One query may depend on a previous query if and only if a change of the answer to the previous query may also change the result of the query.
    \item One query may depend on a previous query if and only if a change of the answer to the previous query may also change the appearance of the query.
\end{enumerate}
}

{
   The first candidate works well by witnessing the result of one query according to the change of the answer of another query. We can easily find that the two queries have nothing to do with each other in a simple example   
%
    $ c = \assign{x}{\query(\chi(1))} ; \assign{y}{\query(\chi(2))}$. This candidate definition works well with respect to data dependency. 
    However, if fails to handle control dependency since it just monitors the changes to the answer of a query when the answer of previous queries returned change. 
    The key point is that this query may also not be asked because of an analyst decision which depend on the answers of previous queries. 
    An example of this situation is shown in program $c_1$ as follows.
    \[
      c_1 = \assign{x}{\query(\chi(1))} ; \eif( x > 2 ,\assign{y}{\query(\chi(2))}, \eskip )
    \]
  %   
    We choose the second candidate, which performs well by witnessing the appearance of one query $\query(\chi(2))$ upon the change of the result of one previous query $\query(\chi(1))$ in $c_1$. 
    It considers the control dependency, and at the same, does not miss the data dependency.
    In particular, the arguments of a query characterizes it.
    In this sense, if the data used in the arguments changes due to a different answer to a certain previous query, the appearance of the query may change as well.
    This situation is also captured by our definition. 
    Let us look at another variant of program $c$, $p_2$, in which the queries equipped with functions using previously assigned variables storing answer of its previous query.
    \[
      c_2 = \assign{x}{\query(\chi(2))} ; \assign{y}{\query(x+\chi(3))}
    \]
    As a reminder, in the {\tt While} language, the query request is composed by two components: a symbol $\query$ representing a linear query type and the argument $\expr$, which represents the function specifying what the query asks. 
    So we do think $\query(\chi(1))$ is different from $\query(\chi(2))$.
    Informally, we think $\query(x+\chi(3))$ may depend on the query $\query(\chi(2))$, because equipped function of the former $x+\chi(3)$ depend on the data assigned with $\query(\chi(2))$.
    We can see the appearance definition catches data dependency in such a way, 
    since $\query(x+\chi(2))$ will not be the same query if the value of $x$ is changed.    
}

   We give a formal definition of variable may dependency based on the trace-based operational semantics as follows.
%
% 
%
%
\jl{
\begin{defn}
[Annotated Variables / Events May Dependency]
\label{def:avar_dep}.
\\
One event $\av_2 = (x_2, v_2, l_2, n_2)$ may depend on another one 
$\av_1 = (x_1, v_1, l_1, n_1)$ in a program $c$,
with a starting memory $m$ and  hidden database $D$, denoted as 
%
$\avdep(\av_1, \av_2, c, m, D)$ is defined below. 
%
%
\[
\begin{array}{l}
\exists \ssa{m}_1, \ssa{m}_3, \vtrace_1, \vtrace_3, \ssa{c}_2, v_1, ({\qval}_1 \lor \sexpr_1).\\
  \left (\begin{array}{l}   
\config{\ssa{m}, \ssa{c}, [], []} \rightarrow^{*} 
\config{\ssa{m}_1, [\assign{\ssa{x}_1}{\query({\qval}_1) (/ v_1)}]^{l_1} ; \ssa{c}_1, \qtrace_1,  \vtrace_1, w_1} 
\rightarrow^{\textbf{ssa-query-v (/ assn-v)}} 
\\ 
\config{\ssa{m}_1[v_1/\ssa{x}], c_2, \qtrace_1', \vtrace_1 ++ [\av_1], w_1} 
\rightarrow^{*} \config{\ssa{m}_3, \eskip, \qtrace_3, \vtrace_3, w_3}
  % 
 \\ \bigwedge
  \left( 
  \begin{array}{l}
  \av_2 \in (\vtrace_3'-(\vtrace_1 ++ [\av_1])) 
  % 
  \\
  \implies 
  \exists v \in \qdom, v \neq v_1, \ssa{m}_3', \qtrace_3', \vtrace_3', w_3'.  
  \config{\ssa{m}_1[v/\ssa{x}], {\ssa{c}_2}, \qtrace_1', \vtrace_1 ++ [\av_1], w_1} 
  \\ 
  \quad \quad 
  \rightarrow^{*}
  (\config{\ssa{m}_3', \eskip, \qtrace_3', \vtrace_3', w_3'} 
    \\ 
    \quad \quad 
  \land 
  \av_2 \not\in (\vtrace_3'-(\vtrace_1 ++ [\av_1])))
\end{array} \right )
\\\bigwedge
\left( 
  \begin{array}{l}
    \av_2 \notin (\vtrace_3 - (\vtrace_1 ++ [\av_1]))
    % 
    \\
    \implies 
  \exists v \in \qdom, v \neq v_1, \ssa{m}_3', \qtrace_3', \vtrace_3', w_3'. 
  \config{\ssa{m}_1[v /\ssa{x}], {\ssa{c}_2}, \qtrace_1', \vtrace_1 ++ [\av_1], w_1}
  \\ 
  \quad \quad 
  \rightarrow^{*} 
  (\config{\ssa{m}_3', \eskip, \qtrace_3', \vtrace_3', w_3'} 
    \\ 
    \quad \quad 
  \land 
  \av_2  \in (\vtrace_3' - (\vtrace_1 ++ [\av_1])))
\end{array} \right )
\end{array} \right )
\end{array}
\]
%
\end{defn}
%
\begin{defn}
[Annotated Variables May Dependency -- Version 2]
\label{def:avar_dep2}.
\\
One event $\av_2$ may depend on another one  $\av_1$in a program $\ssa{c}$,
with a starting memory $\ssa{m}$ and hidden database $D$, denoted as 
%
$\avdep(\av_1, \av_2, c, \ssa{m}, D)$ is defined below. 
%
\[
\begin{array}{ll}
\begin{array}{l}
\exists \ssa{m}, \ssa{m}_1, \ssa{m}_2, \ssa{m}_3, \ssa{m}_2', \ssa{m}_3', 
\vtrace_1, \vtrace_2, \vtrace_2', t_1, t_2, t_2', \ssa{c}_1, \ssa{c}_2, v_1', \sexpr_2.
\\
  \left(
  \begin{array}{l}   
\config{\ssa{m}, \ssa{c}, []} \rightarrow^{*} 
\config{\ssa{m}_1, [\assign{\ssa{x}_1}{v_1}]^{l_1} ; \ssa{c}_1, \vtrace_1, t_1} 
\\ 
 \bigwedge
 \config{\ssa{m}_1[v_1/\ssa{x}_1], c_1, \vtrace_1 ++ [\av_1], t_1[\ssa{x}_1]++} 
 \\
  \qquad \rightarrow^{*} 
  \config{\ssa{m}_2, [\assign{\ssa{x}_2}{\sexpr_2}]^{l_2} ; \ssa{c}_2, \vtrace_2, t_2} 
  \\
  \qquad \rightarrow^{*} 
  \config{\ssa{m}_3, \ssa{c}_2,  \vtrace_2 ++ [\av_2], t_2[\ssa{x}_2]++} 
  % 
 \\ 
 \bigwedge
 \config{\ssa{m}_1[v_1'/\ssa{x}_1], \ssa{c}_1, \vtrace_1, t_1} 
\rightarrow^{*} 
\config{\ssa{m}_2', \ssa{c}_2,  \vtrace_2', t_2'}
\\
\bigwedge
\av_2 \notin \vtrace_2'
\end{array}
\right)
\end{array} 
&
\begin{array}{l}
\av_1 = (\ssa{x}_1, v_1, l_1, n_1)
\\
\av_2 = (\ssa{x}_2, v_2, l_2, n_2)
\end{array}
\\
\begin{array}{l}
\exists \ssa{m}, \ssa{m}_1, \ssa{m}_2, \ssa{m}_3, \ssa{m}_2', \ssa{m}_3', 
\vtrace_1, \vtrace_2, \vtrace_2', t_1, t_2, t_2', \ssa{c}_1, \ssa{c}_2, v_1', {\qexpr}_2.
\\
  \left(
  \begin{array}{l}   
\config{\ssa{m}, \ssa{c}, []} \rightarrow^{*} 
\config{\ssa{m}_1, [\assign{\ssa{x}_1}{\query({\qval}_1)}]^{l_1} ; \ssa{c}_1, \vtrace_1, t_1} 
\\ 
 \bigwedge
 \config{\ssa{m}_1[v_1/\ssa{x}_1], c_1, \vtrace_1 ++ [\av_1], t_1[\ssa{x}_1]++} 
 \\
\qquad \rightarrow^{*} 
\config{\ssa{m}_2, [\assign{\ssa{x}_2}{\query({\qexpr}_2)}]^{l_2} ; \ssa{c}_2, \vtrace_2, t_2} 
\\
\qquad \rightarrow^{*} 
\config{\ssa{m}_3, \ssa{c}_2,  \vtrace_2 ++ [\av_2], t_2[\ssa{x}_2]++} 
  % 
 \\ 
 \bigwedge
 \config{\ssa{m}_1[v_1'/\ssa{x}_1], \ssa{c}_1, \vtrace_1, t_1} 
\rightarrow^{*} 
\config{\ssa{m}_2', \ssa{c}_2,  \vtrace_2', t_2'}
\\
\bigwedge
\av_2 \notin \vtrace_2'
\end{array}
\right)
\end{array} 
&
\begin{array}{l}
\av_1 = (\ssa{x}_1, \qval_1, l_1, n_1)
\\
\av_2 = (\ssa{x}_2, \qval_2, l_2, n_2)
\end{array}
\\
\begin{array}{l}
\exists \ssa{m}, \ssa{m}_1, \ssa{m}_2, \ssa{m}_3, \ssa{m}_2', \ssa{m}_3', 
\vtrace_1, \vtrace_2, \vtrace_2', t_1, t_2, t_2', \ssa{c}_1, \ssa{c}_2, v_1', {\qexpr}_2.
\\
  \left(
  \begin{array}{l}   
\config{\ssa{m}, \ssa{c}, []} \rightarrow^{*} 
\config{\ssa{m}_1, [\assign{\ssa{x}_1}{v_1}]^{l_1} ; \ssa{c}_1, \vtrace_1, t_1} 
\\ 
 \bigwedge
 \config{\ssa{m}_1[v_1/\ssa{x}_1], c_1, \vtrace_1 ++ [\av_1], t_1[\ssa{x}_1]++} 
 \\
\qquad \rightarrow^{*} 
\config{\ssa{m}_2, [\assign{\ssa{x}_2}{\query({\qexpr}_2)}]^{l_2} ; \ssa{c}_2, \vtrace_2, t_2} 
\\
\qquad \rightarrow^{*} 
\config{\ssa{m}_3, \ssa{c}_2,  \vtrace_2 ++ [\av_2], t_2[\ssa{x}_2]++} 
  % 
 \\ 
 \bigwedge
 \config{\ssa{m}_1[v_1'/\ssa{x}_1], \ssa{c}_1, \vtrace_1, t_1} 
\rightarrow^{*} 
\config{\ssa{m}_2', \ssa{c}_2,  \vtrace_2', t_2'}
\\
\bigwedge
\av_2 \notin \vtrace_2'
\end{array}
\right)
\end{array} 
&
\begin{array}{l}
\av_1 = (\ssa{x}_1, v_1, l_1, n_1)
\\
\av_2 = (\ssa{x}_2, \qval_2, l_2, n_2)
\end{array}
\\
\begin{array}{l}
\exists \ssa{m}, \ssa{m}_1, \ssa{m}_2, \ssa{m}_3, \ssa{m}_2', \ssa{m}_3', 
\vtrace_1, \vtrace_2, \vtrace_2', t_1, t_2, t_2', \ssa{c}_1, \ssa{c}_2, v_1', \sexpr_2.
\\
  \left(
  \begin{array}{l}   
\config{\ssa{m}, \ssa{c}, []} \rightarrow^{*} 
\config{\ssa{m}_1, [\assign{\ssa{x}_1}{v_1}]^{l_1} ; \ssa{c}_1, \vtrace_1, t_1} 
\\ 
 \bigwedge
 \config{\ssa{m}_1[v_1/\ssa{x}_1], c_1, \vtrace_1 ++ [\av_1], t_1[\ssa{x}_1]++} 
 \\
\qquad \rightarrow^{*} 
\config{\ssa{m}_2, [\assign{\ssa{x}_2}{\sexpr_2}]^{l_2} ; \ssa{c}_2, \vtrace_2, t_2} 
\\
\qquad \rightarrow^{*} 
\config{\ssa{m}_3, \ssa{c}_2,  \vtrace_2 ++ [\av_2], t_2[\ssa{x}_2]++} 
  % 
 \\ 
 \bigwedge
 \config{\ssa{m}_1[v_1'/\ssa{x}_1], \ssa{c}_1, \vtrace_1, t_1} 
\rightarrow^{*} 
\config{\ssa{m}_2', \ssa{c}_2,  \vtrace_2', t_2'}
\\
\bigwedge
\av_2 \notin \vtrace_2'
\end{array}
\right)
\end{array} 
&
\begin{array}{l}
\av_1 = (\ssa{x}_1, \qval_1, l_1, n_1)
\\
\av_2 = (\ssa{x}_2, v_2, l_2, n_2)
\end{array}
\end{array}
 \]
%
\end{defn}
%
\begin{defn}[Variable May Dependency].
\label{def:var_dep}
\\
Given a program $\ssa{c}$ with its assigned variables $\avar_{\ssa{c}}$, 
one variable $\ssa{x}_2 \in \avar_{\ssa{c}}$ may depend on another variable 
$\ssa{x}_1 \in \avar_{\ssa{c}}$ in $\ssa{c}$ denoted as 
%
$\vardep(\ssa{x}_1, \ssa{x}_2, \ssa{c})$ is defined below.
%
\[
\exists \av_1, \av_2, \ssa{m}, D. ~
\projl{\av_1} = \ssa{x}_1
\land
\projl{\av_2} = \ssa{x}_2
\land 
\avdep(\av_1, \av_2, c, \ssa{m}, D)
\] 
%
%
\end{defn}
%
%
\begin{defn}[Execution Based Dependency Graph].
\\
Given a program $\ssa{c}$, a database $D$, a starting memory $\ssa{m}$ with its assigned variables $\avar_c$ and initial variable counter $\vcounter^0_{c}$ with its corresponding execution:
$\config{\ssa{m}, \ssa{c}, [], \vcounter^0_{\ssa{c}}} 
\to^{*}
\config{\ssa{m'}, \eskip, \vtrace, \vcounter}$,
the dependency graph $\traceG(\ssa{c}, \ssa{m}, D) = (\vertxs, \edges, \weights, \qflag)$ is defined as:
%
\[
\begin{array}{rlcl}
  \text{Vertices} &
  \vertxs & := & \left\{ 
  x \in \mathcal{VAR}
  ~ \middle\vert ~
  x = \avar_{\ssa{c}}(i); i = 0, \ldots, |\avar_{\ssa{c}}| 
  \right\}
  \\
  \text{Directed Edges} &
  \edges & := & 
  \left\{ 
  (x, x') \in \mathcal{VAR} \times \mathcal{VAR}
  ~ \middle\vert ~
  \vardep(x, x', c); 
  x = \avar_{\ssa{c}}(i); x' = \avar_{\ssa{c}}(j); i,j = 0, \ldots, |\avar_{\ssa{c}}| 
  \right\}
  \\
  \text{Weights} &
  \weights & := & 
  \left\{ 
  (x, n) \in \mathcal{VAR} \times \mathbb{N}
  ~ \middle\vert ~
  n = \vcounter(x); x = \avar_{\ssa{c}}(i); i = 0, \ldots, |\avar_{\ssa{c}}|
  \right\}
  \\
  \text{Query Flags} &
  \qflag & := & 
  \left\{(x, n)  \in \vertxs \times \{0, 1\} 
  ~ \middle\vert ~
  \left\{
  \begin{array}{ll}
  n = 1 & x \in \qvar_{\ssa{c}} \\ 
  n = 0 & o.w.
  \end{array}
  \right\};
  x = \avar_{\ssa{c}}(i); i = 0, \ldots, |\avar_{\ssa{c}}|
  \right\}
\end{array}
\]
\end{defn}
%
%
\begin{defn}[Finite Walk ($k$)].
\label{def:finitewalk}
\\
Given a labeled weighted graph $G = (\vertxs, \edges, \weights, \qflag)$, a \emph{finite walk} $k$ in $G$ is a sequence of edges $(e_1 \ldots e_{n - 1})$ 
for which there is a sequence of vertices $(v_1, \ldots, v_{n})$ such that:
\begin{itemize}
    \item $e_i = (v_{i},v_{i + 1})$ for every $1 \leq i < n$.
    \item every vertex $v \in \vertxs$ appears in this vertices sequence $(v_1, \ldots, v_{n})$ of $k$ at most $W(v)$ times.  
\end{itemize}
$(v_1, \ldots, v_{n})$ is the vertex sequence of this walk.
\\
%
Length of this finite walk $k$ is the number of vertices in its vertex sequence, i.e., $\len(k) = n$.
\end{defn}
%
Given a labeled weighted graph $G = (\vertxs, \edges, \weights, \qflag)$, 
we use $\walks(G)$ to denote a set containing all finite walks $k$ in $G$;
and $k_{v_1 \to v_2} \in \walks(G)$where $v_1, v_2 \in \vertxs$ denotes the walk from vertex $v_1$ to $v_2$ .
%
%
\begin{defn}[Length of Finite Walk w.r.t. Query ($\qlen$)].
\label{def:qlen}
\\
Given a labeled weighted graph $G = (\vertxs, \edges, \weights, \qflag)$ and a \emph{finite walk} $k$ in $G$ with its vertex sequence $(v_1, \ldots, v_{n})$, the length of $k$ w.r.t query is defined as:
\[
  \qlen(k) = \len\big(
  v \mid v \in (v_1, \ldots, v_{n}) \land \flag(v) = 1 \big)
\]
, where $\big(v \mid v \in (v_1, \ldots, v_{n}) \land \flag(v) = 1 \big)$ is a subsequence of $k$'s vertex sequence.
\end{defn}
%
Given a program $c$ with a starting memory $m$ and database $D$, we generate its program-based graph 
$\traceG(\ssa{c, m}, D) = (\vertxs, \edges, \weights, \qflag)$.
%
Then the adaptivity bound based on program analysis for $\ssa{c}$ is the number of query vertices on a finite walk in $\progG(\ssa{c})$. This finite walk satisfies:
%
\begin{itemize}
\item the number of query vertices on this walk is maximum
\item the visiting times of each vertex $v$ on this walk is bound by its weight $\weights(v)$.
\end{itemize}
%
It is formally defined in \ref{def:trace_adapt}.
%
\begin{defn}
[Adaptivity of A Program].
\label{def:trace_adapt}
\\
Given a program $\ssa{c}$ in SSA language, 
its adaptivity is defined for all possible starting SSA memory $\ssa{m}$ and database $D$ as follows:
%
$$
A(c) = \max \big 
\{ \qlen(k) \mid \ssa{m} \in \mathcal{SM},D \in \dbdom , k \in \walks(\traceG(c, m, D) \big \} 
$$
\end{defn}
}
\\
%
%
%
%
\todo{
The following lemma describes a property of the trace-based dependency graph.
For any program $c$ with a database $D$ and a starting memory $m$,
the directed edges in its trace-based dependency graph can only be constructed from nodes representing 
smaller annotated queries to annotated queries of greater order.
There doesn't exist backward edges with direction from greater annotated queries to smaller ones.
}
\begin{lem}
\label{lem:edgeforwarding}
[Edges are Forwarding Only].
\\
%
{
Given a program $c$, a database $D$, a starting memory $m$ and the corresponding trace-based dependency graph $G(c,D,m) = (\vertxs, \edges)$, 
for any directed edge $(\av', \av) \in \edges$, 
this is not the case that:
%
$$\av' \avgeq \av$$
%
}
\end{lem}
%
\begin{proof}
Proof in File: {\tt ``edge\_forward.tex''}.
% \input{edge_forward}
\end{proof}
%
%
%
\begin{lem}
\label{lem:DAG}
[Trace-based Dependency Graph is Directed Acyclic].
\\
%
{
Every trace-based dependency graph is a directed acyclic graph.
}
\end{lem}
%
{
\begin{proof}
Proof is obvious based on the Lemma \ref{lem:edgeforwarding}.
\end{proof}
}
%
\begin{lem}
[Adaptivity is Bounded].
\\
{
Given the program $c$ with a certain database $D$ and starting memory $m$, the $A(c)$ w.r.t. the $D$ and $m$ is bounded, i.e.,:
%
\[
\config{m, c, [], []} 
\rightarrow^{*} 
\config{m', \eskip, t', w'} 
\implies
A_{D, m}(c) \leq |t'|
\]
}
\end{lem}
%
\begin{proof}
{
Proof is obvious based on the Lemma \ref{lem:DAG}.
}
\end{proof}
%
%
\clearpage
%
%
\subsection{SSA Transformation and Soundness of Transformation}
in File {\tt ``ssa\_transform\_sound.tex''}
% \input{ssa_transform_sound}
%
\clearpage