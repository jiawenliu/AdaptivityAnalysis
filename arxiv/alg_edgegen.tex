The set of edges $\progE(c)$ is estimated through a combined data and control flow analysis with three components.

Since the edges of the semantics-based graph of a program relies on the dependency relation, it contains both control flow and data flow. 
In this sense, We first develop a \emph{feasible data-flow} relation to estimate the data dependency relation, which catches these two flows.
Then we construct the edges for $\progG(c)$ based on this \emph{feasible data-flow} relation.
This algorithm named Feasible Data-Flow Generation. It 
considers both the control flow and data flow and
is a sound approximation of the edges in the semantics based dependency graph.
The three steps in this algorithm is summarized as follows,
\begin{enumerate}
  \item The \textbf{Reaching Definition} analysis computes a set of labeled variables, $\live(l, c)$ for every label $l$ in $c$
  over its abstract control flow graph, $\absG(c)$.
  The computation performs the standard reaching definition analysis and working-list algorithm over the abstract control flow graph, $\absG(c)$. 
  % as $\live(l, c)$ for every label $l$ in a program $c$. 
  $\live(l, c)$ contains all the labeled variables which are reachable at program point $l$. 
  For each label $l$, the analysis generates two initial sets of labeled variables, $in$ and $out$, 
  containing all the labeled variables $x^l$ that are newly generated but not yet reassigned before and after executing the command $l$.
  The analysis iterates over $\absG(c)$, and updates $in(l)$ and $out(l)$ until they  are stable.
  The final $in(l)$ is the set of reaching definitions $\live(l, c)$ for $l$. 
    \item The \textbf{Feasible Data-Flow} computation combines the $\live(l, c)$, $\absG(c)$ and data flow analysis. 
  It computes the \emph{feasible data-flow} relation,
  % estimates the data dependency relation, 
  $\flowsto(x^i, y^j, c)$ for each pair of the $c$'s labeled variables, $x^i, y^j \in \lvar(c)$ in Definition~\ref{def:feasible_flowsto}. $\flowsto(x^i, y^j, c)$ is a sound approximation 
  of the \emph{variable may-dependency} relation, $\vardep(x^i, y^j, c)$ for every $x^i, y^j \in \lvar(c)$.
  %  over labeled variables for every program.
  The formal proof is in the Appendix. We also discuss that the combined analysis gives more precise approximation on the \emph{data may-dependency} than single analysis in Appendix.
\item \textbf{Edge Estimation}
Using the $\flowsto(x^i, y^j, c)$ relation, we define the estimated directed edges
% for each vertex in $\progV(c)$,
as set of pairs of vertices $x^i, y^j\in \progV(c)$,
% as a set of pairs 
% $\progW(c) \in \mathcal{P}(\mathcal{LV} \times \mathcal{LV} \times EXPR(\constdom))$ 
$\progE(c) \in \mathcal{P}( \mathcal{LV} \times \mathcal{LV})$, by computing
% is the set of pairs 
% The weight for each vertex in $\progV(c)$ is computed 
% indicating 
transitive closure (through other variables) of the  
 $\flowsto$ relation.
\end{enumerate} 
The details are as follows.
%
\paragraph{Reaching definition analysis}
This part performs the standard reaching definition analysis given a program $c$, 
on 
% its every label $l$
every label in $\absV(c)$.  
This step generates set of all the reachable variables at location of label $l$ in the program $c$.
The $\live(l, c)$ represent the analysis result, which is the set of 
reachable labeled variables in program $c$ at the location of label $l$.
For every labelled variable $x^l$ in this set, 
the value assigned to that variable
in the assignment command associated to that label is reachable at the point of  executing the command of label $l$.
It is computed in five steps as follows,
\begin{enumerate}
\item The block, 
is either the command of the form of assignment, skip, or a test of the form of $[b]^{l}$, 
% and $block$ of program $c$ is 
denoted by $\mathsf{blocks}(c)$
the set of all the blocks 
in program $c$, where  $\mathsf{blocks}: \cdom \to \mathcal{P}(\cdom \cup \clabel{\bexpr}^{l})$.

A block  is either the command of the form of assignment, skip, or test of the form of $[b]^{l}$.\\
The operator $\mathsf{blk} : \cdom \to blocks$ gives all the blocks in program $c$.
\\
 Set $?$ to be undefined.
%  $label^{?}$ is label $\cup \{?\}$.\\
%  Define $\mathsf{kill}$: $blocks \to \mathcal{P}(\mathcal{V} \times LABEL \cup \{?\})$, which produces the set of labelled variables of assignment destroyed by the block.
\item The operator $\mathsf{kill}$: $blocks \to \mathcal{P}(\mathcal{V} \times \ldom \cup \{?\})$ produces the set of labelled variables of assignment destroyed by the block.
  % Define $\mathsf{gen}$: $blocks \to \mathcal{P}(\mathcal{V} \times LABEL \cup \{?\})$, which generates the set of labelled variables generated by the block.
\item  The operator $\mathsf{gen}$: $blocks \to \mathcal{P}(\mathcal{V} \times \ldom \cup \{?\})$ generates the set of labelled variables generated by the block.
\item The operator  $in(l)$, $out(l)$: $ \ldom \to \mathcal{LV} \cup \{?\}$ for every block in program $c$ is defined as follows,
 \[
 \begin{array}{ll}
    % in(l)  & = \{ (x, ?) | x^l \in \lvar_c \land  l = \absinit(c) \}  
    in(l)  & = \{ x^{?} | x^l \in \lvar_c \land  l = \absinit(c) \}  
    \cup \{ out(l')|  | (l',\_, l) \in \absE(c) \land  l \neq \absinit(c)\}  \\
     out(l)  & =  gen(B^{l}) \cup \{ in(l) \setminus kill(B^l)  \}  
 \end{array}
 \]
computing $in(l)$ and $out(l)$ for every $B^l \in blocks(c) $, and repeating these two steps
until the $in(l)$ and $out(l)$ are stabilized for every $B^l \in blocks(c) $
% We use $\live_{in}(l,c)$ and $\live_{out}(l, c)$ denote the stabilized results for the command of label $l$ in program $c$. 
We use $\live(l,c)$ to represent 
% $\live_{in}(l,c)$ in the other part of the paper.
denote the stabilized result of $in(l)$ at label $l$ in program $c$. 
% The $\live_{in}(l,c)$ and $\live_{out}(l, c)$ is computed by the Standard worklist algorithm. (For simplicity, we use $\live(l,c)$ to represent $\live_{in}(l,c)$ in the other part of the paper.}
% \\
% The $\live_{in}(l,c)$ and $\live_{out}(l, c)$ 
\item The stabilized $in(l)$ and $out(l)$ for program $c$, as well as $\live(l, c)$,
is computed by the standard work-list algorithm with detail as below. 
% For simplicity, we use $\live(l,c)$ to represent $\live_{in}(l,c)$ in the other part of the paper.
\begin{enumerate}
    \item \textbf{initialize} in[l]=out[l]=$\emptyset$;
    % \item 
     in[0] = $\emptyset$
    \item \textbf{initialize} a work queue $W$, contains all the blocks in $c$
    \item while $|W|$ != 0 \\
          pop $l$ in $W$ \\
          old = out[l] \\
          $in(l)$ =  $out(l')$ where $(l',\_, l) \in \absE(c)$\\
          $out(l)$ = $\mathsf{gen}(b^l)$ $\cup$ ($in(l) - kill(b^l)$ ), where $b^l \in \mathsf{blk}(c)$   \\
          \textbf{if} (old != out(l)) $W = W \cup \{l'| (l,l') \in (l',\_, l) \in \absE(c)\}$ \\
          end while
\end{enumerate}
\end{enumerate}
%
\paragraph{Feasible Data-Flow Computation}
This part presents the computation of the \emph{feasible data-flow} relation between each pair of labeled variables in a program $c$,
formally in Definition~\ref{def:feasible_flowsto}, 
%
%
\begin{defn}[Feasible Data-Flow]
  \label{def:feasible_flowsto}
  Given a program $c$ and two labeled variables $x^i, y^j$  in this program, 
  $\flowsto(x^i, y^j, c)$ is 
    {\small
    \[
   \begin{array}{ll}
    \flowsto(x^i, y^j, \clabel{\assign{y}{\expr}}{}^l)  & \triangleq (x^i, y^j) \in \{ (x^i, y^l) | x \in \mathsf{FV}(\expr) 
    \land x^i \in \live(l, \clabel{\assign{y}{\expr}}^l) \}  \\
    \flowsto(x^i, y^j, \clabel{\assign{y}{\query(\qexpr)}}{}^l)  & \triangleq (x^i, y^j) \in \{ (x^i, y^l) | x \in \mathsf{FV}(\qexpr) 
    % \land (y,i) \in \live(l,\clabel{\assign{x}{\query(\qexpr)}}^l) \}  \\
    \land x^i \in \live(l,\clabel{\assign{y}{\query(\qexpr)}}^l) \}  \\
    \flowsto(x^i, y^j, [\eskip]^{l})  & = \emptyset \\
    \flowsto(x^i, y^j, \eif ([b]^l, c_1, c_2))  & \triangleq \flowsto(x^i, y^j, c_1) \lor \flowsto(x^i, y^j, c_2) \\ 
        & \lor (x^i, y^j) \in
        \left\{(x^i,y^j) | x \in \mathsf{FV}(b) \land 
      %  (x,i) 
      x^i \in \live(l, \eif ([b]^l, c_1, c_2)) \land  y^j \in \lvar(c_1) \right\} \\
    %   ([y = \_]^j) \in \mathsf{blk}(c_1) \} \\
       &\lor (x^i, y^j) \in \left\{(x^i,y^j) | x \in \mathsf{FV}(b) \land 
      %  (x,i) 
      x^i\in \live(l, \eif ([b]^l, c_1, c_2))  \land  y^j \in \lvar(c_2)  \right\} \\
    %   \land ([y = \_]^j) \in \mathsf{blk}(c_2) \} \\
       \flowsto(x^i, y^j, \ewhile [b]^l \edo c_w)  & \triangleq  \flowsto(x^i, y^j, c_w)  \lor
       \\ & 
       (x^i, y^j) \in  \left\{(x^i,y^j) | x \in \mathsf{FV}(b) \land 
      %  (x,i) 
      x^i \in \live(l,   \ewhile [b]^l \edo c_w) \land  y^j \in \lvar(c_w) \right\} \\
    %   ([y = \_]^j) \in \mathsf{blk}(c_w) \} \\
       \flowsto(x^i, y^j, c_1 ;c_2)  & \triangleq \flowsto(x^i, y^j, c_1) \lor \flowsto(x^i, y^j, c_2) \\
   \end{array}
   \]
   }
   \end{defn}
%
We prove that the transitive closure of the \emph{Feasible Data-Flow} relation is a sound approximation 
of the \emph{Variable May-Dependency} relation over labeled variables for every program,
in Appendix~\ref{apdx:flowsto_soundness}.
%

\highlight{Improvement Analysis.}
Combining the result of \emph{reaching definition}, $\live(l, c)$
with the \emph{abstract control flow graph}, $\absG(c)$ with control flow analysis into the feasible 
data-flow generation improves the data-dependency relation approximation accuracy. 
For example, a program $ [x = 0]^{1}; [x=2]^{2};  [y = x+1]^{3}$. 
The standard data flow analysis 
tells us that both the labeled variable $x^{1}$ and $x${2} may flow to $y^{3}$, which will result in an unnecessary edge ($x^{1}, y^{3}$). The result of reaching definition 
can help us eliminate this kind of edge by telling us, at line $3$, only variable $x^{2}$ is reachable. 
% \paragraph*{Edges Estimation}
\paragraph{Edge Estimation}
The \textbf{Edge Estimation}
is based on the $\flowsto(x^i, y^j, c)$ relation.
For each pair of vertices $x^i, y^j$ in $\progV(c)$,
There is a directed edge from  $x^i$ to $y^j$ if and only if there is chain of variables 
in the $\flowsto$ relation between $x^i$ and $y^j$. 
Using the $\flowsto(x^i, y^j, c)$ relation, we define the estimated directed edges as a set which contains all
pair of vertices $x^i, y^j$ in $\progV(c)$, 
$\progE(c) \in \mathcal{P}( \mathcal{LV} \times \mathcal{LV})$
satisfying in the transitive closure of $\flowsto$ as follows,
\highlight{
  \[
    \begin{array}{ll}
    \progE(c) \triangleq &
    \{ 
    (y^j, x^i) ~ \vert ~ y^j, x^i \in \progV(c)
    \land
      \exists n,
      z_1^{r_1}, \ldots, z_n^{r_n} \in \lvar(c) \st 
    \\ & \qquad \qquad
      n \geq 0 \land \flowsto(x^i,  z_1^{r_1}, c) 
      \land \cdots \land \flowsto(z_n^{r_n}, y^j, c) 
    \}
    \end{array}
    \]
}
We prove that this estimated directed edge set $\progE(c)$ is a sound approximation of the 
edge set in $c$'s semantics-based dependency graph 
in Appendix~\ref{apdx:adapt_soundness}.
\begin{lem}[Mapping from Egdes of $\traceG$ to $\progG$]
	For every program $c$ we have:
   \begin{center}
$
	\begin{array}{l}
	\forall e = (v_1, v_2) \in \traceE(c)
	\st 
	\exists e' \in \progE(c) \st e' = (v_1, v_2)
	\end{array}
$
\end{center} 
\end{lem}
  \paragraph*{Example}
  %
As in the Figure~3(c), 
the edge $l^6 \to a^5$ is built by $\flowsto(l^6, a^5, c)$ relation because
% By $\flowsto(l^6, a^5, c)$, we can see 
$a$ is used directly in the query expression $\chi[k]*a$
in the command $\clabel{\assign{l}{\query(\chi[k]*a)}}^6$,
i.e., $a \in FV(\chi[k]*a)$.
And we also have $a^5 \in \live(6, \kw{twoRounds(k)})$ from the reaching definition analysis.
% Then we have $\flowsto(l^6, a^5, c)$ and construct the edge $l^6 \to a^5$.
Another edge $x^3 \to j^5$ in the same graph represents the control flow from $j^5$ to $x^3$, which is soundly caught by our $\flowsto$ relation.