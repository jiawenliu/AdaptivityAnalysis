The set of edges $\progE(c)$ is estimated through a combined data and control flow analysis with three components.

Since the edges of the semantics-based graph of a program rely on the dependency relation, it contains both control flow and data flow. 
In this sense, We first compute a \emph{feasible data-flow} relation to estimate the \emph{variable may-dependency} relation, which catches these two flows.
Then we construct the edges for $\progG(c)$ based on this \emph{feasible data-flow} relation.
% This algorithm is named Feasible Data-Flow Generation. 
It 
considers both the control flow and data flow and
is a sound approximation of the edges in the semantics-based dependency graph.
This algorithm is summarized into three steps as follows,
\begin{enumerate}
 \item 
 We first perform the \textbf{reaching definition} analysis and compute a set of labeled variables that is reachable for every label $l$ in $c$, $\live(l, c)$.
 For example, in the following program
 \[
 c = \clabel{\assign{x}{\query(\chi[1])}}^0 ;\clabel{\assign{x}{\query(\chi[0])}}^1 ;
 \clabel{\assign{y}{\query(\chi[x])}}^2,
 \]
 only $x^1$ is reachable when executing $\clabel{\assign{y}{\query(\chi[x])}}^2$.
 So we want to have $\live(2, c) = \{1\}$.
The computation performs the standard reaching definition analysis and working-list algorithm over the abstract control flow graph, $\absG(c)$. 
 % as $\live(l, c)$ for every label $l$ in a program $c$. 
 $\live(l, c)$ contains all the labeled variables which are reachable at program point $l$. 
 For each label $l$, the analysis generates two initial sets of labeled variables, $in$ and $out$, 
 containing all the labeled variables $x^l$ that are newly generated but not yet reassigned before and after executing the command $l$.
 The analysis iterates over $\absG(c)$, and updates $in(l)$ and $out(l)$ until they are stable.
 The final $in(l)$ is the set of reaching definitions $\live(l, c)$ for $l$. 
 \item 
 Then we compute the \textbf{feasible data-flow} relation
 for every pair of labeled variables in a program $c$.
 % This computation combines the $\live(l, c)$, $\absG(c)$ and the data flow analysis. 
 Specifically, the \emph{feasible data-flow} relation denoted by
 % estimates the data dependency relation, 
 $\flowsto(x^i, y^j, c)$ for each pair of labeled variables the $c$ in a program $c$, $x^i, y^j \in \lvar(c)$.
 It combines the $\live(l, c)$, $\absG(c)$, and the data flow analysis, which gives a more precise approximation on the \emph{data may-dependency} than the result from a single analysis.
 We also prove it is a sound approximation 
 of the \emph{variable may-dependency} relation, $\vardep(x^i, y^j, c)$ for every $x^i, y^j \in \lvar(c)$.
\item 
Then 
% we estimate the edge
% \textbf{Edge Estimation}
using the $\flowsto(x^i, y^j, c)$ relation, we define the estimated directed edges
% for each vertex in $\progV(c)$,
as set of pairs of vertices $x^i, y^j\in \progV(c)$,
% as a set of pairs 
% $\progW(c) \in \mathcal{P}(\mathcal{LV} \times \mathcal{LV} \times EXPR(\constdom))$ 
$\progE(c) \in \mathcal{P}( \mathcal{LV} \times \mathcal{LV})$, by computing
% is the set of pairs 
% The weight for each vertex in $\progV(c)$ is computed 
% indicating 
transitive closure (through other variables) of the 
 $\flowsto$ relation.
\end{enumerate} 
The details are as follows.
%
\paragraph{Reaching definition analysis}
This part performs the standard reaching definition analysis given a program $c$, 
on 
% its every label $l$
every label in $\absV(c)$. 
This step generates that the set contains all the reachable variables at location $l$ in the program $c$.
The $\live(l, c)$ represents the analysis result, which is the set of 
reachable labeled variables in program $c$ at the location of label $l$.
For every labeled variable $x^l$ in this set, 
the value assigned to that variable
in the assignment command associated with that label is reachable at the point of executing the command of label $l$.
It is computed in five steps as follows,
\begin{enumerate}
\item The block, 
is either the command of the form of assignment, skip, or a test of the form of $[b]^{l}$, 
% and $block$ of program $c$ is 
denoted by $\mathsf{blocks}(c)$
the set of all the blocks 
in program $c$, where $\mathsf{blocks}: \cdom \to \mathcal{P}(\cdom \cup \clabel{\bexpr}^{l})$.

A block is either the command of the form of assignment, skip, or test of the form of $[b]^{l}$.\\
The operator $\mathsf{blk}: \cdom \to blocks$ gives all the blocks in program $c$.
\\
 Set $?$ to be undefined.
% $label^{?}$ is label $\cup \{?\}$.\\
% Define $\mathsf{kill}$: $blocks \to \mathcal{P}(\mathcal{V} \times LABEL \cup \{?\})$, which produces the set of labeled variables of assignment destroyed by the block.
\item The operator $\mathsf{kill}$: $blocks \to \mathcal{P}(\mathcal{V} \times \ldom \cup \{?\})$ produces the set of labeled variables of assignment destroyed by the block.
 % Define $\mathsf{gen}$: $blocks \to \mathcal{P}(\mathcal{V} \times LABEL \cup \{?\})$, which generates the set of labeled variables generated by the block.
\item The operator $\mathsf{gen}$: $blocks \to \mathcal{P}(\mathcal{V} \times \ldom \cup \{?\})$ generates the set of labeled variables generated by the block.
\item The operator $in(l)$, $out(l)$: $ \ldom \to \mathcal{LV} \cup \{?\}$ for every block in program $c$ is defined as follows,
 \[
 \begin{array}{ll}
 % in(l) \\ \qquad \triangleq \{ (x, ?) | x^l \in \lvar(c) \land l = \absinit(c) \} 
 in(l) \triangleq \{ x^{?} | x^l \in \lvar(c) \land l = \absinit(c) \} 
 \\ \qquad \qquad \cup \{ out(l')| | (l',\_, l) \in \absE(c) \land l \neq \absinit(c)\} \\
 out(l) \triangleq gen(B^{l}) \cup \{ in(l) \setminus kill(B^l) \} 
 \end{array}
 \]
computing $in(l)$ and $out(l)$ for every $B^l \in blocks(c) $, and repeating these two steps
until the $in(l)$ and $out(l)$ are stabilized for every $B^l \in blocks(c) $
We use $\live(l,c)$ to represent 
denote the stabilized result of $in(l)$ at label $l$ in program $c$. 
%
\item The stabilized $in(l)$ and $out(l)$ for program $c$, as well as $\live(l, c)$,
is computed by the standard work-list algorithm with detail as below. 
% For simplicity, we use $\live(l,c)$ to represent $\live_{in}(l,c)$ in the other part of the paper.
\begin{algorithm}
 \caption{
 {Working List Algorithm ({$\kw{wklist(c, \absG(c)))}$})}
 \label{alg:adapt}
 }
 \begin{algorithmic}[1]
 \REQUIRE The program $c$, the abstract control flow graph $\absG(c)$.
 \STATE \textbf{initialize} in[l]=out[l]=$\emptyset$; in[0] = $\emptyset$
 \\
 a work queue $W$, contains all the blocks in $c$
 \STATE {\bf while} $|W|$ != 0 \\
 \STATE \qquad pop $l$ in $W$ \\
 \STATE \qquad old = out[l] \\
 \STATE \qquad $in(l)$ = $out(l')$ where $(l',\_, l) \in \absE(c)$\\
 \STATE \qquad $out(l)$ = $\mathsf{gen}(b^l)$ $\cup$ ($in(l) - kill(b^l)$), where $b^l \in \mathsf{blk}(c)$ \\
 \STATE \qquad {\bf if} (old != out(l)) $W = W \cup \{l'| (l,l') \in (l',\_, l) \in \absE(c)\}$ 
 \end{algorithmic}
 \end{algorithm}
\end{enumerate}
%
\paragraph{Feasible Data-Flow Computation}
This part presents the computation of the \emph{feasible data-flow} relation between each pair of labeled variables in a program $c$,
formally in Definition~\ref{def:feasible_flowsto}, 
%
%
\begin{defn}[Feasible Data-Flow]
 \label{def:feasible_flowsto}
 Given a program $c$ and two labeled variables $x^i, y^j$ in this program, 
 $\flowsto(x^i, y^j, c)$ is 
 \[
 \begin{array}{l}
 \flowsto(x^i, y^j, \clabel{\assign{y}{\expr}}{}^l) 
 \\ \qquad \triangleq (x^i, y^j) \in \{ (x^i, y^l) | x \in \kw{FV}(\expr) 
 \land x^i \in \live(l, \clabel{\assign{y}{\expr}}^l) \} \\
 \flowsto(x^i, y^j, \clabel{\assign{y}{\query(\qexpr)}}{}^l) 
 \\ \qquad \triangleq (x^i, y^j) \in \{ (x^i, y^l) | x \in \kw{FV}(\qexpr) 
 \land x^i \in \live(l,\clabel{\assign{y}{\query(\qexpr)}}^l) \} \\
 \flowsto(x^i, y^j, \clabel{\eskip}^{l}) 
 \triangleq \emptyset \\
 \flowsto(x^i, y^j, \eif (\clabel{\bexpr}^{l}, c_1, c_2)) 
 \\ \qquad \triangleq \flowsto(x^i, y^j, c_1) \lor \flowsto(x^i, y^j, c_2) 
 \\ \qquad \quad \lor (x^i, y^j) \in \big\{(x^i,y^j) | x \in \kw{FV}(b) 
 x^i \in \live(l, \eif (\clabel{\bexpr}^{l}, c_1, c_2)) \land y^j \in \lvar(c_1)\cup \lvar(c_2) \big\}
 \\
 \flowsto(x^i, y^j, \ewhile \clabel{\bexpr}^{l} \edo (c_w)) 
 \\ \qquad \triangleq \flowsto(x^i, y^j, c_w) 
 \\ \qquad \quad \lor
 (x^i, y^j) \in \big\{(x^i,y^j) | x \in \kw{FV}(b) 
 \land x^i \in \live(l, \ewhile \clabel{\bexpr}^{l} \edo (c_w)) \land y^j \in \lvar(c_w) \big\} 
 \\
 \flowsto(x^i, y^j, c_1 ;c_2) 
 \triangleq \flowsto(x^i, y^j, c_1) \lor \flowsto(x^i, y^j, c_2) \\
 \end{array}
 \]
 \end{defn}
%
We prove that the transitive closure of the \emph{Feasible Data-Flow} relation is a sound approximation 
of the \emph{Variable May-dependency} relation over labeled variables for every program,
in Appendix~\ref{apdx:flowsto_soundness}.
%

The combinations of the result of \emph{reaching definition}, $\live(l, c)$
with the \emph{abstract control flow graph}, $\absG(c)$ with control flow analysis into the feasible 
data-flow generation improves the data-dependency relation approximation accuracy. 

\textbf{Example I.}
In an example program $\clabel{\assign{x}{0}}^{0}; \clabel{\assign{x}{2}}^{1}; \clabel{\assign{y}{x + 1}}^{2}$. 
The standard data flow analysis 
tells us that both the labeled variable $x^{0}$ and $x^1$ may flow to $y^{2}$, which will result in an unnecessary edge ($x^{0}, y^{2}$). The result of reaching definition 
can help us eliminate this kind of edge by telling us, at line $2$, only variable $x^{1}$ is reachable. 

\textbf{Example II.}
This analysis focuses on guaranteeing soundness,
there is an over-approximation in the operation $\kw{FV}(\expr)$ by looking into only the syntactic dependency.
For example, in the program 
$\clabel{\assign{x}{\query(\chi[0])}}^{0}; \clabel{\assign{y}{x - x}}^{1}$,
$y^1$ does not depend on $x^0$ by Definition~\ref{def:var_dep}.
However, the Definition~\ref{def:feasible_flowsto} still produces the $\flowsto(x^0, y^1, x)$, which over-approximates the variable may-dependency relation.

\paragraph{Edge Estimation}
The \textbf{Edge Estimation}
is based on the $\flowsto(x^i, y^j, c)$ relation.
For each pair of vertices $x^i, y^j$ in $\progV(c)$,
There is a directed edge from $x^i$ to $y^j$ if and only if there is a chain of variables 
in the $\flowsto$ relation between $x^i$ and $y^j$. 
Using the $\flowsto(x^i, y^j, c)$ relation, we define the estimated directed edges as a set that contains all
pair of vertices $x^i, y^j$ in $\progV(c)$, 
$\progE(c) \in \mathcal{P}( \mathcal{LV} \times \mathcal{LV})$
satisfying in the transitive closure of $\flowsto$ as follows,

\[
 \begin{array}{ll}
 \progE(c) \triangleq &
 \{ 
 (y^j, x^i) ~ \vert ~ y^j, x^i \in \progV(c)
 \land
 \exists n,
 z_1^{r_1}, \ldots, z_n^{r_n} \in \lvar(c) \st 
 \\ & \qquad \qquad
 n \geq 0 \land \flowsto(x^i, z_1^{r_1}, c) 
 \land \cdots \land \flowsto(z_n^{r_n}, y^j, c) 
 \}
 \end{array}
 \]

 We prove that this estimated directed edge set $\progE(c)$ is a sound approximation of the 
edge set in $c$'s semantics-based dependency graph 
in Appendix~\ref{apdx:adapt_soundness}.
\begin{lem}[Mapping from Egdes of $\traceG$ to $\progG$]
 For every program $c$ we have:
 \begin{center}
$
 \begin{array}{l}
 \forall e = (v_1, v_2) \in \traceE(c)
 \st 
 \exists e' \in \progE(c) \st e' = (v_1, v_2)
 \end{array}
$
\end{center} 
\end{lem}

As in the Figure~\ref{fig:overview-example}(c), 
the edge $l^6 \to a^5$ is built by $\flowsto(l^6, a^5, c)$ relation because
$a$ is used directly in the query expression $\chi[k]*a$
in the command $\clabel{\assign{l}{\query(\chi[k]*a)}}^6$,
i.e., $a \in \kw{FV}(\chi[k]*a)$.
And we also have $a^5 \in \live(6, \kw{twoRounds(k)})$ from the reaching definition analysis.
Another edge $x^3 \to j^5$ in the same graph represents the control flow from $j^5$ to $x^3$, which is soundly caught by our $\flowsto$ relation.
