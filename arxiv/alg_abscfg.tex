This section shows how to generate the abstract transition graph $\absG(c)$ of a
program $c$ through constructing its vertices and edges.

An \emph{Abstract Transition Graph}, $\absG(c)$ for a program $c$ is composed of
a vertex set $\absV(c)$ and an edge set $\absE(c)$, $\absG(c) \triangleq (\absV(c), \absE(c))$.
% For a program $c$, this analysis first generates its abstract execution control flow graph notated as follows,
% \[\absG(c) =(\absV(c), \absE(c))\]
%
\\
Every 
vertex $l \in \absV(c)$ is the label of a labeled command in $c$, which is unique.
We also call the unique label as program point.
% corresponds to a program point $l$, which is a unique
% label of a command in this program.
% $\absV(c)$ is the set of $c$'s all program points,
\\
Each edge $(l \xrightarrow{dc} l') \in \absE(c)$ is an abstract transition
between two program points $l, l'$. 
There is an edge from $l$ to $l'$ if and only if
the command with label $l'$ can execute right after the execution of the command with label $l$.
% if and only if there is a control flow between two program points.
Each edge is annotated by a constraint $dc \in \dcdom^{\top}$, which is generated from the command with label $l$.
This constraint describes the abstract execution of the command with $l$. 
%  before the introduction of the edge and weight estimation.  
% We discuss the vertices and edge of the
% abstract transition graph for a program $c$, $\absG(c)$.

\paragraph{Abstract Control Flow Graph Vertices Construction}
\label{sec:alg_abscfg-vertex}
Every 
vertex $l \in \absV(c)$ corresponds to a program point $l$, which is a unique
label of a command in this program.
Concretely,
the vertices of this graph is the set of $c$'s labels with the exit label ${\lex}$ formally as follows,
\[ 
  \absV(c) = \lvar(c)\cup\{{\lex}\}
\]
%  corresponding to a label command in the program.

\paragraph{Abstract Control Flow Graph Edge Construction}
\label{sec:alg_abscfg-edge}

Each edge $(l \xrightarrow{dc} l') \in \absE(c)$ is an abstract transition
between two program points $l, l'$. 
The edge is constructed by the standard control flow analysis satisfying
there is an edge from $l$ to $l'$ if and only if
the command with label $l'$ can execute right after the execution of the command with label $l$.

% if and only if there is a control flow between two program points.
Each edge is annotated by a constraint $dc$ generated from the command with label $l$.
This constraint describes the abstract execution of the command with $l$. 
It is either
the symbol $\top$, 
a boolean expression or 
a \emph{difference constraint} computed according to the algorithm in~\cite{SinnZV17}.
% This step shows how to generate the abstract transition graph $\absG(c)$ of a
% program $c$ through constructing its vertices and edges.
Below we summarize how to compute the constraints and generate the edges in three steps,
\begin{enumerate}
 \item In the first step, we generate the \emph{constraint}
 of the expression for every program's labeled command,
 which is used as the annotation of an edge.

 \item In the second step, we compute the \emph{initial and continuation state} for each command. 
%  The initial state is a set that contains the
%  program point where this command {starts} executing, 
%  and the continuation state is a set
%  that contains the constraint of this command
%  and the continuation program points after the execution of this command.

 \item In the third step, we compute the set of edges for the program, $\absflow(c)$.
 Each edge is an \emph{abstract event}, which is a pair of the initial and continuation states.
\end{enumerate}
%
\paragraph{Constraint Computation}
% In this step, we first show how to compute the constraints for expressions in a program $c$,
% by a program abstraction method adopted from the
% algorithm in Section 6 in~\cite{SinnZV17}.
% \\
Given a program $c$,
every expression in an assignment command or in the guard of a $\eif$ or $\ewhile$ command
is transformed into a constraint as follows.
%
%
\begin{defn}[Difference Constraint, Symbolic Constant]
The difference constraints $DC(\mathcal{V} \cup \constdom)$ is the set of all the inequality of
form $x' \leq y + v$ or $x' \leq v$ where $x \in \mathcal{V} $, 
$y \in \mathcal{V}$ and $v \in \scvardom$.
The \emph{Symbolic Constant} can be a natural number, $\infty$, the input variable of a program, $\inpvardom$ or
$Q_m$ representing the maximum value returned as the query answer. 
We use $\scvardom \subseteq \mathbb{N} \cup \vardom \cup \{ \infty, Q_m \}$ to denote the universe of all \emph{Symbolic Constant},
which is the set of all natural numbers with $\infty$ and programs' input variables.
\end{defn}
An inequality $x' \leq y + v$ describes that the value of $x$ in the current state is
at most the value of $y$ in the previous state plus the symbolic constant $v$.
An inequality $x' \leq v$ describes that the value of $x$ in the current state is
at most the value $v$.

\begin{defn}[Symbolic Expression]
 \label{def:adaptfun-symbolic_expr}
 The \emph{symbolic expression} of a program $\scexpr(c) \subseteq \mathcal{A}$ is the set of all the arithmetic expressions over $\mathbb{N} \cup \inpvar(c) \cup \{\infty, Q_m \}$ for the program $c$.
\end{defn}

\begin{defn}[Constraint]
 The constraint set, $\dcdom^{\top}$ is composed of the \emph{Difference Constraints} $DC(\mathcal{V} \cup \constdom)$, the \emph{Boolean Expressions}, $\booldom$ and $\top$.
 \end{defn}
 

When a difference constrain shows up as an edge annotation, $l \xrightarrow{x' \leq y + v} l'$,
% Then $x'$ 
it denotes that
the value of variable $x$
after executing the command at $l$ is at most
% and the right-hand side describes 
the value of variable $y$ plus $v$ before the execution,
and $l \xrightarrow{x' \leq v} l'$ respectively denotes value of variable $x$
after executing the command at $l$ is at most
the value of the symbolic constant $v$ before the execution.
We have $l \xrightarrow{x' \leq Q_m} l'$ in the case that command $l$ is a query request and the query answer is assigned to variable $x$.

%

The Boolean Expressions $b$ from the set $\booldom$.
$b$ on an edge $l \xrightarrow{b} l'$ describes
that after evaluating the guard with label $l$,
$b$ holds and the command with label $l$ will execute right after.
%

The top constraint, $\top$ denotes true. It is preserved for $\eskip$ command or commands that don't
interfere with any counter variable.


For every expression in each of the label commands, we abstract it into a constraint in three steps via the program abstraction method as below.
It is a context-free computation skeleton overall the variable and value domain. In a specific computation with a given program $c$, these domains will associate with the program $c$.

\begin{defn}[Constraint Computation]
 \label{def:constraint_compute}
 With a program $c$, a boolean expression $\bexpr$ in the guard of a $\eif$ or $\ewhile$ command
 or an expression $\expr$ and a variable $x$
 in an assignment command $\assign{x}{\expr}$ as input.

 We first initialize 
 $\grdvar = \{\}$ as the set of the variable used in the expression of every while or if guard in the program $c$.

 Then the constraint $\absexpr(\bexpr, \_)$ or $\absexpr(x - v, x)$ is computed as follows,
 \[
 \begin{array}{ll} 
 \absexpr(x - v, x) = x' \leq x - v & x \in \grdvar \land v \in \constdom \\
 \absexpr(y + v, x) = x' \leq y + v & x, y \in \grdvar \land v \in \constdom \\
 \absexpr(v, x) = x' \leq v & x \in \grdvar \land v \in (\grdvar \cup \constdom) \\
 \absexpr(y + v, x) = x' \leq y + v, 
 \grdvar = \grdvar \cup \{y\} & x \in \grdvar \land y \notin \grdvar \land v \in \constdom \\
 \absexpr(\qexpr, x) = x' \leq Q_m & x \in \grdvar \land \qexpr \text{ is a query expression} \\
 \absexpr(\bexpr, \_) = \bexpr, \grdvar = \grdvar \cup 
 \kw{FV}(\bexpr) & x \in \grdvar \land \bexpr \text{ is a boolean expression} \\
 \absexpr(\expr, x) = \top & x \notin \grdvar \\
 \end{array}
 \]
 $\absexpr(\expr, x)$ and $\grdvar$ is iteratively updating until stabilized over every guard and assignment command in $c$.
 We use $\absexpr(\expr, x)$
 to denote the stabilized result in the following paper.
 \end{defn}
%
$\grdvar \subseteq \vardom$ is the domain for all variables used in the guard expression of every while command overall programs. 
In the fourth case, if a variable $x$, belonging to the set 
$\grdvar$ is updated by a variable $y$, which isn't in this set, 
we add $y$ into the set $\grdvar$ and repeat 
above procedure until $\grdvar$ and $\absexpr(\expr, x)$ is stabilized. 
Specifically,
we handle a normalized expression, $x > 0$
in guards of while loop headers, and 
the counter variable $x$ only increases, decreases, or is reset by 
simple arithmetic expression (mainly multiplication, division, minus, and plus (able to extend to max and min)). 
The counter variable $x$ is generalized into the norm when the boolean expression $x > 0$
in $\ewhile$ doesn't have the form $x > 0$.
The way of normalizing the guards and computing the norms is adopted from the computation step 1 in Section 6.1 in paper \cite{SinnZV17}. 

In the $5^{th}$ case where the expression comes from a query request, we abstract this query expression into $x \leq Q_m$.
By doing this, we ignore the answer of this query in the static analysis just to capture the possible dependency relation pass through query requests.
% \\
\begin{defn}[Universe of The Symbolic Expression ($\scexprdom$)]
 \label{def:symbolic_expr_domain}
 $\scexprdom$ is the universe of all the arithmetic expressions 
over $\constdom$, $\scexprdom \subseteq \mathcal{A}$
\end{defn}
Intuitively, the symbolic expression set is a subset of arithmetic expressions over $\mathbb{N}$
by restricting the variables into the
input variables.
% , 
% i.e., $\scexprdom \subseteq \inpexprdom$.

\paragraph{Initial and Continuation State Computation}
% The initial state is the
% program points before executing this command, which is computed by the standard initial state generation method from control flow analysis.
% The continuation state is a set
% that contains the constraint of this command and the program points after the execution of this command.
% This set is enriched 
% % program's initial and continuation states 
% from the standard control flow analysis.

\begin{itemize}
 \item The \emph{initial state}, $\absinit(c) \in \mathcal{P}(\ldom)$
 for a command $c$ is the label of the first command that will be executed in $c$,
 computed as follows,
%
\[
 \begin{array}{ll}
 \absinit(\clabel{\assign{x}{\expr}}{}^l) & = l \\
 \absinit(\clabel{\assign{x}{\query(\qexpr)}}{}^l) & = l \\
 \absinit(\clabel{\eskip}^{l}) & = l \\
 \absinit(\eif \clabel{\bexpr}^{l} \ethen c_1 \eelse c_2) & = l\\
 \absinit(\ewhile \clabel{\bexpr}^{l} \edo (c_w)) & = l \\
 \absinit(c_1 ; c_2) & = \absinit(c_1) \\
 \end{array}
 \]
\item The \emph{continuation state} of the program $c$, 
$\absfinal(c) \in \mathcal{P}(\ldom \times \dcdom^{\top})$
is a set of pairs, $(l, dc)$ with a
program point (i.e., a label), $l$ as the first component and a constraint, 
$dc$ as the second component.
% Every pair in $\absfinal(c)$ 
The program point $l$ is the label of the command that is evaluated at last during the execution of $c$,
and the constraint $dc$ in this pair is generated from this last command of label $l$.
%  by $\absexpr$ for the expression in $c$.
% in the first step.

Given a program $c$, its continuation state, $\absfinal(c)$ is computed as follows,
% $\absfinal(c) \in\mathcal{P}(\ldom \times \dcdom^{\top})$,
% computes the set of Abstract continuation state for the command. 
 \[
 \begin{array}{ll}
 \absfinal(\clabel{\assign{x}{\expr}}{}^l) & = \{(l, \absexpr\eapp (\expr, x))\} \\
 \absfinal(\clabel{\assign{x}{\query(\qexpr)}}{}^l) & = \{
 (l, x' \leq 0 + Q_m )\} \\
 \absfinal(\clabel{\eskip}^{l}) 
 & = \{(l, \top)\} \\
 \absfinal(\eif \clabel{\bexpr}^{l} \ethen c_1 \eelse c_2) & = \absfinal(c_1) \cup \absfinal(c_2) \\
 \absfinal(\ewhile \clabel{\bexpr}^{l} \edo (c_w)) & = \{(l, \absexpr(\bexpr, \top))\} \\
 \absfinal(c_1 ; c_2) & = \absfinal(c_2) \\
 \end{array}
 \]
 %
\end{itemize}
 \paragraph{Abstract Event Computation} 
% Each abstract event is an edge between two vertices in the abstract transition graph.
% It is 
 The set of abstract events for a program $c$ is generated by computing the initial state and continuation state interactively and recursively.
% \begin{itemize}
% \item \emph{Abstract Event}: 
% $\absevent \in $
% $\ldom \times \dcdom^{\top} \times \ldom$
% \item \emph{Abstract Event Computation}: $\absflow \in \cdom \to \mathcal{P}( \ldom \times \dcdom^{\top} \times \ldom )$
% \end{itemize}
 \begin{defn}[Abstract Event]
 \label{def:adaptfun-abs_event}
 An \emph{abstract event},
 $\absevent \in $
 $\ldom \times \dcdom^{\top} \times \ldom$
 is a 
 % pair of the abstract initial state and continuation state.
 triple where the first and third components are labels,
 second component is a constraint from $\dcdom^{\top}$.
 % the thrid % computed from program's abstract final and initial state, $\absfinal(c)$ and $\absinit(c)$ with formal definition, and algorithm detail in Appendix.
 % the constraint and the third corresponds to a continuation state.
 \end{defn}
 In an abstract event $(l, dc, l')$ of a program $c$, 
 the first label $l \in \ldom$ corresponds to an initial state of $c$, and 
 the second label $l' \in \ldom$ with the constraint $dc \in \dcdom^{\top}$ correspond to an abstract continuation state of $c$.
 The abstract initial state is a label from $\ldom$.
% The abstract continuation state is a pair from $\ldom \times \dcdom^{\top}$, 
% where first component is a label from $\ldom$ and the second component is a constraint from $\dcdom^{\top}$.
 %
% We abuse the notation $\mathcal{P}(\absevent)$ for the power set of all abstract events.

The set of the abstract events $\absflow(c)$ for a program $c$
% .
% Its type is formally defined 
is computed as follows in Definition~\ref{def:absevent_compute}.
 %
 \begin{defn}[Abstract Event Computation]
 \label{def:absevent_compute}
 $\absflow \in \cdom \to \mathcal{P}( \ldom \times \dcdom^{\top} \times \ldom )$
 \end{defn}
 %
% The \emph{Abstract Execution Trace} for program $c$ is computed as follows.
% \\
 % We now show how to compute the abstract execution trace. 
 We first append a $\eskip$ command with 
% a symbolic label $l_e$, i.e., $\clabel{\eskip}^{l_e}$ at the end of the program $c$, and compute the $\absflow(c) = \absflow'(c')$ for $c'$, where $c' = c;\clabel{\eskip}^{l_e}$ as follows,
the label $\lex$, i.e., $\clabel{\eskip}^{\lex}$ at the end of the program $c$, and construct 
the program $c' = c;\clabel{\eskip}^{\lex}$.
Then, we compute the $\absflow(c) = \absflow'(c')$ for $c'$ as follows,
 %
 {
 \[
 \begin{array}{ll}
 \absflow'(\clabel{\assign{x}{\expr}}{}^l) & = \emptyset \\
 \absflow'(\clabel{\assign{x}{\query(\qexpr)}}{}^l) & = \emptyset \\
 \absflow'(\clabel{\eskip}^{l}) & = \emptyset \\
 \absflow'(\eif \clabel{\bexpr}^{l} \ethen c_t \eelse c_f) & = \absflow'(c_t) \cup \absflow'(c_f)
 \\ & \quad 
 \cup \left\{(l, \absexpr(\bexpr, \top), \absinit(c_t) ) \right\}
 \\ & \quad 
 \cup \left\{ (l, \absexpr(\neg\bexpr, \top), \absinit(c_f)) \right\} \\
 \absflow'(\ewhile \clabel{\bexpr}^{l} \edo (c_w)) & = \absflow'(c_w) \cup \{(l, \absexpr(\bexpr, \top), \absinit(c_w)) \} 
 \\ & \quad 
 \cup \{(l', dc, l)| (l', dc) \in \absfinal(c_w) \} \\
 \absflow'(c_1 ; c_2) & = \absflow'(c_1) \cup \absflow'(c_2) 
 \\ & \quad 
 \cup \{ (l, dc, \absinit(c_2)) | (l, dc) \in \absfinal(c_1) \} \\
 \end{array}
 \]
 }
 Notice $\absflow'(\clabel{\assign{x}{\expr}}^{l})$, $\absflow'(\clabel{\assign{x}{\query(\qexpr)}}^{l})$ and $\absflow'(\clabel{\eskip}^{l})$ are all empty set. 
 
% \highlight{Theorem Guarantees:}

For every event $\event$ with label $l$, if it is in an execution trace $\trace$ of the program $c$, 
 there is an abstract event in the program's abstract execution trace of form $(l, \_, \_)$, formally below
 with the proof in Appendix~\ref{apdx:abscfg_sound}
 \begin{lem}[Soundness of the Abstract Events]
 \label{lem:abscfg_sound}
 For every program $c$ and
 an execution trace $\trace \in \ftdom$ that is generated w.r.t.
 an initial trace $\vtrace_0 \in \ftdom_0(c)$,
 there is an abstract event $\absevent = (l, \_, \_) \in \absflow(c)$ 
 for every event $\event \in \trace$ having the same label $l$, i.e., $\event = (\_, l, \_, \_)$.
 %
 \[
 \begin{array}{l}
 \forall c \in \cdom, \vtrace_0 \in \ftdom_0(c), \trace \in \ftdom , l, l' \in \absV(c), \event = (\_, l, \_, \_) \in \eventset \st
 \\
 \quad
 \config{{c}, \trace_0} \to^{*} \config{\clabel{\eskip}^{l'}, \trace_0 \tracecat \vtrace} 
 \land \event \in \trace 
 \\
 \qquad \implies \exists \absevent = (l, \_, \_) \in (\ldom\times \dcdom^{\top} \times \ldom) \st 
 \absevent \in \absflow(c)
 \end{array}
 \]
 \end{lem}

For every program point $l$, if it is the label of an assignment command in a program $c$,
there is a unique abstract event in the program's abstract events set $\absevent \in \absflow(c)$ of form $(l, \_, \_)$. 
\begin{lem}[Uniqueness of the Abstract Event]
 \label{lem:abscfg_uniquex}
 For every program $c$ and
 an execution trace $\trace \in \ftdom$ that is generated w.r.t.
 an initial trace $\vtrace_0 \in \ftdom_0(c)$,
 there is a unique abstract event $\absevent = (l, \_, \_) \in \absflow(c)$ 
 for every assignment event $\event \in \eventset^{\asn}$ in the
 execution trace having the label $l$, i.e., $\event = (\_, l, \_, \_)$ and $\event \in \trace$.
%
\[
 \begin{array}{l}
 \forall c \in \cdom, \vtrace_0 \in \ftdom_0(c), \trace \in \ftdom , l, l' \in \absV(c), \event = (\_, l, \_) \in \eventset^{\asn} \st
 \\
 \qquad \config{{c}, \trace_0} \to^{*} \config{\clabel{\eskip}^{l'}, \trace_0 \tracecat \vtrace} 
 \land \event \in \trace 
 \\
 \qquad \implies \exists! \absevent = (l, \_, \_) \in (\ldom\times \dcdom^{\top} \times \ldom) \st 
 \absevent \in \absflow(c)
\end{array}
\]
\end{lem}
This lemma is proved in Appendix~\ref{apdx:abscfg_uniquex}.

 \paragraph{Edge Construction}
For a program $c$, the edges on its abstract transition graph are constructed by computing the set of all its abstract events, $\absflow(c)$ as follows,
 \[
 \absE(c) = \{(l_1, dc, l_2) | (l_1, dc, l_2) \in \absflow(c)\}
 \]
\paragraph{Abstract Transition Graph Construction} 
With the vertices $\absV(c)$ and edges $\absE(c)$ ready, we construct the abstract transition graph, formally in
Definition~\ref{def:abs_cfg}.
%
\begin{defn}[Abstract Transition Graph]
\label{def:abs_cfg}
Given a program $c$, 
its \emph{abstract transition graph} $\absG(c) =(\absV(c), \absE(c))$ is computed as follows,
\\
$\absE(c) = \{(l_1, dc, l_2) | (l_1, dc, l_2) \in \absflow(c)\}$,
\\
$\absV(c) = \lvar(c)\cup\{\lex\}$
\end{defn}


To illustrate the construction of the abstraction transition graphs, we show again the running example as below.
%
\input{examples/abscfg_tworound}