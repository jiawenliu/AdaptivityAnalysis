In this section, we formally present the definition of adaptivity for a given program.
As we discussed in Section~\ref{sec:adaptivity-informal}, we first define a dependency relation between program variables,
we then define a semantics-based dependency graph, and finally look at longest walks in this graph. 

\subsection{May-dependency between Variables}
\label{sec:dep}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% The Detail Explanation of Variable May-Dependency and Motivation on How to define it %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
We are interested in defining a notion of dependencies between program variables since assigned variables are a good proxy to study dependencies between queries---we can recover query requests from variables associated with queries. We consider dependencies that can be generated by either data or control flow.
% as follows,
% \begin{enumerate}
For example, in the program 
\[c_1 =[\assign{x}{\query(\chi[2])}]^1 ;[\assign{y}{\query(\chi[3] + x)}]^2\]
the query $\query(\chi[3] + x)$  depends on the query $\query(\chi[2]))$ through a \emph{value dependency} via  $x^1$.
% ), because $\chi[3] + x$ may depend on the data stored in x assigned by the result of $\query(\chi[2]))$. 
% From our perspective, $\query(\chi[1])$ is different from $\query(\chi[2]))$.
\\
% \\
% (2). One query may depend on a previous query if and only if a change of the value returned
%     to the previous query request may also change the appearance of this query quest.
%     This captures the control influence.
Conversely, in the program
\[c_2 = [\assign{x}{\query(\chi[1])}]^1 ; \eif( [x > 2]^2 , [\assign{y}{\query(\chi[2])}]^3, [\eskip]^4 )\] 
the query $\query(\chi[2])$ 
depends on the query $\query(\chi[1])$ via the \emph{control dependency} of the guard of the if command involving the labeled variable $x^1$.

To define dependency between program variables we will consider two events that are generated from the same command, hence they have the same variable name or boolean expression and label, but have either different value or different query expression, captured by the following definition. 

\begin{defn}
\label{def:diff}
Two events $\event_1, \event_2 \in \eventset$ differ in their value, or query value,
denoted as $\diff(\event_1, \event_2)$, if and only if:
{\small
\begin{subequations}
\begin{align}
& \pi_1(\event_1) = \pi_1(\event_2) 
  \land  
  \pi_2(\event_1) = \pi_2(\event_2) \\
& \land  
  \big(
   (\pi_3(\event_1) \neq \pi_3(\event_2)
  \land 
  \pi_{4}(\event_1) = \pi_{4}(\event_2) = \bullet )
  \lor 
  (\pi_4(\event_1) \neq \bullet
  \land 
  \pi_4(\event_2) \neq \bullet
  \land 
  \pi_{4}(\event_1) \neq_q \pi_{4}(\event_2)) 
  \big)
\end{align}
\label{eq:diff}
\end{subequations}
}
where $\qexpr_1 =_{q} \qexpr_2$ denotes the semantics equivalence between query values\footnote{The formal definition is in the supplementary material},
and $\pi_i$ projects the $i$-th element from the quadruple of an event.
\end{defn}
{
$\pi_1(\event_1) = \pi_1(\event_2) 
  \land  
  \pi_2(\event_1) = \pi_2(\event_2)$ at Eq.\ref{eq:diff}(a)
requires that $\event_1$ and $\event_2$ have the same variable name and label. 
This guarantees that $\event_1$ and $\event_2$ are generated from the same labeled command.
In Eq.\ref{eq:diff}(b),
two kinds of comparisons between the third and fourth element are for the non-query assignment and query request separately.
For events generated from the non-query assignments (via checking
$\pi_{4}(\event_1) =_q \pi_{4}(\event_2) = \bullet$), we only compare their assigned values through $\pi_3(\event_1) \neq \pi_3(\event_2)$.
But for these from query requests (via checking
$\pi_{4}(\event_1) \neq \bullet \land \pi_{4}(\event_2) \neq \bullet$),
we are comparing their query expressions by $\pi_{4}(\event_1) \neq_q \pi_{4}(\event_2)$ rather than the assigned value computed from the unknown database server.
This matches the intuitive data dependency between queries, where one query is influenced by others as long as the query request is changed.
}

{Below is the \emph{event may-dependency} between events based on observing their differences via $\diff$.}
\begin{defn}[Event May-Dependency]
\label{def:event_dep}
An event $\event_2$ is in the \emph{event may-dependency} relation with an assignment event $\event_1 \in \eventset^{\asn}$ in a program ${c}$  with a hidden database $D$ and a witness trace $\trace \in \mathcal{T}$,
$\eventdep(\event_1, \event_2, [\event_1 ] \tracecat \trace \tracecat [\event_2], c, D)$ if and only if
\begin{subequations}
\begin{align}
&  
\exists \trace_0, \trace_1, \trace' \in \mathcal{T},\event_1' \in \eventset^{\asn}, {c}_1, {c}_2  \in \cdom  \st \diff(\event_1, \event_1') \land \\
& 
\quad (\exists  \event_2' \in \eventset \st 
\left(
\begin{array}{ll}   
  & \config{{c}, \trace_0} \rightarrow^{*} 
  \config{{c}_1, \trace_1 \tracecat [\event_1]}  \rightarrow^{*} 
  \config{{c}_2,  \trace_1 \tracecat [\event_1] \tracecat \trace \tracecat [\event_2] } 
   \\ 
   \bigwedge &
   \config{{c}_1, \trace_1 \tracecat [\event_1']}  \rightarrow^{*}
    \config{{c}_2,  \trace_1 \tracecat[ \event_1'] \tracecat \trace' \tracecat [\event_2'] } 
  \\
  \bigwedge & 
  \diff(\event_2,\event_2' ) \land 
  \vcounter(\trace, \pi_2(\event_2))
  = 
  \vcounter(\trace', \pi_2(\event_2'))\\
  \end{array}
  \right)\\ 
  & 
  \quad
  \lor 
  \left(
  \begin{array}{l} 
  \exists \trace_3, \trace_3'  \in \mathcal{T}, \event_b \in \eventset^{\test} \st 
  \\
   \quad \config{{c}, \trace_0} \rightarrow^{*} \config{{c}_1, \trace_1 \tracecat [\event_1]}  \rightarrow^{*}
   \config{c_2,  \trace_1 \tracecat [\event_1] \tracecat
   \trace \tracecat [\event_b] \tracecat  \trace_3} 
\\ \quad \land
\config{{c}_1, \trace_1 \tracecat [\event_1']}  \rightarrow^{*} 
\config{c_2,  \trace_1 \tracecat [\event_1'] \tracecat \trace' \tracecat [(\neg \event_b)] \tracecat \trace_3'} 
\\
\quad \land \tlabel({\trace_3}) \cap \tlabel({\trace_3'})
= \emptyset
\land \vcounter(\trace', \pi_2(\event_b)) = \vcounter(\trace, \pi_2(\event_b)) 
    \land \event_2 \in \trace_3
    \land \event_2 \not\in \trace_3'
  \end{array}
  \right)
  ),
\end{align}
\label{eq:eventdep}
\end{subequations}
where $\tlabel(\trace) \subseteq \ldom$ is the set of the labels in all the events from trace $\trace$ and $\event_2 \in \trace_3$ or $\event_2 \notin \trace_3$ denotes that $\event_2$ belongs to $\trace_3$ or not.
\end{defn}
The first line in Equation~\ref{eq:eventdep}(a) requires that $\event_1$ comes from an assignment command.
Then, $\diff(\event_1, \event_1')$ guarantees that value assigned to the same variable is different in $\event_1'$.

The following two parts in Equation~\ref{eq:eventdep}(b) and (c) capture the value dependency and control dependency respectively. 
As in the literature on non-interference, and following~\cite{Cousot19a}, we formulate these dependencies as relational properties, i.e. in terms of two different traces of execution. 
I force these two traces to differ by using the event $\event_1$ in one and $\event_1'$ in the other. 
Both Equation~\ref{eq:eventdep}(b) and (c) execute the program two times w.r.t. the different values in $\event_1$ (as line:1 in Equation~\ref{eq:eventdep}(b) and line:2 in Equation~\ref{eq:eventdep}(c))
and $\event_1'$ (as line:2 in Equation~\ref{eq:eventdep}(b) and line:3 in Equation~\ref{eq:eventdep}(c)).
However, the definition checks the difference in the newly generated traces in different ways in line:3 of Equation~\ref{eq:eventdep}(b) and line:4 of Equation~\ref{eq:eventdep}(c) to capture the value dependency and control dependency respectively.
This idea is similar to the semantics dependency definition from~\cite{Cousot19a}.

For the value dependency, we check whether the change of $\event_1$ also creates a change in the value of $\event_2$ or not.
In Equation~\ref{eq:eventdep}(b) line:2, if the newly generated trace, $\trace' ++ [\event_2']$ still contains $\event_2$ as $\event_2'$, I check the difference on their value in line:3.
We additionally check whether the two events appear the same times in the two traces.
This is to make sure that they are in the same iteration if the two events are generated from the command of a loop body.
If they only differ in their assigned values, i.e., $\diff(\event_2, \event_2')$ and
they are in the same loop iteration (via $\vcounter(\trace, \pi_2(\event_2)) = \vcounter(\trace', \pi_2(\event_2'))$),
then we define there is a value \emph{may-dependency} relation between $\event_1$ and $\event_2$.

The Equation~\ref{eq:eventdep}(c) captures the control dependency through observing whether $\event_2$ is disappeared from the second execution traces, $\trace' \tracecat [(\neg \event_b)] \tracecat \trace_3'$ in line:3.
$\event_2 \in \trace_3 \land \event_2 \not\in \trace_3'$ in Equation~\ref{eq:eventdep}(c) line:4 specifies this disappearance.
$\vcounter(\trace', \pi_2(\event_b)) = \vcounter(\trace, \pi_2(\event_b))$ is used to make sure the two executions are
in the same loop iteration as well.
Different from Equation~\ref{eq:eventdep}(b) line:3,
we want to find a testing event, $\event_b$ in the execution trace because checking only $\event_2$'s occurrence and the
$\vcounter(\trace, \pi_2(\event_2)) = \vcounter(\trace', \pi_2(\event_2'))$
causes false positives
when there is no influence through control dependency. 
For example in the following program
\[
 \clabel{\assign{i}{3}}^{0}; \clabel{\assign{x}{\query(\chi[0])}}^1 \ewhile \clabel{i \geq 0}^{2} \edo ( \clabel{\assign{y}{\query(\chi[i])}}^3; \clabel{\assign{i}{ i - 1}}^{4})
\]
we execute only two iterations of the while loop as follows,
\[
 \begin{array}{l}
 \config{
 \clabel{\assign{i}{3}}^{0}; \clabel{\assign{x}{\query(\chi[0])}}^1; \ewhile \clabel{i \geq 0}^{2} \edo ( \clabel{\assign{y}{\query(\chi[i])}}^3; \clabel{\assign{i}{ i - 1}}^{4}), \trace_0} \\
 \rightarrow^{*} \config{\ewhile \clabel{i \geq 0}^{2} \edo ( \clabel{\assign{y}{\query(\chi[i])}}^3; \clabel{\assign{i}{ i - 1}}^{4}), \trace_1 \tracecat [(x, 1, v, \chi[0])]} \\
 \rightarrow^{*}
 \config{\ewhile \clabel{i \geq 0}^{2} \edo ( \clabel{\assign{y}{\query(\chi[i])}}^3; \clabel{\assign{i}{ i - 1}}^{4}), 
 \\ \qquad \quad \trace_1 \tracecat [(x, 1, v, \chi[0]), (i \geq 0, 2, \etrue, \bullet), (y, 3, v_0, \chi[0]), (i, 4, 1, \bullet), (i \geq 0, 2, \etrue, \bullet)]
 \\ \qquad \quad \tracecat [ (y, 3, v_1, \chi[1]) ]}.
 \end{array} 
\]
To find the dependency relation between $(x, 1, v, \chi[0])$ and $(y, 3, v_1, \chi[1])$, we modify the first event and then execute only the first iteration of the while loop as follows,
\[
 \begin{array}{l}
 \config{\ewhile \clabel{i \geq 0}^{2} \edo ( \clabel{\assign{y}{\query(\chi[i])}}^3; \clabel{\assign{i}{ i - 1}}^{4}), \trace_1 \tracecat [(x, 1, v', \chi[0])]} \\
 \rightarrow^{*}
 \config{\ewhile \clabel{i \geq 0}^{2} \edo ( \clabel{\assign{y}{\query(\chi[i])}}^3; \clabel{\assign{i}{ i - 1}}^{4}),
 \\ \qquad \quad \trace_1 \tracecat [(x, 1, v', \chi[0]), (i \geq 0, 2, \etrue, \bullet), (y, 3, v_1, \chi[0])] 
  \tracecat[]}.
 \end{array} 
 \]
Without looking into a testing event, we can always say $(y, 3, v_1, \chi[1]) \not\in []$ and they have event may-dependency relation.
However, there does not exist any dependency relation between $(x, 1, v, \chi[0])$ and $(y, 3, v_1, \chi[1])$.
For this reason, we use the presence of a test event whose value is affected by the change in $\event_1$
to guarantee that the influence goes through a control flow in the first step.
Because the control dependency can only be passed through the guard of if or while command, this guard must be evaluated into two different values ($\event_b$ and $\neg \event_b$) in the two executions.


We can now extend the dependency relation to variables by considering all the assignment events generated during the programâ€™s execution. 

\begin{defn}[Variable May-Dependency]
  \label{def:var_dep}
A variable ${x}_2^{l_2} \in \lvar(c)$  \emph{may-dependent} on the 
  variable ${x}_1^{l_1} \in \lvar(c)$ in a program ${c}$,
  %
  $\vardep({x}_1^{l_1}, {x}_2^{l_2}, {c})$, if and only if
\begin{center}
$
{\small   \begin{array}{l}
\exists \event_1, \event_2 \in \eventset^{\asn}, \trace \in \mathcal{T} \st
\pi_{1}{(\event_1)}^{\pi_{2}{(\event_1)}} = {x}_1^{l_1}
\land
\pi_{1}{(\event_2)}^{\pi_{2}{(\event_2)}} = {x}_2^{l_2}% \\ \quad 
\land 
\eventdep(\event_1, \event_2, \trace, c) 
  \end{array}
}%
$
\end{center}
  \end{defn}
{From the definition, a labeled variable $x_2^{l_2}$ may depend on another labeled variable $x_1^{l_1}$ in a program $c$ under the hidden database $D$, 
as long as there exist two assignment events $\event_1$ (for $x_1^{l_1}$) and $\event_2$ for $x_2^{l_2}$
satisfy the \emph{event may-dependency} relation under a witness trace $\trace$.  
Notice that in the definition above we can also have that the two variables are the same,
this allow us to capture self-dependencies
}

\subsection{Weight of Labeled Variables}
\label{sec:dep}
Since the \emph{adaptivity} is also related to the quantity of
the \emph{variable may-dependency} relation
we define 
the weight of
every labeled variable in a program as follows.

\begin{defn}[Weight of Labeled Variable]
 \label{def:lvar_weight} For ta labeled variable $x^l$ in a program $c$,
$f({c}, x^l): \ftdom_0(c) \to (\mathbb{N})$ is a \emph{weight function} of this labeled
variable $x^l$ if and only if,
\[
 \begin{array}{l}
 \forall \trace_0 \in \ftdom_0(c), \trace' \in \ftdom, l' \st 
 \\ \qquad 
 \config{{c}, \trace_0} \to^{*} 
 \config{\clabel{\eskip}^{l'}, \trace_0 \tracecat \trace'} 
 \land w(\trace_0) = \vcounter(\trace', l) \}. 
 \end{array}
 \]
\end{defn}
% A weight function $w \in \traceW(c)$ is a function that 
Specifically, for every initial trace $\trace_0 \in \ftdom_0(c)$,
the weight for a labeled variable $x^l$ under this initial trace, $w(\trace_0)$
gives the number of times that the command with the label $l$ is evaluated.
% the corresponding vertex $x^l$ is visited. 
% For each vertex $x^l$, 
In other words, it tracks for each vertex $x^l$ its visiting times 
% (i.e., the evaluation times of the command with the label $l$)
 when the program $c$ is executing under the initial trace $\trace_0$.
 The weight functions are total and with range $\mathbb{N}$. 
 As discussed above in Definition~\ref{def:adaptfun-wfprog}, since a well-formed program $c$ is always terminating, we have
 for any initial trace $\trace_0 \in \ftdom_0(c)$ a terminating execution 
 $\config{{c}, \trace_0} \to^{*} \config{\clabel{\eskip}^{l'}, \trace_0\tracecat\trace'} $
 which produce a finite execution trace $\trace \in \ftdom$.
The visiting times are computed by the counter operator $\vcounter(\trace', l)$
by counting the occurrence of the label $l$ in $\trace'$.

If the program is not a well-formed program by Definition~\ref{def:adaptfun-wfprog}, the program does not terminate.
As a result, every labeled variable of this program does not have a weight function.

\textbf{Example.} 
As an instance, in Figure~\ref{fig:overview-example}(b), the weight of the labeled variable $x^3$ is 
$\lambda \trace_0 \st \env(\trace_0) k$, i.e.
a function of type $\ftdom_0(\kw{twoRound(k)}) \to \mathbb{N}$.
$\env(\trace_0) k$ fetch the initial value assigned to variable $k$ from the initial trace $\trace_0$.
This function means when 
% given input $\trace_0$, 
we execute the $\kw{twoRound(k)}$ program under input $\trace_0$, 
$\config{\kw{twoRound(k)}, \trace_0} \to^{*} \config{\clabel{\eskip}^{l'}, \trace_0\tracecat\trace'} $,
we have an execution trace $\trace'$.
Then $w_k(\trace_0)$ outputs the occurrences of the label $3$ in $\trace'$, which is 
the same as the iteration numbers of the loop,
% always
i.e., the value of $k$ in the initial trace, $\env(\trace_0) k$.


\subsection{Semantics-based Dependency Graph}
\label{sec:design_choice}
In order to track the adaptivity with respect to the query,
we also define the set of query variables for a program $c$, $\qvar(c)$ as below.
It is the set of query-associated variables (in query request assignments) that contains all labeled variables in $c$'s query requests, and $\qvar(c) \subseteq \lvar(c)$.
% as below.
% formally in Definition~\ref{def:qvar}.
\begin{defn}[Query Variables a program $c$, $\qvar(c)$] 
 \label{def:qvar}
Given a program $c$, its query variables 
$\qvar(c)$ is the set of variables set to the result of a query in the program.
It is defined as follows:
{
\[
 \qvar(c) \triangleq
 \left\{
 \begin{array}{ll}
 \{\} 
 & {c} = \clabel{\assign x \expr}^{l} 
 \\
 \{{x}^l\} 
 & {c} = \clabel{\assign x \query(\qexpr)}^{l} 
 \\
 \qvar(c_1) \cup \qvar(c_2) 
 & {c} = {c_1};{c_2}
 \\
 \qvar(c_1) \cup \qvar(c_2) 
 & {c} =\eif(\clabel{\bexpr}^{l}, c_1, c_2) 
 \\
 \qvar(c_w)
 & {c} = \ewhile \clabel{\bexpr}^{l} \edo (c_w)
\end{array}
\right.
\]
}
\end{defn}

Then, we use the \emph{variable may-dependency} relation, the query variables and the \emph{weight function}
of each labeled variable to 
define the semantics-based dependency graph for a well-formed program.

\begin{defn}[Semantics-based Dependency Graph]
\label{def:trace_graph}
For a well-formed program ${c} \in \cdom$,
its \emph{semantics-based dependency graph} has four components as follows,
\[
 \traceG({c}) \triangleq (\traceV({c}), \traceE({c}), \traceW({c}), \traceF({c})).
\]
Each component is defined as below,
{\small
\[
\begin{array}{lll}
 \text{Vertices} &
 \traceV({c}) & := \left\{ 
 x^l
 ~ \middle\vert ~ x^l \in \lvar(c)
 \right\}
 \\
 \text{Edges} &
 \traceE({c}) & := 
 \left\{ 
 (x^i, y^j) 
 ~ \middle\vert ~
 x^i, y^j \in \lvar(c) \land \vardep(x^i, y^j, c) 
 \right\}
 \\
 \text{Weights} &
 \traceW({c}) & := 
 \{ 
 (x^l, w) 
 ~ \vert ~ 
 w : \ftdom_0(c) \to \mathbb{N}
 \land
 x^l \in \lvar(c) \land
 \\ & & \qquad 
 \forall \trace_0 \in \ftdom_0(c), \trace' \in \ftdom, l' \st 
 \\ & & \qquad 
 \config{{c}, \trace_0} \to^{*} 
 \config{\clabel{\eskip}^{l'}, \trace_0 \tracecat \trace'} 
 \land w(\trace_0) = \vcounter(\trace', l) \} 
 \\
 \text{Query} &
 \traceF({c}) & := 
 \big\{(x^l, n) 
 ~ \vert ~ x^l \in \lvar(c) 
 \\ \text{Annotations} & & \qquad
 \land n = 1 \Leftrightarrow x^l \in \qvar(c) \land n = 0 \Leftrightarrow x^l \notin \qvar(c)
 \big\},
\end{array},
\]
}
A semantics-based dependency graph $\traceG({c})= (\traceV({c}), \traceE({c}), \traceW({c}), \traceF({c}))$ 
is \emph{well-formed} if and only if $ \{x^l \ |\ (x^l,w)\in \traceW({c})\} = \traceV({c}) $.
\end{defn}
The only situation where $ \{x^l \ |\ (x^l,w)\in \traceW({c})\} \neq \traceV({c}) $ is that the program
has non-terminating execution.
In this situation, by Definition~\ref{def:lvar_weight}  we know every labeled variable of this program does not have a weight function.
As a result, the weight set is empty.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% The Explanation of Dependency Graph %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Below we discuss in detail the four components of the semantics-based dependency graph for a program $c$.
\begin{enumerate}
 \item The vertices set, $\traceV({c})$ contains all the labeled variables of program $c$,
 which are statically collected.
 \item $\traceF(c)$ contains pairs of a labeled variable and a query annotation (either $1$ or $0$).
  In each pair, the annotation indicates whether $x^l$ comes from a query request ($1$) or not ($0$) by checking if the labeled variable $x^l$ of the vertex is in $\qvar(c)$.
 \item Edges in $\traceE(c)$ are all directed.
 They are built from the \emph{variable may-dependency} relation, i.e. $\vardep(x^i, y^j, c)$ in Definition~\ref{def:var_dep} between two labeled variables.
 There is an edge from $y^j$ to $x^i$ if and only if they are in the \emph{variable may-dependency} relation, $\vardep(x^i, y^j, c)$. 
 This is the key definition in order to formalize the intuitive \emph{adaptivity}. We use this to ingredient the dependency relation between queries into this graph.
 \item 
The weight function in $\traceW(c)$ for each vertex (also a labeled variable), $w : \ftdom_0(c) \to \mathbb{N}$
maps from an initial trace $\trace_0 \in \ftdom_0(c)$ to a natural number as defined in Definition~\ref{def:lvar_weight}.
This is also an important component in order to capture the dependency quantity between queries.
\end{enumerate}

The main novelty of the semantics-based dependency graph is the combination of the quantitative and reachability sub-properties. 
It can tell both the dependency between queries via the directed edge, and the times they depend on each other via the weight.
Then we can utilize them, together with the query annotation to precisely define the \emph{adaptivity} for a program.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Trace-Based Adaptivity%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Adaptivity}
We can now define the adaptivity of a program formally. This notion is formulated in terms of an initial trace, specifying the value of the input variables, as the walk on the graph $\traceG({c})$, which has the largest number of query requests.


\begin{defn}[Walk]
\label{def:finitewalk}
Given a well-formed program $c$ with its semantics-based dependency graph $\traceG({c}) = (\traceV, \traceE, \traceW, \traceF)$ of a program $c$, a \emph{walk} $k$ is a function that maps an initial trace $\trace_0$ to a sequence of vertices $(v_1, \ldots, v_{n})$
for which there is a sequence of edges $(e_1 \ldots e_{n - 1})$  satisfying
\begin{itemize}
\item $e_i = (v_{i},v_{i + 1}) \in \traceE$ for every $1 \leq i < n$,
\item and $v_i$ appears in $(v_1, \ldots, v_{n})$ at most $w_i(\trace_0)$ times for every $v_i \in \traceV$ and $(v_i, w_i) \in \traceW$.  
\end{itemize}
$k(\trace_0) = (v_1, \ldots, v_{n})$
%  and the length of $k(\trace_0)$ is the number of vertices in its vertex sequence, i.e., $|k(\trace_0)| = n$.}
% The length of $k(\trace_0)$ is the number of vertices in its vertex sequence, i.e., $\len(k)(\trace_0) = n$.
and we denote by $\walks(\traceG(c))$
the set of all the walks $k$ in $\traceG(c)$.
\end{defn} 
Because for the adaptivity
% is intuitively 
we are interested in the dependency between queries,
we calculate a special ``length'' of a walk, the \emph{query length},  by counting only the vertices
corresponding to queries.
\begin{defn}[Query Length]
\label{def:qlen}
Given 
the semantics-based dependency graph $\traceG({c})$ of a well-formed program $c$,
 and a \emph{walk} 
 $k \in \walks(\traceG(c))$ 
%  with vertex sequence $(v_1, \ldots, v_{n})$, 
the \emph{query length} of $k$ is a function $\qlen(k):\ftdom_0(c) \to \mathbb{N}$ that 
% given an initial trace $\trace_0$ 
gives
the number of vertices that correspond to query variables in the vertex sequence of $k(\trace_0)$
for any initial trace $\trace_0 \in \ftdom_0(c)$ as follows, 
\begin{center}
   $
  \qlen(k) = \lambda \trace_0 \st |\big( v \mid v \in (v_1, \ldots, v_{n}) \land (v, 1) \in \traceF(c) 
%   \land
%   k \in \walks(\traceG(c)) 
  \land k(\trace_0) = (v_1, \ldots, v_{n}) \big)|,
$
\end{center}
where the notation $| (\ldots) |$ gives the number of vertices in a sequence.
\end{defn}
Then we define for a well-formed program its adaptivity as a function as below.
\begin{defn}
    [Adaptivity of a Program]
    \label{def:trace_adapt}
    Given a well-formed program ${c}$, 
    its adaptivity $A(c)$ is a function 
    $A(c) : \ftdom_0(c)\to \mathbb{N}$ such that for an
    initial trace $\trace_0 \in \ftdom_0(c)$, 
\begin{center}
$
    A(c) = \lambda \trace_0 \st \max \big 
    \{ \qlen(k)(\trace_0) \mid k \in \walks(\traceG(c)) \big \} 
$
\end{center}
\end{defn}
As discussed above, programs that has non-terminating behaviors do not have the intuitive adaptivity. So we define the adaptivity only for the well-formed program.

\subsection{The definition limitation}
\input{examples/multipleRoundsSingle}