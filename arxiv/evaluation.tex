\subsection{Implementation Results}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Previous Version for Reference %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% We implemented $\THESYSTEM$ as a tool which takes a labeled command as input  
% and outputs two upper bounds on the program adaptivity and the number of query requests respectively.
% This implementation consists of an 
% abstract control flow graph generation,
% edge estimation (as presented in Section~\ref{sec:alg_edgegen}), and weight estimation (as presented in Section~\ref{sec:alg_weightgen}) in Ocaml, 
% and the adaptivity computation algorithm shown in Section~\ref{sec:alg_adaptcompute} in Python.
% The OCaml program takes the labeled command as input and outputs the program-based dependency graph and
% the abstract transition graph,
% feeds into the python program and the python program provides the adaptivity upper bound and the query number as the final output.

% We evaluated this implementation on $17$ example programs with the evaluation results shown in Table~\ref{tb:adapt-imp}.
% In this table,
% the first column is the name of each program.
% For each program $c$, the second column is its intuitive adaptivity rounds,
% the third column is the adaptivity $A(c)(\trace_0)$ w.r.t the input initial trace $\trace_0 \in \mathcal{T}_0(c)$ as definition~\ref{def:trace_adapt}.
% In all these examples, the input variable $k$ specifies the loop iteration numbers.
% Since $A(c)(\trace_0)$ by definition~\ref{def:trace_adapt} will count the execution times of
% query request command in the loop, which is indeed same as  the loop iteration numbers,
% we use $\env(\trace_0) k$ in the third column represent this number, which computes the $k$'s initial value from input initial trace $\trace_0$.
% The fifth column is the output of the $\THESYSTEM$ implementation, which consists of two expressions.
% The first one is the upper bound for adaptivity and the second one is the 
% upper bound for the total number of query requests in the program. And the last column is the performance evaluation w.r.t. the program size.

% For the forth program $\kw{multiRoundsO(k)}$, $\THESYSTEM$ outputs an over-approximated upper bound $1 + 2*k$ for the $A(c)$, which is consistent with our expectation as discussed in Example~\ref{ex:multiRoundsO}. 
% The fifth program is the evaluation results for the example in Example~\ref{ex:multiRoundsS}, where $\THESYSTEM$ outputs the tight bound for $A(c)$ but $A(c)$ is a loose definition of the program's actual adaptivity rounds.
% %
% The first two programs $\kw{twoRounds(k)}$, $ \kw{multiRounds(k)}$ are the same as Figure~\ref{fig:overview-example}(a) and Figure~\ref{fig:multipleRounds}(a).
% The other programs in the table from  $\kw{seq()}$ to $ \kw{nestWhileMPRV(k)}$ are 
% designed for testing the programs under different possible situations.
% They contain control dependency, data value dependency,
% the nested while, dependency through multiple variables, dependency across nested loops. 
% Overall for these examples, our system gives both the accurate adaptivity definition and estimated
% adaptivity upper bound through our formalization and analysis framework $\THESYSTEM$.
% The complete programs are defined below from Example~\ref{ex:twoRoundsComplete} to Example~\ref{ex:nestedWhileMPRV},
% and the implementations are in GitHub.
% \begin {table}[H]
%     \caption{Experimental results of {\THESYSTEM} implementation}
%         \label{tb:adapt-imp}
%         \begin{center}
%         \centering
% {\footnotesize
%         \begin{tabular}{ r | c | c | c | c | c | c }
%         \multirow{2}{*}{Program $c$} & 
%         \multirow{2}{*}{\emph{adaptivity}} 
%          & \multirow{2}{*}{$A(c) (\trace_0)$} 
%          & \multicolumn{2}{c|}{$\THESYSTEM$}
%          & \multicolumn{2}{c}{performance} \\ 
%          \cline{4-7}
%          & & & $\progA(c)$ & $\query$ \# & line of code & time (second) \\
%          \hline \hline
%          $  \kw{twoRounds(k)}$ & $2$ & $2$ & $2$ & $k$ & 8 & 0.014 \\
%          $  \kw{multipleRounds(k)}$ & $k$ & $ \env(\trace_0) k $ & $k$ & $k$  &  10 & 0.017 \\
%          $  \kw{lRGD(k, r)}$ & $k$ & $\env(\trace_0) k$ & $k$ & $2 * \env(\trace_0) k$  &  10 & 0.017  \\
%          $  \kw{multiRoundsO(k)}$ & $1 + k$ & $1 + (\env(\trace_0) k) $  & $1 +2 * k$ & $1 + 2*k$  &  10 & 0.019  \\
%          $  \kw{multiRoundsS(k)}$    & $2$ & $2 + (\env(\trace_0) k) $ & $2 + k$ & $2 + k$  &  9 & 0.017  \\
%          $  \kw{seq()}$ & $4$ & $4$ & $4$ & $4$ & 4 & 0.011 \\ 
%          $  \kw{seqRV()}$ & $4$ & $4$ & $4$ & $4$ & 4 & 0.011\\  
%          $  \kw{ifVD()}$ & $3$ & $3$ & $3$ & $3$ & 5 & 0.012 \\
%          $  \kw{ifCD()}$ & $3$ & $3$ & $3$ & $3$  & 5 & 0.009   \\
%          $  \kw{whileNested(k)}$ & $1+k$ & $1+ (\env(\trace_0) k)$ & $1+k$  &  $1+k$ & 7 & 0.015 \\
%          $  \kw{whileM(k)}$ & $1 + k$ & $1 +2 * \lfloor \frac{\env(\trace_0) k}{2} \rfloor$ & $1 +2 * \lfloor \frac{k}{2} \rfloor$ & $1 + 2 * k$  &  9 & 0.0139  \\
%          $  \kw{whileRV(k)}$ & $1 + 2*k$ & $1 + 2*(\env(\trace_0) k)$ & $1 + 2*k$ & $2 + 3 * k$  &  9 & 0.014  \\
%          $  \kw{whileVCD(k)}$ & $1 + 2*k$ & $1 + 2*(\env(\trace_0) k)$ & $1 + 2 * k$ & $2 + 2 * k$  &  6 & 0.007  \\
%          $  \kw{whileMPVCD(k)}$ & $2 + k$ & $2 + (\env(\trace_0) k)$  & $2 + k$ & $1 + 2 * k$   &   9 & 0.013 \\
%          $  \kw{nestWhileVD(k)}$ & $2 + k^2$ & $2 + (\env(\trace_0) k)^2$  & $2 + k^2$ & $1 + k + k^2$   &  10 & 0.022  \\
%          $  \kw{nestWhileRV(k)}$ & $1 + 2*k$ & $1 + 2*(\env(\trace_0) k)$ & $1 + 2*k$ &  $1 + k + k^2$   &  10 & 0.019  \\
%          $  \kw{nestWhileMR(k)}$ & $1 + k + k^2$ & $1 + (\env(\trace_0) k) + (\env(\trace_0) k)^2$  & $1 + k + k^2$ &  $2 + k + k^2$  & 10 & 0.039  \\
%          $  \kw{nestWhileMPRV(k)}$ & $1 + k + k^2$ & $1 + (\env(\trace_0) k) + (\env(\trace_0) k)^2$  & $1 + k + k^2$ &  $2 + k + k^2$  &  10 & 0.148  \\
%          $  \kw{mRComplete(k)}$ & $k$ & $ \env(\trace_0) k $ & $k$ & $k$   &  30 & 408.998 \\
%          $  \kw{mRComposed(k)}$ & $k$ & $ \env(\trace_0) k $ & $k$ & $k$   &  50 & 22539.638\\
%          $  \kw{tRComposed(k)}$ & $k$ & $ \env(\trace_0) k $ & $k$ & $k$  &  49 & * \\
%          $  \kw{seqComposed(k)}$ & $k$ & $ \env(\trace_0) k $ & $k$ & $k$  &  502 & * \\
%          $  \kw{jumboS(k)}$ & $k$ & $ \env(\trace_0) k $ & $k$ & $k$  &  70 & * \\
%          $  \kw{jumbo(k)}$ & $k$ & $ \env(\trace_0) k $ & $k$ & $k$  &  521 & * \\
%          $  \kw{big(k)}$ & $k$ & $ \env(\trace_0) k $ & $k$ & $k$  &  214 & *
%         \end{tabular}
% }        
% \end{center}
% \end{table}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Previous Version Above %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\jl{
We implemented $\THESYSTEM$ as a tool which takes a labeled command as input  
and outputs two upper bounds on the program adaptivity and the number of query requests respectively.
This implementation consists of an 
abstract control flow graph generation,
edge estimation (as presented in Section~\ref{sec:alg_edgegen}), and weight estimation (as presented in Section~\ref{sec:alg_weightgen}) in Ocaml, 
and the adaptivity computation algorithm shown in Section~\ref{sec:alg_adaptcompute} in Python.
The OCaml program takes the labeled command as input and outputs the program-based dependency graph and
the abstract transition graph,
feeds into the python program and the python program provides the adaptivity upper bound and the query number as the final output.
}

We evaluated this implementation on $23$ example programs with the evaluation results shown in Table~\ref{tb:adapt-imp}.
In this table,
the first column is the name of each program.
For each program $c$, the second column is its intuitive adaptivity rounds,
% the third column is the adaptivity $A(c)(\trace_0)$ w.r.t the input initial trace $\trace_0 \in \mathcal{T}_0(c)$ as definition~\ref{def:trace_adapt}.
% In all these examples, the input variable $k$ specifies the loop iteration numbers.
% Since $A(c)(\trace_0)$ by definition~\ref{def:trace_adapt} will count the execution times of
% query request command in the loop, which is indeed same as  the loop iteration numbers,
% we use $\env(\trace_0) k$ in the third column represent this number, which computes the $k$'s initial value from input initial trace $\trace_0$.
the third column is the output of the $\THESYSTEM$ implementation, which consists of two expressions.
The first one is the upper bound for adaptivity and the second one is the 
upper bound for the total number of query requests in the program. And the last column is the performance evaluation w.r.t. the program size.

\jl{
The last column is the performance evaluation.
The time contains three parts. The first part is the running time of the Ocaml code, which parses the program and generates the $\progG(c)$.
The second and third parts are the running times of the reachability bound analysis algorithm
and the adaptivity computation algorithm, $\pathsearch(c)$.
}

    The first $5$ programs are adapted from real world data analysis algorithms.
    The first two programs $\kw{twoRounds(k)}$, $ \kw{multiRounds(k)}$ are the same as Figure~\ref{fig:overview-example}(a) and Figure~\ref{fig:multipleRounds}(a).
    $\THESYSTEM$ computes tight adaptivity bound for the first 3.
For the forth program $\kw{multiRoundsO(k)}$, $\THESYSTEM$ outputs an over-approximated upper bound $1 + 2*k$ for the $A(c)$, which is consistent with our expectation as discussed in Example~\ref{ex:multiRoundsO}. 
The fifth program is the evaluation results for the example in Example~\ref{ex:multiRoundsS}, where $\THESYSTEM$ outputs the tight bound for $A(c)$ but $A(c)$ is a loose definition of the program's actual adaptivity rounds.
%

The programs from Tab.~\ref{tb:adapt-imp} line:6-17 all have small size but complex structures, to test the programs under different situations including
data, control dependency,
the multiple paths nested loop with related counters, etc.
Both implementations compute the tight bound for examples in line:6-14
and over-approximate the adaptivities for $15^{th}$ and $16^{th}$ due to path-insensitivity.
For the $17^{th}$ one, implementation I gives tight bound bound while II gives loose bound, so we keep both implementations.

The last six programs are composed of some programs above in order to test the performance limitation when the input program is large. 
From the evaluation results, the performance bottleneck is the reachability bound analysis algorithm.
By implementing the bound analysis algorithm in Section~\ref{sec:alg_weightgen} (adapted from \cite{sinn2017complexity}), we are unable to evaluate the $\kw{Jumbo}$ in a reasonable time period.
Alternatively, we implement another light reachability bound analysis algorithm and compute the \emph{adaptivity} for
$\kw{jumboS}, \kw{jumbo}$ and $\kw{big}$ effectively.

Overall for these examples, our system gives both the accurate adaptivity definition and estimated
adaptivity upper bound through our formalization and analysis framework $\THESYSTEM$.
The complete programs are defined below from Example~\ref{ex:twoRoundsComplete} to Example~\ref{ex:nestedWhileMPRV} in the Appendix~\ref{apdx:evaluated_examples}.

\input{eval-table}

 \subsection{More Discussions on The Evaluated Examples}  
 \subsubsection{The Complete Two Rounds Adaptive Data Analysis Algorithm, $\kw{tRComplete}$} 
 \input{examples/twoRoundsComplete}
 %
 \subsubsection{The Complete Multiple Rounds Adaptive Data Analysis Algorithm, $\kw{mRComplete}$} 
 \input{examples/multipleRoundsComplete}
 %
% \subsubsection{$\kw{lRGD}$}
% \input{examples/linearRegressionGD}
 %          
% \subsubsection{The Programs for Examples from line:6 - 15 in Table.\ref{tb:adapt-imp}}
% \input{examples/evaluated_examples-prog}

% \subsubsection{The Programs for Examples from line:16 - 20 in Table.\ref{tb:adapt-imp}}
% \input{examples/evaluated_examples-code}
