
\[\begin{array}{llll}
\mbox{Expr.} & \expr & ::= & x ~|~ \expr_1 \eapp \expr_2 
 ~|~ \lambda x. \expr 
    \\
             & & &  \etrue ~|~ \efalse ~|~
  \eif  \expr \ethen \expr_2 \eelse \expr_3 ~|~
\econst ~|~ \eop(\expr)  \\
\mbox{Environment} & \env & ::= & x_1 \mapsto (\valr_1, \adapt_1), \ldots, x_n \mapsto (\valr_n,\adapt_n)
\end{array}\]

\[
\begin{array}{llll}
  \mbox{Index Term} & \idx, \nnatA & ::= &     i ~|~ n \\
 %                                  - \idx_2 ~|~ \smax{\idx_1}{\idx_2}\\
%                                  \mbox{Sort} & S & ::= & \nat \\
  \mbox{Linear type} & \type &::=  &  \ltype \lto{\nnatA} \type ~|~
                                     \tbase ~|~ \tbool \\
  \mbox{Nonlinear Type} & \ltype & ::= & \bang{\idx} \type   \\
  \mbox{Typing context } & \Gamma & ::= & x_1 : \ltype_1, \ldots,
                                          x_n : \ltype_n
\end{array}
\]


\begin{figure}[h]
  \begin{mathpar}
    \inferrule{
    }{
     \valr, \env \bigstep{0} \valr, \env} ~\textsf{val}
   %  \and
   % \inferrule{  \mathsf{fetch} (\env,x)  =  (\valr, \adapt)  }{x, \env
   %   \bigstep{\adapt} \valr, \env }~\textsf{var}
   \and
   %
     \inferrule{  \env(x)  =  (\valr, \env_1,  \adapt)  }{x,
       \env  \bigstep{\adapt} \valr, \env_1 }~\textsf{var}
     %
   \and
  %
   \inferrule{ }{\econst , \env \bigstep{0} \econst, \env}~\textsf{const}
   %
   \and
   %
 \inferrule{
  }{
    \lambda x. \expr, \env
    \bigstep{0} \lambda x.\expr, \env
  }~\textsf{lambda}
  %
  \and
  %
  \inferrule{
    \expr_1, \env_1 \bigstep{\adapt_1} \lambda x.\expr , \env_1' \\
    %\forall x_i \in \dom(\env_1 \cap \env_2).  \fresh \eapp x_i' \\
     \expr_2, \env_2 \bigstep{\adapt_2} \valr_2 , \env_2' \\
    \fresh \eapp x' \\
    \expr[x'/x], \env_1'[ x'  \to (\valr_2, \env_2', \adapt_2  ) ] 
    \bigstep{\adapt_3} \valr, \env_3
  }{
     \expr_1 \eapp \expr_2 , (\env_1 \uplus \env_2)\bigstep{{\max(\adapt_1, \adapt_3)}} \valr, \env_3
  }
 %
  \and
  %
{
  \inferrule{
     \expr , \env \bigstep{\adapt} \valr , \env_1 
   }{
     \eop(\expr), \env \bigstep{\adapt +1} \eop(\valr),  \env_1
   }~\textsf{delta}
 }%
\and
 %
 \inferrule{
   \expr, \env \bigstep{\adapt} \efalse, \env'
   \\
   \expr_2 , \env \bigstep{\adapt_2} \valr_2, \env_2
  }{
    \eif \expr \ethen \expr_1 \eelse \expr_2 , \env \bigstep{\adapt +
      \adapt_2 } \valr_2, \env_2
  }~\textsf{if-f}
%
\and
%
\inferrule{
   \expr , \env \bigstep{\adapt} \etrue, \env'
   \\
    \expr_1, \env \bigstep{\adapt_1} \valr_1, \env_1
  }{
    \eif \expr \ethen \expr_1 \eelse \expr_2 , \env \bigstep{\adapt +
      \adapt_1 } \valr_1, \env_1
  }~\textsf{if-t}
  %
  \and
  %
{  
\inferrule{
    \expr, \env \bigstep{\adapt} (\expr_1, \expr_2) , \env_1 \\
    %\forall x_i \in \dom(\env_1 \cap \env_2).  \fresh \eapp x_i' \\
     \expr_1, \env_1 \bigstep{\adapt_1} \valr_1 , \env_1' \\
     \expr_2, \env_1 \bigstep{\adapt_2} \valr_2 , \env_2' \\
    \fresh \eapp x', y' \\
    \expr'[x'/x][y'/y], 
    \env_1[ x'  \to (\valr_1, \env_1', \adapt_1), 
    y' \to (\valr_2, \env_2', \adapt_2) ] 
    \bigstep{\adapt'} \valr, \env'
  }{
     \elet \eapp (x, y) = \expr \ein \expr' , \env \bigstep{{\max(\adapt, \adapt')}} \valr, \env'
  }~\textsf{bind}
  }
  \\\\
  \begin{array}{llll}
    \env_1 \uplus \emptyset & \triangleq & \env_1 &\\
     \emptyset \uplus \env_2 & \triangleq & \env_2 &\\
  \end{array}
\end{mathpar}
  \caption{Big-step semantics }
  \label{fig:semantics1}
\end{figure}


\begin{figure}[h]
  \begin{mathpar}
    \inferrule{
    }{
      \ictx \tctx , x: \bang{1} \type \tvdash{0} x: \type
    }~\textbf{Ax}
    %
    \and
    %
    \inferrule{
    }{
      \ictx \Gamma \tvdash{0} c : \tbase 
    }~\textbf{const}
    %
    %
    \and
    %
    \inferrule{
      \ictx \Gamma, x: \ltype
      \tvdash{\nnatA }
      \expr: \type
    }{
      \ictx \Gamma \tvdash{0} \lambda x. \expr : \ltype
      \lto{\nnatA} \type
    }~\textbf{lambda}
    \and
    %
    \inferrule{
      \ictx \Gamma_1  \tvdash{\nnatA_1} \expr_1:  \bang{\idx} \type_1
      \lto{\nnatA} \type_2      \\
      \ictx \Gamma_2 \tvdash{\nnatA_2} \expr_2: \type_1 
    }{
      \ictx   \Gamma_1 + \idx \times \Gamma_2  
      \tvdash{    \nnatA_1 +
        \idx \times \nnatA_2 + \nnatA    } 
        \expr_1 \eapp \expr_2 : \type_2
    }~\textbf{app}
    %
    \and
    %
    \inferrule{
      \ictx \Gamma \tvdash{\nnatA} \expr:  \tbase 
    }{
      \ictx \Gamma  \tvdash{1+\nnatA} \delta(\expr): \tbase
    }~\textbf{delta}
     %
    \and
    %
    \inferrule{
      \ictx \Gamma'  \tvdash{\nnatA'} \expr: \type' \\
      \Gamma' \leqslant \Gamma \\
      \nnatA' \leq \nnatA\\
      \sub{\type'}{\type} 
    }{
      \ictx \Gamma  \tvdash{\nnatA} \expr: \type 
    }~\textbf{subtype}
      %
    \and
    %
    \inferrule{
      \ictx \Gamma, y: \type', x: \type ,\Gamma'  \tvdash{\nnatA} \expr: \type 
    }{
      \ictx \Gamma, x: \type, y: \type' ,\Gamma'  \tvdash{\nnatA} \expr: \type 
    }~\textbf{exchange}
    %
    \and
    %
    {
    \inferrule{
      \ictx \Gamma \tvdash{\nnatA} \expr: \tbool
      \\
      \ictx \Gamma_1 \tvdash{\nnatA_1} \expr_1: \type
      \\
      \ictx \Gamma_2 \tvdash{\nnatA_2} \expr_2: \type
      \\
      \Gamma' = \Gamma + \Gamma_1 + \Gamma_2
      \\
      \nnatA' = \nnatA + \max(\nnatA_1, \nnatA_2)
    }{
      \ictx \Gamma' \tvdash{\nnatA'}  \eif \expr  \ethen \expr_1 \eelse \expr_2 : \type 
    }~\textbf{if}
    }
     \\\\
\begin{array}{llll}
  \idx \times \Gamma &\triangleq  &  \Gamma  & \idx =1  \\
                     &\triangleq  &  \bang{0} \Gamma & \idx =0 \\
  \bang{\idx_1} \type + \bang{\idx_2} \type  &\triangleq  
  & \bang{ \max(\idx_1,\idx_2)} \type &  \\
  \Gamma + \emptyset & \triangleq & \Gamma & \\
  \emptyset+ \Gamma  & \triangleq & \Gamma & \\
  ( [x : \ltype ],\Gamma) +  ([x: \ltype'],\Delta)  & \triangleq
                            & [x: \ltype + \ltype' ], \Gamma +
                              \Delta &   \\
   \sub{\Gamma}{\Delta} & \triangleq &  \dom(\Gamma) = \dom(\Delta) & \\
    & &                                    \land \forall x \in
                                      \dom(\Gamma),
        \sub{\Delta(x)}{\Gamma(x)} &  
\end{array}
  \end{mathpar}
  \caption{Typing rules, first version}
  \label{fig:type-rules1}
\end{figure}

\begin{figure}[h]
  \begin{mathpar}
    \inferrule{
      \idx_1 \leq \idx \\
      \sub{\ltype}{\ltype_1}
    }{
      \sub{\bang{\idx} \ltype}{\bang{\idx_1} \ltype_1}
    }~\textsf{bang}
    %
    \and
    %
    \inferrule{
        \nnatA \leq \nnatA' \\
        \sub{\type_1}{\type}   \\
      \sub{\type'}{\type_1'}
    }{
      \sub{\type \lto{\nnatA} \type' }{\type_1 \lto{\nnatA'} \ltype_1'}
    }~\textsf{arrow}
    %
    \and
    %
    \inferrule{
    }{
    \sub{\tbase}{\tbase}
    }~\textsf{base}
  \end{mathpar}
  \caption{subtyping}
 \end{figure}

 \clearpage

 \begin{figure}[h]
  \begin{mathpar}
    \inferrule{
     \env ( x ) = (\valr, \env', \adapt)
      \\
      \tvdash{\nnatA} ( \valr, \env') : \type
          }{
     \tvdash{\adapt + \nnatA}   ( x, \env):  \type
    }~\textbf{C-Ax}
    %
    \and
    %
    \inferrule{
    }{
      \tvdash{0} (  c, \env) : \tbase
    }~\textbf{C-const}
   
    \and
    %
    \inferrule{
      \tvdash{\nnatA' } ( \valr', \theta') : \type_1
      \\
      \fresh\eapp  x' ~~ \forall \adapt'
      \\
      \tvdash{ S+ \idx \times (\adapt' + \nnatA' ) +\nnatA }
     ( \expr[x'/x], \env[x' \to (\valr', \theta', R')]      ) :
     \type_2
    }{
     \tvdash{S} (  \lambda x. \expr, \env )  : \bang{\idx} \type_1
      \lto{\nnatA} \type_2
    }~\textbf{C-lambda}
    \and
    %
    \inferrule{
       \tvdash{\nnatA_1} ( \expr_1, \env_1) :  \bang{\idx} \type_1
      \lto{\nnatA} \type_2      \\
      \tvdash{\nnatA_2} ( \expr_2, \env_2 ): \type_1
    }{
       \tvdash{    \nnatA_1 +
        \idx \times \nnatA_2 + \nnatA    } (  \expr_1 \eapp \expr_2, \env_1 \uplus \env_2   ) : \type_2
    }~\textbf{C-app}
    %
    \and
    %
    \inferrule{
      \tvdash{\nnatA} (\expr, \env) :  \tbase
   }{  \tvdash{1+\nnatA} (\delta(\expr) , \env ) : \tbase
    }~\textbf{C-delta}
    \\\\
    \begin{array}{lll}
       \theta  & \triangleq (x_i \to (\valr_i, \env_i, R_i)) & i \in 
       \mathbb{N}\\
      (x_i : \bang{ \idx }\type_i), \Gamma \vDash (x_i \to (\valr_i, \env_i, R_i))
      \uplus \theta & \triangleq ~~~\tvdash { \_ } (\valr_i, \env_i)
                                          :  \type_i  &\conj
                                   \Gamma \vDash \theta
      \end{array}
  \end{mathpar}
  \caption{Typing rules, configure}
  \label{fig:configure-rules}
\end{figure}

\begin{figure}[h]
  \begin{mathpar}
    \begin{array}{lll}
      \lrv{\tbase} & = & \{  ( \econst, \env,  \nnatA)  \} \\
      %
      % \lrv{\type_1 \times \type_2} & = & \{(\valr_1, \valr_2) ~|~ \valr_1 \in \lrv{\type_1} \conj \valr_2 \in \lrv{\type_2} \}\\
      %
      \lrv{\bang{k} \type } & = & \{  ( \valr, \env,   \nnatA) |  (\valr, \env,
                                   \nnatA ) \in \lrv{\type}  \} \\
      %
      \lrv{ \bang{k} \type_1 \lto{\nnatA} \type_2    } & = &
      \{( \lambda x.\expr, \env,  \nnatA_1) ~|~ \forall \valr', \env',
      \nnatA'. ( \valr',\env',  \nnatA') \in
      \lrv{ \bang{k} \type_1 }.\\
      & & 
          \implies   \fresh \eapp x' \land \\
      & & \forall \adapt. ( \expr[x'/x], \env[x' \mapsto (\valr', \env', \adapt )] ) \in
          \lre{    }{ \nnatA_1+\nnatA+ \idx \times (\adapt + \nnatA') }{\type_2}     \} \\
      %
      \\
      %
      \lre{}{\nnatA}{\type} & = & \{  ( \expr, \env) ~|~  ( \expr , \env
                                  \bigstep{\adapt}  \valr, \env' ) \\
      & & ~~~~~~~~~~~~~\implies \adapt \leq \nnatA \conj 
     ( \valr, \env', \nnatA- \adapt) \in \lrv{\type})
      \}
    \end{array}
  \end{mathpar}
  \caption{Logical relation without step-indexing}
  \label{fig:lr:non-step}
\end{figure}

\paragraph{Typable Approach By Weihao}
\[
\begin{array}{ll}
 F(\expr, \phi ) & where \eapp ~~ \phi(x_i) = (\idx_i, \adapt_i, \nnatA_i ) \\
   F(x,\phi) & = \sum_{x_i \in \fv{x}  } \idx_i \times (\adapt_i+ \nnatA_i)  \\
F(\lambda x. \expr ,  \phi  ) & =  \sum_{x_i \in \fv{\lambda x.\expr}  } \idx_i \times (\adapt_i+ \nnatA_i)   \\  %\sum_{x_i \in \fv{\lambda x.\expr} } k_i \times R_i  \\
F(\delta(\expr) , \phi ) & = \sum_{x_i \in \fv{\delta(\expr)} } \idx_i \times (\adapt_i+ \nnatA_i)  \\
F(c, \phi ) & = 0  \\
F(\expr_1 \eapp \expr_2, \phi ) & = F(\expr_1, \phi ) +
                                  F(\expr_2,\phi ) \\
F(\eif \expr \ethen \expr_1 \eelse \expr_2, \phi ) & = F(\expr, \phi) + \max(F(\expr_1, \phi),  F(\expr_2, \phi)   )  
\end{array} 
\]

\begin{defn}[Typable]
  \label{typable}
  A closure $( \expr, [ x_1 \to (\valr_1 ,  \env_1 , \adapt_1 ) , \ldots, x_i \to (\valr_i, \env_i, \adapt_i )] )$ is typable with type $\type$ and adaptivity $J$ if exists $k_i$\\
  \[
     x_1 : \bang{\idx_1} \type_1, \ldots, \bang{\idx_i} \type_i 
     \tvdash{\nnatA}  \expr : \type  \]
   and each closure $(\valr_i, \env_i)$  is also typable with type $\bang{\idx_i} \type_i$ and adaptivity $\nnatA_i$, $ \phi = [x_1
     \to (\idx_1, \adapt_1, \nnatA_1), \ldots,  x_i \to (\idx_i, \adapt_i,
     \nnatA_i)  ] $,  $J = \nnatA + F( \expr, \phi ) $.
 \end{defn}

 \begin{defn}[ClosedClosure]
  \label{closure}
   A closure $(\expr, \env)$ is closed if $\fv{\expr} \subseteq \dom(\env)$. 
 \end{defn}

% \begin{lem}[ClosureTypable ]
%   \label{ct}
%    If a closure $(\expr, \env)$ is closed, then there exists $\type$ and $J$ so that $(\expr, \env)$ is typable with $\type$ and $J$.
%    \end{lem}
 

\begin{lem}[programTypable]
  \label{proglemma}
   If $ \tvdash{\nnatA}   \expr : \type $, then $(
     \expr, \emptyset ) $ is typable with $\type$ and adaptivity $\nnatA$. 
   \end{lem}

   \begin{lem}[TypableMono]
     \label{tmono}
     If a closure is $D$ is typable with $\type$ and $\nnatA$, and $\nnatA \leq \nnatA'$, then
     D is typable with $\type$ and $\nnatA'$.
    \end{lem} 

   
\begin{lem}[TypableSoundness]
  \label{tsound}
  If a closure $D$ is typable with $\type$ and $J$, and $D \bigstep{\adapt} E$, then
    closure $E$ is typable with $\type$ and adaptivity $J - \adapt$. 
   \end{lem}
\paragraph{Typable Approach By Marco}
\begin{defn}[Typable Closures]
  \label{def:typable}
Let $\env=[ x_1 \to (\valr_1 ,  \env_1 , R_1 ) ,
  \ldots, x_n \to (\valr_n, \env_n, R_n )]$. 
  The closure $( \expr, \env)$ is typable with
  type $\type$ and adaptivity $J$ if:
\begin{enumerate}\item  
     $x_1 : \bang{k_1} \type_1, \ldots, \bang{k_i} \type_i 
     \tvdash{Z}  \expr : \type$, for some types $\bang{k_i}
   \type_i$ for $(1\leq i\leq n)$, 
\item each closure $(\valr_i, \env_i)$ for $(1\leq i\leq n)$ is typable with type
  $\bang{k_i} \type_i$ and adaptivity $Z_i$,
\item $J = Z + \sum_{(v_i,\theta_i,S_i)\in\theta} k_i \times (R_i
  +Z_i)$.
\end{enumerate}
 \end{defn}
To justify why we chose $\sum$ in the third clause above it is worth
to consider the following configuration:
$$
[x\mapsto (\lambda u.\lambda w.\delta(u)+\delta(w),[\,],0)
,y:\mapsto (v,[\,],2) ], x\, y\, y
$$
   
\begin{lem}[Soundness]
  \label{tsound}
  If a closure $D$ is typable with type $\type$ and adaptivity $J$, and $D \bigstep{R} E$, then
    the closure $E$ is typable with type $\type$ and adaptivity $I$,
    where $I+R\leq J$. 
   \end{lem}
\fail{Soundness is unable to be proven}
