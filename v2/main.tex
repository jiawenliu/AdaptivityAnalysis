\documentclass[a4paper,11pt]{article}

\usepackage{mathpartir}
\usepackage{amsmath,amsthm,amsfonts}
\usepackage{color}
\usepackage{algorithm}
\usepackage{algorithmic}

\input{ldefs}

\theoremstyle{definition}
\newtheorem{thm}{Theorem}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{cor}[thm]{Corollary}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{defn}[thm]{Definition}

\title{Adaptivity analysis}

\author{}

\date{January 19, 2019}

\begin{document}

\maketitle

\paragraph{Abstract}
An adaptive data analysis is based on multiple queries over a data set, in which some queries rely on the results of some other queries. The error of each query is usually controllable and bound independently, but the error can propagate through the chain of different queries and bring to high generalization error. To address this issue, data analysts are adopting different mechanisms in their algorithms, such as Gaussian mechanism, etc. To utilize these mechanisms in the best way one needs to understand the depth of chain of queries that one can generate in a data analysis. In this work, we define a programming language which can provide, through its type system, an upper bound on the adaptivity  depth (the length of the longest chain of queries) of a program implementing an adaptive data analysis. We show how this language can help to analyze the generalization error of two data analyses with different adaptivity structures.

\paragraph{Adaptivity}
Adaptivity is a measure of the nesting depth of a mechanism. To
represent this depth, we use extended natural numbers. Define $\natb =
\nat \cup \{\bot\}$, where $\bot$ is a special symbol and $\natbi =
\natb \cup \{\infty\}$. We use $\nnatA, \nnatB$ to range over $\nat$,
$\nnatbA, \nnatbB$ to range over $\natb$, and $\nnatbiA, \nnatbiB$ to
range over $\natbi$.

The functions $\max$ and $+$, and the order $\leq$ on natural numbers
extend to $\natbi$ in the natural way:
\[\begin{array}{lcl}
\max(\bot, \nnatbiA) & = & \nnatbiA \\
\max(\nnatbiA, \bot) & = & \nnatbiA \\
\max(\infty, \nnatbiA) & = & \infty \\
\max(\nnatbiA, \infty) & = & \infty \\
\\
%
\bot + \nnatbiA & = & \bot \\
\nnatbiA + \bot & = & \bot \\
\infty + \nnatbiA & = & \infty ~~~~ \mbox{if } \nnatbiA \neq \bot \\
\nnatbiA + \infty & = & \infty ~~~~ \mbox{if } \nnatbiA \neq \bot \\
\\
%
\bot \leq \nnatbiA \\
\nnatbiA \leq \infty
\end{array}
\]
One can think of $\bot$ as $-\infty$, with the special proviso that,
here, $-\infty + \infty$ is specifically defined to be $-\infty$.

\paragraph{Language}
Expressions are shown below. $\econst$ denotes constants (of some base
type $\tbase$, which may, for example, be reals or rational
numbers). $\eop$ represents a primitive operation (such as a
mechanism), which determines adaptivity. For simplicity, we assume
that $\eop$ can only have type $\tbase \to \tbool$. We make
environments explicit in closures. This is needed for the tracing
semantics later.
\[\begin{array}{llll}
\mbox{Expr.} & \expr & ::= & x ~|~ \expr_1 \eapp \expr_2 ~|~ \efix f(x).\expr
 ~|~ (\expr_1, \expr_2) ~|~ \eprojl(\expr) ~|~ \eprojr(\expr) ~| \\
%
& & & \etrue ~|~ \efalse ~|~ \eif(\expr_1, \expr_2, \expr_3) ~|~
\econst ~|~ \eop(\expr) \\
& & & \boxed{~|~ \elet  = \expr_1 \ein \expr_2 ~|~ \enil ~|~  \econs (
      \expr_1, \expr_2) } \\
%
\mbox{Value} & \valr & ::= & \etrue ~|~ \efalse ~|~ \econst ~|~
(\efix f(x).\expr, \env) ~|~ (\valr_1, \valr_2) 
    \boxed{  ~|~ \enil ~|~ \econs (\valr_1, \valr_2)} \\
%
\mbox{Environment} & \env & ::= & x_1 \mapsto \valr_1, \ldots, x_n \mapsto \valr_n
\end{array}\]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Tracing operational semantics and adaptivity}

\paragraph{Traces}
A trace $\tr$ is a representation of the big-step derivation of an
expression's evaluation. Our big-step semantics output a trace. We use
traces to define the adaptivity of a run. Our notion of traces and the
tracing semantics is taken from~\cite[Section 4]{perera:dep}, but we
omit their ``holes'' for which we have no need. The construct
$\trapp{\tr_1}{\tr_2}{f}{x}{\tr_3}$ records a trace of function
application. $\tr_1$ is the trace of the head, $\tr_2$ the trace of
the argument and $\tr_3$ is the trace of the function body. $f$ and
$x$ are bound in $\tr_3$.
%
\[\begin{array}{llll}
\mbox{Trace} & \tr & ::= & x ~|~ \trapp{\tr_1}{\tr_2}{f}{x}{\tr_3} ~|~
\trfix f(x).e ~|~ (\tr_1, \tr_2) ~|~ \trprojl(\tr) ~|\\ 
%
& & & \trprojr(\tr) ~|~ \trtrue ~|~ \trfalse ~|~ \trift(\tr_b, \tr_t)
~|~ \triff(\tr_b, \tr_f) ~|~ \trconst ~|~ \trop(\tr) \\
%
& & & \trnil ~|~ \trcons (\tr_1, \tr_2)
\end{array}\]


\paragraph{Big-step tracing semantics}
The big-step, tracing semantics $\env, \expr \bigstep \valr, \tr$
computes a value $\valr$ and a trace $\tr$ from an expression $\expr$
and an enviroment $\env$ which maps the free variables of $\expr$ to
\emph{closed} values. The rules, taken from~\cite{perera:dep}, are
shown in Figure~\ref{fig:big-step}. Some salient points:
\begin{itemize}
\item[-] Erasing the traces from the semantics yields a standard
  big-step semantics.
\item[-] The trace of a primitive application $\eop(\expr)$
  records that $\eop$ was applied to the trace of
  $\expr$. This enables us to define adaptivity from a trace later.
\item[-] The trace of a variable $x$ is $x$. This way traces record
  where substitutions occur and, hence, variable dependencies. This is
  also needed for defining adaptivity.
\end{itemize}

\begin{figure}
\begin{mathpar}
  \inferrule{ }{\env, x \bigstep \env(x), x}
  %
  \and
  %
  \inferrule{ }{\env, \econst \bigstep \econst, \trconst}
  %
  \and
  %
  \inferrule{ }{\env, \etrue \bigstep \etrue, \trtrue}
  %
  \and
  %
  \inferrule{ }{\env, \efalse \bigstep \efalse, \trfalse}
  %
  \and
  %
  \inferrule{
  }{
    \env, \efix f(x). \expr \bigstep (\efix f(x).\expr, \env), \trfix f(x).\expr
  }
  %
  \and
  %
  \inferrule{
    \env, \expr_1 \bigstep \valr_1, \tr_1 \\
    \valr_1 = (\efix f(x).\expr, \env') \\\\
    \env, \expr_2 \bigstep \valr_2, \tr_2 \\
    \env'[f \mapsto \valr_1, x \mapsto \valr_2], \expr \bigstep \valr, \tr
  }{
    \env, \expr_1 \eapp \expr_2 \bigstep \valr, \trapp{\tr_1}{\tr_2}{f}{x}{\tr}
  }
  %
  \and
  %
  \inferrule{
    \env, \expr_1 \bigstep \valr_1, \tr_1 \\
    \env, \expr_2 \bigstep \valr_2, \tr_2
  }{
    \env, (\expr_1, \expr_2) \bigstep (\valr_1, \valr_2), (\tr_1, \tr_2)
  }
  %
  \and
  %
  \inferrule{
    \env, \expr \bigstep (\valr_1, \valr_2), \tr
  }{
    \env, \eprojl(\expr) \bigstep \valr_1, \trprojl(\tr)
  }
  %
  \and
  %
  \inferrule{
    \env, \expr \bigstep (\valr_1, \valr_2), \tr
  }{
    \env, \eprojr(\expr) \bigstep \valr_2, \trprojr(\tr)
  }
  %
  \and
  %
  \inferrule{
    \env, \expr \bigstep \etrue, \tr \\
    \env, \expr_1 \bigstep \valr, \tr_1
  }{
    \env, \eif(\expr, \expr_1, \expr_2) \bigstep \valr, \trift(\tr, \tr_1)
  }
  %
  \and
  %
  \inferrule{
    \env, \expr \bigstep \efalse, \tr \\
    \env, \expr_2 \bigstep \valr, \tr_2
  }{
    \env, \eif(\expr, \expr_1, \expr_2) \bigstep \valr, \triff(\tr, \tr_2)
  }
  %
  \and
  %
  \inferrule{
    \env, \expr \bigstep \valr, \tr \\
    \eop{}(\valr) = \valr'
  }{
    \env, \eop(\expr) \bigstep \valr', \trop(\tr)
  }
%
\and
%
\boxed{
  \inferrule{
}
{ \env, \enil \bigstep \enil, \trnil }
%
\and
%
\inferrule{
\env, \expr_1 \bigstep \valr_1, \tr_1 \\
\env, \expr_2 \bigstep \valr_2, \tr_2
}
{ \env, \econs (\expr_1, \expr_2)  \bigstep \econs (\valr_1, \valr_2),
  \trcons(\tr_1, \tr_2)
}
}
%
\and
%
\boxed{
\inferrule{
  \env, \expr_1 \bigstep \valr_1, \tr_1 \\
  \env[x \mapsto \valr_1] , \expr_2 \bigstep \valr, \tr_2
}
{\env, \elet x;q = \expr_1 \ein \expr_2 \bigstep \valr, \trlet (x,
  \tr_1, \tr_2) }

}

\end{mathpar}


  
  \caption{Big-step semantics with provenance}
  \label{fig:big-step}
\end{figure}


\paragraph{Adaptivity of a trace}
We define the \emph{adaptivity} of a trace $\tr$, $\adap(\tr)$, which
means the maximum number of nested $\eop$s in $\tr$, taking variable
and control dependencies into account. To define this, we need an
auxiliary notion called the \emph{depth of variable $x$} in trace
$\tr$, written $\ddep{x}(\tr)$, which is the maximum number of
$\eop{}$s in any path leading from the root of $\tr$ to an occurence
of $x$ (at a leaf), again taking variable and control dependencies
into account. Technically, $\adap: \mbox{Traces} \to \nat$ and
$\ddep{x}: \mbox{Traces} \to \natb$. If $x$ does not appear free in
$\tr$, $\ddep{x}(\tr)$ is $\bot$.

The functions $\adap$ and $\ddep{x}$ are defined by mutual induction
in Figure~\ref{fig:adap}. 

\begin{figure}
  \framebox{$\adap: \mbox{Traces} \to \nat$}
  \begin{mathpar}
    \begin{array}{lcl}
      \adap(x) & = & 0 \\
      %
      \adap(\trapp{\tr_1}{\tr_2}{f}{x}{\tr_3}) & = &
      \adap(\tr_1) + \max(\adap(\tr_3), \adap(\tr_2) + \ddep{x}(\tr_3))\\
      %
      \adap(\trfix f(x).\expr) & = & 0 \\
      %
      \adap((\tr_1, \tr_2)) & = & \max(\adap(\tr_1), \adap(\tr_2)) \\
      %
      \adap(\trprojl(\tr)) & = & \adap(\tr) \\
      %
      \adap(\trprojr(\tr)) & = & \adap(\tr) \\
      %
      \adap(\trtrue) & = & 0 \\
      %
      \adap(\trfalse) & = & 0 \\
      %
      \adap(\trift(\tr_b, \tr_t)) & = & \adap(\tr_b) + \adap(\tr_t) \\
      %
      \adap(\triff(\tr_b, \tr_f)) & = & \adap(\tr_b) + \adap(\tr_f) \\
      %
      \adap(\trconst) & = & 0 \\
      %
      \adap(\trop(\tr)) & = & 1 + \adap(\tr) \\
      %
     \adap(\trnil) & = & 0 \\
     %
     \adap(\trcons(\tr_1,\tr_2) ) & = &  \max(\adap(\tr_1),
                                        \adap(\tr_2)) \\
     %
    \adap( \trlet (x, \tr_1,\tr_2) ) & = & \max (\adap(\tr_2),
                                           \adap(\tr_1)+\ddep{x}(\tr_2)  )
      \end{array}
  \end{mathpar}
  
  \framebox{$\ddep{x}: \mbox{Traces} \to \natb$}
  \begin{mathpar}
    \begin{array}{lcl}
      \ddep{x}(y) & = &
      \left\lbrace
      \begin{array}{ll}
        0 & \mbox{if } x = y \\
        \bot & \mbox{if } x \neq y
      \end{array}
      \right.\\
      %
      \ddep{x}(\trapp{\tr_1}{\tr_2}{f}{y}{\tr_3}) & = & \max(\ddep{x}(\tr_1), \\
      & & ~~~~~~~\adap(\tr_1) + \max(\ddep{x}(\tr_3), \ddep{x}(\tr_2) + \ddep{y}(\tr_3))) \\
      %
      \ddep{x}(\trfix f(y).\expr) & = & \bot \\
      %
      \ddep{x}((\tr_1, \tr_2)) & = & \max(\ddep{x}(\tr_1), \ddep{x}(\tr_2)) \\
      %
      \ddep{x}(\trprojl(\tr)) & = & \ddep{x}(\tr) \\
      %
      \ddep{x}(\trprojr(\tr)) & = & \ddep{x}(\tr) \\
      %
      \ddep{x}(\trtrue) & = & \bot \\
      %
      \ddep{x}(\trfalse) & = & \bot \\
      %
      \ddep{x}(\trift(\tr_b, \tr_t)) & = & \max(\ddep{x}(\tr_b), \adap(\tr_b) + \ddep{x}(\tr_t)) \\
      %
      \ddep{x}(\trift(\tr_b, \tr_f)) & = & \max(\ddep{x}(\tr_b), \adap(\tr_b) + \ddep{x}(\tr_f)) \\
      %
      \ddep{x}(\trconst) & = & \bot \\
      %
      \ddep{x}(\trop(\tr)) & = & 1 + \ddep{x}(\tr) \\
       %
      \ddep{x}(\trnil) & = & \bot \\
      %
      \ddep{x}(\trcons(\tr_1,\tr_2) ) & = & \max(\ddep{x}(\tr_1),
                                            \ddep{x}(\tr_2)) \\
      %
      \ddep{x}( \trlet(y, \tr_1, \tr_2) ) & = & \max( \ddep{x}(\tr_2),
                                                \ddep{x}(\tr_1)+\ddep{y}(\tr_2)  )

    \end{array}
  \end{mathpar}
  \caption{Adaptivity of a trace and depth of variable $x$ in a trace}
  \label{fig:adap}
\end{figure}

\paragraph{Explanation of $\adap$}
We explain the interesting cases of the definition of $\adap$. The
case $\trapp{\tr_1}{\tr_2}{f}{x}{\tr_3}$ corresponds to a function
application with $\tr_1$, $\tr_2$, $\tr_3$ being the traces of the
head, the argument and the body, respectively, and $x$ being the
argument. The adaptivity is defined to be $\adap(\tr_1) +
\max(\adap(\tr_3), \adap(\tr_2) + \ddep{x}(\tr_3))$. The term
$\adap(\tr_1)$ occurs additively since the entire computation is
control-dependent on the function the head of the application
evaluates to. The rest of the term $\max(\adap(\tr_3), \adap(\tr_2) +
\ddep{x}(\tr_3))$ is simply the maximum nesting depth in the body,
taking the data dependency on the argument into account. To see this,
consider the following exhaustive cases:
\begin{itemize}
  \item[-] When $x$ appears free in the trace $\tr_3$,
    $\ddep{x}(\tr_3)$ is the maximum $\eop$-nesting depth of $x$ in
    the body. Hence, $\max(\adap(\tr_3), \adap(\tr_2) +
    \ddep{x}(\tr_3))$ represents the maximum number of nested $\eop$s
    in the evaluation of $e[e'/x]$ where $e'$ is the argument
    expression that generates the trace $\tr_2$ and $e$ is the body of
    the function.
  \item[-] When $x$ does not appear free in the trace $\tr_3$ of the
    body (i.e., the body's evaluation does not depend on $x$),
    $\ddep{x}(\tr_3) = \bot$, so $\max(\adap(\tr_3), \adap(\tr_2) +
    \ddep{x}(\tr_3)) = \max(\adap(\tr_3), \adap(\tr_2) + \bot) =
    \max(\adap(\tr_3), \bot) = \adap(\tr_3)$, which is the adaptivity
    of the body in the absence of dependency from $x$.
\end{itemize}

The case $\trift(\tr_b, \tr_t)$ corresponds to the evaluation of
$\eif(\expr_b, \expr_t, \_)$ where $\expr_b$ evaluates to $\etrue$
with trace $\tr_b$ and $\tr_t$ is the trace of $\expr_t$. In this
case, since the entire evaluation of $\expr_t$ is control dependent on
$\expr_b$, the adaptivity is simply $\adap(\tr_b) + \adap(\tr_t)$.

\paragraph{Explanation of $\ddep{x}$}
We explain interesting cases in the definition of $\ddep{x}$.  For the
trace $\trapp{\tr_1}{\tr_2}{f}{y}{\tr_3}$, $\ddep{x}$ is defined as
$\max(\ddep{x}(\tr_1), \adap(\tr_1) + \max(\ddep{x}(\tr_3),
\ddep{x}(\tr_2) + \ddep{y}(\tr_3)))$. Here, $\max(\ddep{x}(\tr_3),
\ddep{x}(\tr_2) + \ddep{y}(\tr_3))$ is the maximum depth of $x$ in the
body ($\tr_3$), taking the dependency on the argument into
account. Specifically, when the argument variable $y$ is not used in
the body, $\ddep{y}(\tr_3) = \bot$, and this term is
$\ddep{x}(\tr_3)$.  The term $\adap(\tr_1)$ is added since the body's
entire execution is control-flow dependent on the function that the
head of the application evaluates to.

For the trace $\trift(\tr_b, \tr_t)$, $\ddep{x}$ is defined as
$\max(\ddep{x}(\tr_b), \adap(\tr_b) + \ddep{x}(\tr_t))$. The term
$\ddep{x}(\tr_b)$ is simply the maximum depth of $x$ in $\tr_b$. We
take the $\max$ of this with $\adap(\tr_b) + \ddep{x}(\tr_t)$, the
maximum depth of $x$ in $\tr_t$, taking the control dependency on
$\tr_b$ into account. Note that when $x$ is not used in $\tr_t$, then
$\ddep{x}(\tr_t) = \bot$ and $\ddep{x}(\trift(\tr_b, \tr_t)) =
\ddep{x}(\tr_b)$.

\begin{lem}\label{lem:ddep-leq-adap}
For all $\tr$ and $x$, $\ddep{x}(\tr) \leq \adap(\tr)$ in $\natb$.
\end{lem}
%
\begin{proof}
By easy induction on $\tr$, following the definitions of $\ddep{x}$
and $\adap$.
\end{proof}

\paragraph{Remark}
At first glance it may seem that Lemma~\ref{lem:ddep-leq-adap} can be
used to simplify the definition of $\ddep{x}(\trift(\tr_b, \tr_t))$
from $\max(\ddep{x}(\tr_b), \adap(\tr_b) + \ddep{x}(\tr_t))$ to
$\adap(\tr_b) + \ddep{x}(\tr_t)$ since $\ddep{x}(\tr_b) \leq
\adap(\tr_b)$. However, this simplification is not correct, since
$\ddep{x}(\tr_t)$ may be $\bot$. In that case, $\max(\ddep{x}(\tr_b),
\adap(\tr_b) + \ddep{x}(\tr_t))$ equals $\ddep{x}(\tr_b)$ while
$\adap(\tr_b) + \ddep{x}(\tr_t)$ equals $\bot$.

More generally, since $\bot$ behaves like $-\infty$, we do not have
the implication $a \leq b \Rightarrow a \leq b + c$ as $c$ may be
$-\infty$ ($\bot$). As a result, $a \leq b$ does not imply $\max(a, b
+ c) = b + c$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Type system}

We build a type system that statically approximates both $\adap$ and
$\ddep{x}$ for every $x$ in the context.

A \emph{depth map}, denoted $\dmap$, is a map from variables to
$\natbi$.
%
%% We define the support of a depth map, $\supp(\dmap) \defeq \{x ~|~
%% \dmap(x) \neq \bot\}$. We are only interested in depth maps with
%% finite support. Such a depth map can be written $x_1: \nnatbiA_1,
%% \ldots, x_k: \nnatbiA_k$.
%
Our typing judgment takes the form $\Gamma; \dmap \tvdash{\nnatA}
\expr: \type$, where $\Gamma$ is a typing context, $\dmap$ is a depth
map, and $\nnatA \in \nat$. The idea is that $\dmap$ gives an upper
bound on the depth of each free variable of $\expr$. Obviously, we
only care about the values of $\dmap$ on the domain of $\Gamma$ (at
the remaining points, $\dmap$ can be $\bot$; such a $\dmap$ can always
be finitely represented as $x_1: \nnatbiA_1, \ldots, x_k: \nnatbiA_k$,
where $x_1,\ldots,x_k$ are bound by $\Gamma$). $\nnatA$ is an upper
bound on the adaptivity of $\expr$.

\paragraph{Types}
Types $\type$ are simple, except that the function type is annotated
with the adaptivity $\nnatA$ of the function body, a depth-map $\dmap$
which gives the depths of all free variables of the body (i.e.,
variables bound in outer scopes), and a depth $\nnatbiA \in \natbi$ of
the argument variable in the body. The function name, although free in
the body, always has depth $\infty$, so we don't write its depth
explicitly.\footnote{The function name is never substituted by a value
  with a nontrivial trace, so we can choose any depth for it. $\infty$
  is the most permissive depth, as will become clear from the typing
  rules shortly.}

\[
\begin{array}{llll}
  \mbox{Type} & \type & ::= & \tbase ~|~ \tbool ~|~ \type_1 \times
  \type_2 ~|~ \tarr{\type_1}{\type_2}{\nnatbiA}{\dmap}{\nnatA} ~|~
                              \tlist{\type} ~|~ \tbox{\type}
\end{array}
\]

%% Note that the type $\tarr{\type_1}{\type_2}{\nnatbiA}{\dmap}{\nnatA}$
%% is well-formed only in a context $\Gamma$ that binds all variables in
%% the domain of $\dmap$. 

\paragraph{Typing rules}
The typing rules are shown in Figure~\ref{fig:type-rules}. In these
rules, we write $\nnatbiA + \dmap$ or $\dmap + \nnatbiA$ for the depth
map $\lambda x.\eapp  (\nnatbiA + \dmap(x))$ defined on the same domain as
$\dmap$. We also lift $\max$ and $+$ pointwise to depth maps.
%% and define the constant map $\dmapb$ that maps everything to
%% $\bot$.
These are also formally defined in Figure~\ref{fig:type-rules}.

\begin{figure}
  \begin{mathpar}
    \inferrule{
      \Gamma(x) = \type \\ 0 \leq \dmap(x) \mbox{ or equiv.\ } \dmap(x) \neq \bot
    }{
      \Gamma; \dmap \tvdash{\nnatA} x: \type
    }
    %
    \and
    %
    \inferrule{
      \Gamma; \dmap_1 \tvdash{\nnatA_1} \expr_1: (\tarr{\type_1}{\type_2}{\nnatbiA}{\dmap}{\nnatA}) \\
      \Gamma; \dmap_2 \tvdash{\nnatA_2} \expr_2: \type_1 \\\\
      \nnatA' = \nnatA_1 + \max(\nnatA, \nnatA_2 + \nnatbiA) \\
      \dmap' = \max(\dmap_1, \nnatA_1 + \max(\dmap, \dmap_2 + \nnatbiA))
    }{
      \Gamma; \dmap' \tvdash{\nnatA'} \expr_1 \eapp \expr_2 : \type_2
    }
    %
    \and
    %
    \inferrule{
      \Gamma, f: (\tarr{\type_1}{\type_2}{\nnatbiA}{\dmap}{\nnatA}), x: \type_1;
      \dmap[f: \infty, x: \nnatbiA]
      \tvdash{\nnatA}
      \expr: \type_2
    }{
      \Gamma; \dmap' \tvdash{\nnatA'} \efix f(x).\expr: (\tarr{\type_1}{\type_2}{\nnatbiA}{\dmap}{\nnatA})
    }
    %
    \and
    %
    \inferrule{
      \Gamma; \dmap_1 \tvdash{\nnatA_1} \expr_1: \type_1 \\
      \Gamma; \dmap_2 \tvdash{\nnatA_2} \expr_2: \type_2 \\\\
      \dmap' = \max(\dmap_1,\dmap_2) \\
      \nnatA' = \max(\nnatA_1,\nnatA_2)
    }{
      \Gamma; \dmap' \tvdash{\nnatA'} (\expr_1, \expr_2): \type_1 \times \type_2
    }
    %
    \and
    %
    \inferrule{
      \Gamma; \dmap \tvdash{\nnatA} \expr: \type_1 \times \type_2
    }{
      \Gamma; \dmap \tvdash{\nnatA} \eprojl(\expr): \type_1
    }
    %
    \and
    %
    \inferrule{
      \Gamma; \dmap \tvdash{\nnatA} \expr: \type_1 \times \type_2
    }{
      \Gamma; \dmap \tvdash{\nnatA} \eprojr(\expr): \type_2
    }
    %
    \and
    %
    \inferrule{
    }{
      \Gamma; \dmap \tvdash{\nnatA} \etrue: \tbool
    }
    %
    \and
    %
    \inferrule{
    }{
      \Gamma; \dmap \tvdash{\nnatA} \efalse: \tbool
    }
    %
    \and
    %
    \inferrule{
      \Gamma; \dmap_1 \tvdash{\nnatA_1} \expr_1: \tbool \\
      \Gamma; \dmap \tvdash{\nnatA} \expr_2: \type \\
      \Gamma; \dmap \tvdash{\nnatA} \expr_3: \type \\\\
      \nnatA' = \nnatA_1 + \nnatA \\
      \dmap' = \max(\dmap_1, \nnatA_1 + \dmap)
    }{
      \Gamma; \dmap' \tvdash{\nnatA'} \eif(\expr_1, \expr_2, \expr_3):  \type
    }
    %
    \and
    %
    \inferrule{
    }{
      \Gamma; \dmap \tvdash{\nnatA} \econst: \tbase
    }
    %
    \and
    %
    \inferrule{
      \Gamma; \dmap \tvdash{\nnatA} \expr: \tbase \\
      \nnatA' = 1 + \nnatA \\
      \dmap' = 1 + \dmap
    }{
      \Gamma; \dmap' \tvdash{\nnatA'} \eop(\expr): \tbool
    }

 \and
    %
    \inferrule{
      \Gamma; \dmap \tvdash{\nnatA} \expr:  \tbox{  (\tarr{ \tau_1
        }{ \tau_2 }{0}{\dmap''}{0})     }   \\
      \forall x \in \dmap''. \dmap''(x) = 0 \\
      \nnatA' = 1 + \nnatA \\
      \dmap' = 1 + \dmap
    }{
      \Gamma; \dmap' \tvdash{\nnatA'} \eop(\expr): \treal
    }
  \end{mathpar}
  \caption{Typing rules}
  \label{fig:type-rules}
\end{figure}

\clearpage
\begin{figure}
\[
\begin{array}{llll}
\mbox{Index Term} & \idx, \nnatA & ::= &     i ~|~ n ~|~ \idx_1 + \idx_2 ~|~  \idx_1
                                 - \idx_2 ~|~ \smax{\idx_1}{\idx_2}\\
  \mbox{Sort} & S & ::= & \nat \\
\mbox{Expr.} & \expr & ::= & x ~|~ \expr_1 \eapp \expr_2 ~|~ \efix f(x).\expr
            ~|~ (\expr_1, \expr_2) ~|~ \eprojl(\expr) ~|~ \eprojr(\expr) ~| \\
%
& & &           \etrue ~|~ \efalse ~|~ \eif(\expr_1, \expr_2, \expr_3) 
            ~|~ \econst ~|~ \eop(\expr) \\
& & &           ~|~ \elet  = \expr_1 \ein \expr_2 ~|~ \enil ~|~  \econs (
                \expr_1, \expr_2)  \\
& & &  \eilam \expr  ~|~  \expr \eapp []  ~|~
                            \epack \expr ~|~ \eunpack \expr \eas x
                            \ein \expr \\
& & & \boxed{~|~ \bernoulli \eapp \valr ~|~ \uniform \eapp \valr_1 \eapp \valr_2}\\      
%
  \mbox{Type} & \type & ::= & \tbool ~|~ \type_1 \times
  \type_2 ~|~ \tarr{\type_1}{\type_2}{\nnatbiA}{\dmap}{\nnatA} ~|~
                              \tlist{\type} ~|~ \tbox{\type}\\
& & &                  \boxed{ ~|~  \treal ~|~  \tint ~|~   \tint[I]  ~|~      \tforall{i} \type  ~|~ \texists{i} \type      } 
%
\end{array}
\]

\framebox{
  \begin{mathpar}
     \inferrule{
      \Gamma; \dmap \tvdash{\nnatA} \expr: \type \\
      \forall x \in \dom(\Gamma), \sub{\Gamma(x)}{\tbox{\Gamma(x)}}
      \\
      \delta \not\in \expr
    }{
      \Gamma, \Gamma'; \dmap \tvdash{\nnatA} \expr: \tbox{\type}
    }
    %
    \\
    %
    \boxed{
     \inferrule{
      \Gamma; \dmap \tvdash{\nnatA} \expr: \type \\
      \delta \not\in \expr
    }{
      \Gamma, \Gamma'; \dmap \tvdash{\nnatA} \expr: \tbox{\type}
    }    
    }
    %
    \and
    %
    \inferrule{
      \dmap \wf{\type} \\
    }{
      \Gamma; \dmap \tvdash{\nnatA} \enil: \tlist{\type}
    }
    % 
    \and
    %
   \inferrule{
   \Gamma; \dmap_1 \tvdash{\nnatA_1} \expr_1 : \type \\
   \Gamma; \dmap_2 \tvdash{\nnatA_2} \expr_2 : \tlist{\type}\\
   \dmap' = \max(\dmap_1, \dmap_2) \\
   \nnatA' = \max ( \nnatA_1, \nnatA_2 )
   }
   { \Gamma; \dmap' \tvdash{\nnatA'} \econs(\expr_1, \expr_2) :
     \tlist{\type}  }
   %
   \and
   %
   \inferrule{
     \Gamma; \dmap_1 \tvdash{\nnatA_1} \expr_1 : \type_1 \\
     \Gamma, x:\type_1 ; \dmap_2[x:q] \tvdash{\nnatA_2} \expr_2 :
     \type_2 \\
     \dmap' = \max( \dmap_2, \dmap_1 + q ) \\
     \nnatA' = \max ( \nnatA_2, \nnatA_1 + q )
   }
   {  \Gamma; \dmap' \tvdash{\nnatA'}  \elet x = \expr_1 \ein \expr_2 : \type}
   %
   \and
   %
  \inferrule{
      \Delta, i; \Gamma ;\dmap \tvdash{\nnatA} \expr: \type
    }{
     \Delta;  \Gamma; \dmap \tvdash{\nnatA}    \eilam \expr    :  \tforall{i} \type 
    }
    %
    \and
    %
  \inferrule{
      \Delta; \Gamma ;\dmap \tvdash{\nnatA} \expr: \tforall{i} \type
      \\
       \Delta \tvdash{}  I ::  S 
    }{
     \Delta;  \Gamma; \dmap \tvdash{\nnatA[I/i]}    \expr \eapp []   :
     \type[I/i]
    }
    \end{mathpar}
}          

\framebox{
    \begin{mathpar}
  \inferrule
  {
       \Delta (i) = S
  }
  {
     \Delta \tvdash{}  i :: S
  }
  %
  \and
  %
  \inferrule
  {
    \empty
  }
  {
    \Delta \tvdash{}  n :: \nat
  }
  %
  \and
  %
  \inferrule
  {
    \Delta \tvdash{}  \idx_1 :: S
    \and
    \Delta \tvdash{}  \idx_2 :: S
    \and
    \Delta \tvdash{}  \diamond \in \{ +, -, \max \}
  }
  {
    \Delta \tvdash{}  \idx_1 \diamond \idx_2 :: S
  }
  \end{mathpar}
}  

  \framebox{
  \begin{mathpar}
    \mbox{\textbf{where: }} \\
%    \dmapb \defeq \lambda x.\eapp  \bot \\
    \nnatbiA + \dmap \defeq \dmap + \nnatbiA \defeq \lambda x.\eapp  (\nnatbiA + \dmap(x)) \\
    \dmap_1 + \dmap_2 \defeq \lambda x.\eapp  (\dmap_1(x) + \dmap_2(x)) \\
    \max(\dmap_1, \dmap_2) \defeq \lambda x.\eapp  \max(\dmap_1(x), \dmap_2(x))
  \end{mathpar}}

  \caption{New Typing rules and Index Term}
  \label{fig:new-type-rules}
\end{figure}


\begin{figure}
   \begin{mathpar}
     \inferrule{
    }{
      \dmap \models \sub{\tbase}{\tbox{\tbase} }
    }
    %
    \and
    %
     \inferrule{
    }{
      \dmap \models \sub{\tbool}{\tbox{\tbool} }
    }
    %
    \and
    %
    \inferrule{
       \dmap \models \sub{\type_1 }{ \type_1'  } \\
        \dmap \models \sub{\type_2 }{ \type_2'  }
    }{
      \dmap \models \sub{\type_1 \times \type_2 }{ \type_1' \times \type_2'  }
    }
    %
    \and
    %
     \inferrule{
       \forall x \in \dmap'. \dmap'(x) =0
    }{
      \dmap \models \sub{\tbox{(
          \tarr{\type_1}{\type_2}{\nnatbiA}{\dmap'}{\nnatA} )} 
      }{\tarr{(\tbox{\type_1}) }{(\tbox{\type_2})}{0}{\dmap'}{0} }
    }
    %
    \and
    %
     \inferrule{
    }{
      \dmap \models \sub{\tarr{\type_1}{\type_2}{0}{\dmap'}{0} }{  \tbox{(
          \tarr{\type_1}{\type_2}{\nnatbiA}{\dmap'}{\nnatA} )  }
    } }
    %
    \and
    %
     \inferrule{
    }
    {
      \dmap \models \sub{ \tint[I] }{ \tint }
    }
    %
    \and
    %
     \inferrule
    {
      \dmap \models \sub{ \type_1' }{ \type_1 }
      \and
      \dmap \models \sub{ \type_2 }{ \type_2' }
      \and
      \dmap \leq \dmap'
      \and
      \nnatA \leq \nnatA'
    }
    {
      \dmap \models \sub{ \tarr{\type_1}{\type_2}{ \nnatbiA }{\dmap}{\nnatA} }
      { \tarr{\type_1'}{\type_2'}{\nnatbiA'}{\dmap}{\nnatA'} }
    }
    \end{mathpar}
 \caption{Subtyping rules}
  \label{fig:sub-type-rules}
\end{figure}


The rules follow \emph{exactly} the definitions of $\adap()$ and
$\ddep{x}()$ to compute $\nnatA$ and $\dmap$ in the conclusion of the
typing rule for every construct. For instance, the typing rule for
$\expr_1 \eapp \expr_2$ does exactly what $\adap()$ and $\ddep{x}()$
do for the trace $\trapp{\tr_1}{\tr_2}{f}{x}{\tr_3}$.

\paragraph{Remark}
The astute reader might note that our type system looks very much like
a coeffect+effect system where the coeffect $\dmap$ estimates the
depth of each free variable and the effect $\nnatA$ estimates the
adaptivity. While this is true at a high-level, note there are two
essential differences between our type system and a coeffect+effect
system.
\begin{itemize}
\item[-] In some of our rules (those for $\expr_1 \eapp \expr_2$ and
  $\eif(\expr_1, \expr_2, \expr_3)$), the conclusion's coeffect
  depends on the effects of the premises. For instance, in the rule
  for $\expr_1 \eapp \expr_2$, the final coeffect $\dmap'$ depends on
  the effect $\nnatA_1$. This does not happen in standard
  coeffect+effect systems.
\item[-] Our type for functions internalizes the effect. In a standard
  coeffect + effect system, the effect is always on the typing
  judgment, and at the point of function construction ($\efix$), one
  anticipatively adds the effects of future function applications to
  the effect in the conclusion.
\end{itemize}
It may be possible to do away with both these differences by tracking
more information in the coeffects (e.g., what is the maximum
adaptivity of a function's argument?), but the details need to be
worked out and verified.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Denotational Semantics}

\begin{figure}
  \begin{mathpar}
    \begin{array}{lll}
      \lr{\tbool} & = & \mathbb{B}\\
      \lr{\type_1 \times \type_2} & = & \lrv{\type_1}\times\lrv{\type_2}\\
      %
      \lr{\tarr{\type_1}{\type_2}{\nnatbiA}{\dmap}{\nnatA}} & = &
      \lr{\type_1} \to \lrv{\type_2}\\
      %
      \lr{\tmonad \type} & = & \mathcal{M}\lrv{\type}\\
      \\
       \\
      \lr{\etrue}_{\env} &=& t\in \mathbb{B}\\
      \lr{\efalse}_{\env}&=& f \in \mathbb{B}\\
      \lr{(\expr_1,\expr_2)}_{\env}&=& (\lr{\expr_1}_{\env}, \lr{\expr_2}_{\env})\\
      \lr{x}_{\env} &=& \env(x)\\
      \lr{\lambda x:\type.\expr}_{\env} &=&  \hat{\lambda} v\in\lr{\type}. \lr{\expr}_{\env[x=v]}\\
      \lr{\expr_1\expr_2}_{\env} &=&  \lr{\expr_1}_{\env}\lr{\expr_2}_{\env}\\
      \lr{\return(\expr)}_{\env} &=& \hat{\delta}\lr{\expr}_{\env}\\
      \lr{\elet x=\expr_1 \ein \expr_2 }_{\env} &=& {\tt mlet}\ v=\lr{\expr_1}_{\env}
                                             \ {\tt in}\ \lr{\expr_2}_{\env[x=\valr]} \\
    \end{array}
  \end{mathpar}
  \caption{Denotational Semantics without Traces}
  \label{fig:denSem}
\end{figure}

where $\mathcal{M} A$ is the set of discrete distributions over $A$ defined as 
$\{d: A \to [0,1] | \sum_{a\in A} d(a)=1 \}$ and $\hat{\delta}$ is the
Dirac distribution.

\begin{figure}
  \begin{mathpar}
    \begin{array}{lll}
      \lrt{\type} & = & \lr{\type}\times\mathcal{\tr} \\
      % \lr{\type_1 \times \type_2} & = & \lrv{\type_1}\times\lrv{\type_2}\\
      % %
      % \lr{\tarr{\type_1}{\type_2}{\nnatbiA}{\dmap}{\nnatA}} & = &
      % \lr{\type_1} \to \lrv{\type_2}\\
      % %
      % \lr{M\type} & = & \mathcal{M}\lrv{\type}\\
      \\
       \\
      \lrt{\etrue}_{\env} &=& (t,\etrue) \\
      \lrt{\efalse}_{\env}&=& (f,\efalse)\\
      \lrt{(\expr_1,\expr_2)}_{\env}&=& \elet (\valr_1,\tr_1)=\lrt{\expr_1}_{\env} \ein 
                                               \elet (\valr_2, \tr_2)=\lrt{\expr_2}_{\env}) \ein 
                                               ((\valr_1,\valr_2),(\tr_1,\tr_2))\\
      \lrt{x}_{\env} &=& (\env(x),x)\\
      \lrt{\lambda x:\type.\expr}_{\env} &=&  (\hat{\lambda} \valr\in\lr{\type}. \lr{\expr}_{\env[x=\valr]}, \lambda x:\type.\expr)\\
      \lrt{\expr_1\expr_2}_{\env} &=&  
      % (\lr{\expr_1}_{\env}\lr{\expr_2}_{\env},\\ 
        % & & \elet (\valr_1, \tr_1) = \lrt{\expr_1}_{\env} \ein\\
        % & & \elet (\valr_2, \tr_2) = \lrt{\expr_2}_{\env} \ein\\
        % & & \elet \valr_1 = \lr{\lambda x:\type. \expr}_{\env} \ein \\
        % & & \elet (\valr, \tr) = \lrt{\expr}_{\env[x \to \valr_2]} \ein\\
        % & & (\tr_1, \tr_2, \mathrel{\triangleright} \lambda x:\type. \tr))\\
\\
\\
      \lr{\return(\expr)}_{\env} &=& \hat{\delta}\lr{\expr}_{\env}\\
      \lr{\elet x=\expr_1 \ein \expr_2 }_{\env} &=& ({\tt mlet}\ \valr=\lr{\expr_1}_{\env}
                                                   
                                                  \ {\tt in}\ \lr{\expr_2}_{\env[x=\valr]},\\
      & & \elet (\valr_1, \tr_1) = \lrt{\expr_1}_{\theta} \ein \\
      & & \elet (\valr_2, \tr_2) = \lrt{\expr_2}_{\theta[x \to \valr_1]} \ein \\
      & & (x, \tr_1, \tr_2)
      ) \\
    \end{array}
  \end{mathpar}
  \caption{Denotational Semantics with Traces}
  \label{fig:denSem_trace}
\end{figure}

\section{Logical relation and soundness}

Our type system is sound in the following sense.

\begin{thm}[Soundness]\label{thm:soundness}
If $\tvdash{\nnatA} \expr: \type$ and $\cdot, \expr \bigstep \valr,
\tr$ then $\adap(\tr) \leq \nnatA$.
\end{thm}

To prove this theorem, we build a logical relation on types. As usual,
the relation consists of a value relation and an expression
relation. We first show a non-step-indexed version of the relation in
Figure~\ref{fig:lr:non-step}. This relation is well-founded but
cannot, as usual, be used directly to prove the soundness of the
$\efix$ typing rule. We show this relation here purely for exposition
without the clutter of step-indices. We will step-index the relation
shortly.

\begin{figure}
  \begin{mathpar}
    \begin{array}{lll}
      \lrv{\tbool} & = & \{\etrue, \efalse\} \\
      %
      \lrv{\tbase} & = & \{\econst ~|~ \econst: \tbase \} \\
      %
      \lrv{\type_1 \times \type_2} & = & \{(\valr_1, \valr_2) ~|~ \valr_1 \in \lrv{\type_1} \conj \valr_2 \in \lrv{\type_2} \}\\
      %
      \lrv{\tarr{\type_1}{\type_2}{\nnatbiA}{\dmap}{\nnatA}} & = &
      \{(\efix f(x).\expr, \env) ~|~ \forall \valr \in \lrv{\type_1}.\\
      & & 
      ~~~~~~(\env[x \mapsto \valr, f \mapsto (\efix f(x).\expr, \env)], \expr) \in \lre{\dmap[x: \nnatbiA, f: \infty]}{\nnatA}{\type_2}\} \\
      %
      \\
      %
      \lre{\dmap}{\nnatA}{\type} & = & \{ (\env, \expr) ~|~ \forall \valr\eapp  \tr.\eapp  (\env, \expr \bigstep \valr, \tr) \\
      & & ~~~~~~~~~~~~~~~~~\Rightarrow (\adap(\tr) \leq \nnatA \conj \\
      & & ~~~~~~~~~~~~~~~~~~~~~~~\forall x \in \mbox{Vars}.\eapp  \ddep{x}(\tr) \leq \dmap(x) \conj \\
      & & ~~~~~~~~~~~~~~~~~~~~~~~\valr \in \lrv{\type})
      \}
    \end{array}
  \end{mathpar}
  \caption{Logical relation without step-indexing}
  \label{fig:lr:non-step}
\end{figure}

The value relation $\lrv{\type}$, as usual, defines which
\emph{closed} values are semantically in the type $\type$. The only
interesting case of this relation is the case for the arrow type. The
expression relation $\lre{\dmap}{\nnatA}{\type}$ is more
interesting. It is indexed by a depth map and an
adaptivity. Importantly, this relation contains sets of configurations
$(\env, \expr)$ where the evaluation of $(\env, \expr)$ produces a
value in the value relation at $\type$, the adaptivity of the trace is
no more than $\nnatA$ and for any variable $x$, $\ddep{x}$ of the
trace is no more than $\dmap(x)$.

The value relation can be lifted to contexts in the usual way. Say
that $\env \in \lrv{\Gamma}$ when $\dom(\env) \supseteq \dom(\Gamma)$
and for every $x \in \dom(\Gamma)$, $\env(x) \in \lrv{\Gamma(x)}$.

The fundamental theorem we would \emph{like} to prove is the
following. Of course, this cannot be proven until we step-index the
relation, but this should give an idea of the connection between the
type system and the logical relation.

\begin{prop}[Fundamental theorem]
\label{prop:fund}
  If $\Gamma; \dmap \tvdash{\nnatA} \expr: \type$ and $ \env \in
  \lrv{\Gamma}$, then $(\env, \expr) \in \lre{\dmap}{\nnatA}{\type}$.
\end{prop}


If this proposition were provable, then Theorem~\ref{thm:soundness}
would follow from it immediately.

\paragraph{Step-indexed logical relation}
To step-index the relation we need to have a notion of the number of
reduction steps. One way to do this is to change the operational
semantics to count the number of reduction steps. However, this is
unnecessary since the number of reduction steps in a derivation is
exactly the size of the derivation's trace. So, we just ``index'' the
relation on the size of the derivation's trace. The same technique has
been used previously~\cite{cicek15}.

\begin{defn}[Trace size]
  The size of a trace is defined as the number of
  $\trapp{\tr_1}{\tr_2}{f}{x}{\tr_3}$, $\trift(\tr_b, \tr_t)$,
  $\triff(\tr_b, \tr_f)$ and $\trop(\tr)$ constructors in
  it. Basically, we count all elimination constructors, but not
  introduction constructors.\footnote{Deepak's note: The purpose of
    counting this way is to make sure that the trace of the evaluation
    of any \emph{value} has size $0$. This may be required in the
    proof of the fundamental theorem, but I am not sure.}

\end{defn}

\begin{defn}[Trace size]
  We use $\size{\tr}$ to denote the size of the trace $\tr$.
\end{defn}
\begin{figure}
  \framebox{$\size{\tr}: \mbox{Traces} \to \nat$}
  \begin{mathpar}
    \begin{array}{lcl}
      \size{x} & = & 0 \\
      %
      \size{\trapp{\tr_1}{\tr_2}{f}{x}{\tr_3}} & = &
      \size{\tr_1} + \size{\tr_2} + \size{\tr_3} + 1 \\
      %
      \size{\trfix f(x).e} & = & 0 \\
      %
      \size{(\tr_1, \tr_2)} & = & \size{\tr_1} + \size{\tr_2} \\
      %
      \size{\trprojl(\tr)} & = & \size{\tr} +1 \\
      %
      \size{\trprojr(\tr)} & = & \size{\tr} + 1 \\
      %
      \size{\trtrue} & = & 0 \\
      %
      \size{\trfalse} & = & 0 \\
      %
      \size{\trift(\tr_b, \tr_t)} & = & \size{\tr_b} + \size{\tr_t} + 1 \\
      %
      \size{\triff(\tr_b, \tr_f)} & = & \size{\tr_b} + \size{\tr_f} + 1 \\
      %
      \size{\trconst} & = & 0 \\
      %
      \size{\trop(\tr)} & = & \size{\tr} + 1 \\
      %
      \size{\trnil} & = & 0 \\
      %
      \size{\trcons(\tr_1,\tr_2)} & = & \size{\tr_1} + \size{\tr_2} \\
      % 
      \size{ \trlet(x, \tr_1, \tr_2) } & = & \size{\tr_1} + \size{\tr_2}
      \end{array}
  \end{mathpar}
  \caption{Size of a trace}
  \label{fig:size}
\end{figure}



The step-indexed relation is shown in Figure~\ref{fig:lr:step}. Now,
the value relation $\lrv{\type}$ contains pairs of step-indices
$\stepiA$ and closed values. The expression relation contains pairs of
step-indices and configurations $(\env, \expr)$. The relation
basically mirrors the non-step-indexed relation of
Figure~\ref{fig:lr:non-step}, with step indexes added in the
completely standard way.


\begin{figure}
  \begin{mathpar}
    \begin{array}{lll}
      \lrv{\tbool} & = & \{(\stepiA, \etrue) ~|~ \stepiA \in \nat\} \cup
      \{ (\stepiA, \efalse) ~|~ \stepiA \in \nat\} \\
      %
      \lrv{\tbase} & = & \{(\stepiA, \econst) ~|~ \stepiA \in \nat \conj \econst: \tbase \} \\
      %
      \lrv{\type_1 \times \type_2} & = & \{(\stepiA, (\valr_1, \valr_2)) ~|~ (\stepiA, \valr_1) \in \lrv{\type_1} \conj (\stepiA, \valr_2) \in \lrv{\type_2} \}\\
      %
      \lrv{\tarr{\type_1}{\type_2}{\nnatbiA}{\dmap}{\nnatA}} & = &
      \{(\stepiA, (\efix f(x).\expr, \env)) ~|~ \forall \stepiB < \stepiA.\eapp  \forall (\stepiB, \valr) \in \lrv{\type_1}.\\
      & & 
      ~~~~~~(\stepiB, (\env[x \mapsto \valr, f \mapsto (\efix f(x).\expr, \env)], \expr)) \in \lre{\dmap[x: \nnatbiA, f: \infty]}{\nnatA}{\type_2}\} \\
      %
     \boxed{ \lrv{\tlist{\type}}  } & = & \{  (\stepiA, \enil) ~|~ \stepiA \in
                                \nat \} \cup \{  (\stepiA,
                                \econs(\valr_1,\valr_2) ) ~|~
                                (\stepiA, \valr_1) \in \lrv{\type}
                                \land (\stepiA, \valr_2) \in \lrv{\tlist{\type}} \}
      \\
      %
      \\ 
      %
      \lre{\dmap}{\nnatA}{\type} & = & \{ (\stepiA, (\env, \expr)) ~|~ \forall \valr\eapp  \tr\eapp  \stepiB.\eapp  (\env, \expr \bigstep \valr, \tr) \conj (\size{\tr} = \stepiB) \conj (\stepiB \leq \stepiA) \\
      & & ~~~~~~~~~~~~~~~~~~~~~~~~~\Rightarrow (\adap(\tr) \leq \nnatA \conj \\
      & & ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\forall x \in \mbox{Vars}.\eapp  \ddep{x}(\tr) \leq \dmap(x) \conj \\
      & & ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~((\stepiA - \stepiB,  \valr) \in \lrv{\type})
      \}\\
      \boxed{\lrv{\tint}} & = & \{(\stepiA, i) ~|~ \stepiA \in \nat \conj i : \tint \}\\
      %
      \boxed{\lrv{\treal}} & = & \{(\stepiA, r) ~|~ \stepiA \in \nat \conj r : \treal \}\\
      %  
      \boxed{\lrv{\tbox{\type}}} & = & \{(\stepiA, \valr) ~|~ \stepiA \in \nat \conj \valr \in \lrv{\type} \conj \eop \notin \valr \}\\
      %
      \boxed{ \lrv{\tforall{i} \type} } & = & \{(\stepiA, \eilam \expr) ~|~ \stepiA \in \nat \conj \forall I. ~ \Delta \tvdash{} I ::S, \expr \in \lre{\dmap}{\nnatA}{\type[I/i]} \}\\
      %
      \boxed{ \lrv{ \tint[I] } } & = & \{(\stepiA, \valr) ~|~ \stepiA \in \nat \conj \valr = I \}\\
  \end{array}
  \end{mathpar}
  \caption{Logical relation with step-indexing}
  \label{fig:lr:step}
\end{figure}

We say that $(\stepiA, \env) \in \lrv{\Gamma}$ when $\dom(\env)
\supseteq \dom(\Gamma)$ and for every $x \in \dom(\Gamma)$, $(\stepiA,
\env(x)) \in \lrv{\Gamma(x)}$.

\clearpage
\begin{lem}\label{lem:downward}
1. If $(\stepiA, \valr) \in \lrv{\type}$ and $\stepiA' \leq \stepiA$,
then $(\stepiA', \valr) \in \lrv{\type}$.\\
2. 1. If $(\stepiA, \expr) \in \lre{\nnatA}{\dmap}{\type}$ and $\stepiA' \leq \stepiA$,
then $(\stepiA', \expr) \in \lre{\nnatA}{\dmap}{\type}$\\
3.If $(\stepiA, \env) \in \lrv{\Gamma}$ and $\stepiA' \leq \stepiA$, then $(\stepiA', \env) \in \lrv{\Gamma}$.
\end{lem}
%
\begin{proof}
(1,2) simultaneously proved by induction on $\type$, 3 followed by (1, 2).
\end{proof}

\begin{thm}[Fundamental theorem]
  If $\Gamma; \dmap \tvdash{\nnatA} \expr: \type$ and $(\stepiA, \env)
  \in \lrv{\Gamma}$, then $(\stepiA, (\env, \expr)) \in
  \lre{\dmap}{\nnatA}{\type}$.
\begin{thm}[Fundamental theorem]
  If $\Gamma; \dmap \tvdash{\nnatA} \expr: \type$ and $(\stepiA, \env)
  \in \lrv{\Gamma}$, then $(\stepiA, (\env, \expr)) \in
  \lre{\dmap}{\nnatA}{\type}$.
\end{thm}
\end{thm}
%
\begin{proof}
By induction on the given typing derivation. For the case of
$\efix$, we subinduct on the step index.

\[
    \boxed{
     \inferrule{
      \Gamma; \dmap \tvdash{\nnatA} \expr: \type \\
      \delta \not\in \expr
    }{
      \Gamma, \Gamma'; \dmap \tvdash{\nnatA} \expr: \tbox{\type}
    }    
    }
\]

\[
\boxed{
  \inferrule{
      \Delta, i; \Gamma ;\dmap \tvdash{\nnatA} \expr: \type
    }{
     \Delta;  \Gamma; \dmap \tvdash{\nnatA}    \eilam \expr    :  \tforall{i} \type 
    }
    }
\]

\[
\boxed{
  \inferrule{
      \Delta; \Gamma ;\dmap \tvdash{\nnatA} \expr: \tforall{i} \type
      \\
       \Delta \tvdash{}  I ::  S 
    }{
     \Delta;  \Gamma; \dmap \tvdash{\nnatA[I/i]}    \expr \eapp []   :
     \type[I/i]
    }
    }
\]

\noindent {\bf case}

\[
   \inferrule*[right = PAIR]{
      \Gamma; \dmap_1 \tvdash{\nnatA_1} \expr_1: \type_1 ~ (1) 
   		\\
      \Gamma; \dmap_2 \tvdash{\nnatA_2} \expr_2: \type_2 ~ (2)
      	\\\\
      \dmap' = \max(\dmap_1,\dmap_2) 
      	\\
      \nnatA' = \max(\nnatA_1,\nnatA_2)
    }{
      \Gamma; \dmap' \tvdash{\nnatA'} (\expr_1, \expr_2): \type_1 \times \type_2
    }
\]
Assume $(\stepiA, \env) \in \lrv{\Gamma}$, 
to show: $(\stepiA, (\env, (\expr_1, \expr_2))) \in \lre{\dmap'}{\nnatA'}{\type_1 \times \type_2}$.\\
%
By inversion, STS: $\forall \eapp  \valr, \tr, j.$ 
$(\env, (\expr_1, \expr_2) \bigstep \valr, \eapp  \tr) \land (\size{\tr} = j) \land (j \leq \stepiA)$\\
%
$\Rightarrow (\adap(\tr) < \nnatA') \land (\forall x \in \mbox{Vars}. \ddep{x}(\tr) \leq \dmap'(x)) \land ((\stepiA - j, \valr) \in \lrv{\type_1 \times \type_2})$.\\
%
By induction hypothesis on $(1)$, we have $(\stepiA, \expr_1) \in \lre{\dmap_1}{\nnatA_1}{\type_1}$.\\
%
By inversion, pick any $\valr_1,  \tr_1, j_1$ s.t.,
$(\env, \expr_1 \bigstep \valr_1, \tr_1) ~ (3) 
\land (\size{\tr_1} = j_1) 
\land (j_1 < \stepiA) $,\\
%
we have: \\
$(\adap(\tr_1) \leq \nnatA_1) ~ (4)$ 
$\land \forall x, \ddep{x}(\tr_1) \leq \dmap_1(x) ~ (5)$ 
$\land (\stepiA - j_1, \valr_1) \in \lrv{\type_1} ~ (6) $.\\
%
By induction hypothesis on $(2)$ and the assumption $(\stepiA - j_1,
\env) \in \lrv{\Gamma}$ from Lemma~\ref{lem:downward}, we have $(\stepiA - j_1, \expr_2) \in \lre{\dmap_2}{\nnatA_2}{\type_2}$.\\
%
By inversion, pick $\valr_2,  \tr_2ï¼Œj_2 $ s.t., $ (\env, \expr_2
\bigstep \valr_2, \tr_2) ~ (7) \land (\size{\tr_2} = j_2) \land j_2 < \stepiA-j_1 $,\\
%
we have:\\
$\adap(\tr_2) \leq \nnatA_2 ~ (8)$
$\land \forall x\in \mbox{Vars}. \ddep{x}(\tr_2) \leq \dmap_2(x) ~ (9)$
$\land (\stepiA- j_1- j_2, \valr_2) \in \lrv{\type_2} ~ (10)$.\\
%
By E-Pair rule, we have:\\
\[
\inferrule*[right = E-Pair]
{\env, \expr_1 \bigstep \valr_1, \tr_1 ~ (3)  \and \env, \expr_2
\bigstep \valr_2, \tr_2 ~ (7) }
{\env, (\expr_1, \expr_2) \bigstep (\valr_1, \valr_2), (\tr_1, \tr_2)}
\]
Pick $\valr = (\valr_1, \valr_2), \tr = (\tr_1, \tr_2), j = |(\tr_1, \tr_2)| = j_1 + j_2$, s.t. $\env, (\expr_1, \expr_2) \bigstep \valr, \tr \land \size{\tr} = j \land j \leq \stepiA$.\\
%
STS:\\
1. $\adap(\tr) = \adap(\tr_1, \tr_2) < \nnatA' = \max(\nnatA_1, \nnatA_2)$, which is proved by $(4), (8)$.\\
%
2. $\forall x \in \mbox{Vars}. \ddep{x}(\tr_1, \tr_2) = \max(\ddep{x}(\tr_1), \ddep{x}(\tr_2)) \leq \dmap'(x) = \max(\dmap_1(x), \dmap_2(x))$, which is proved by $(5),(9)$.\\
%
3. $(\stepiA - (j_1 + j_2), (\valr_1, \valr_2)) \in \lrv{\type_1
  \times \type_2}$, which is proved by $(10)
$ and applying Lemma~\ref{lem:downward} on $(6)$.\\


\noindent {\bf case}
\[
    \inferrule*[right = FIX]{
      \Gamma, f: (\tarr{\type_1}{\type_2}{\nnatbiA}{\dmap}{\nnatA}), x: \type_1;
      \dmap[f: \infty, x: \nnatbiA]
      \tvdash{\nnatA}
      \expr: \type_2
       ~ (\triangle)
    }{
      \Gamma; \dmap' \tvdash{\nnatA'} \efix f(x).\expr: (\tarr{\type_1}{\type_2}{\nnatbiA}{\dmap}{\nnatA})
    }
\]
Assume: $(\stepiA, \env) \in \lrv{\tr}$. TS: $(\stepiA, (\env, \efix f(x). \expr)) \in \lre{\dmap'}{\nnatA}{\type}$.\\
%
By inversion, STS: $\forall \valr, \tr, j.$
$(\env, \efix f(x). \expr \bigstep \valr, \tr) \land (\size{\tr} = j) \land (j \leq \stepiA)$
$ \Rightarrow (\adap(\tr) \leq \nnatA') \land (\forall x \in \mbox{Vars}. \ddep{x}(\tr) \leq \dmap'(x)) \land ((\stepiA - j), \valr) \in \lrv{(\tarr{\type_1}{\type_2}{\nnatbiA}{\dmap}{\nnatA})}$.\\
%
By E-FIX, let $\valr = (\efix f(x). \expr, \env)$, we know:\\
$(\env, \efix f(x). \expr) \bigstep ((\efix f(x). \expr, \env), \efix f(x). \expr)~(1) $;\\
$|\efix f(x). \expr|= j \land j < \stepiA ~(2).$\\
%
Suppose $(1), (2)$, STS: $ (\adap(\efix f(x). \expr) = 0 \leq \nnatA')
\land (\forall x \in \mbox{Vars}. \ddep{x}(\efix f(x). \expr) = \bot \leq \dmap'(x)) \land ((\stepiA -j), (\efix f(x). \expr, \env)) \in \lrv{(\tarr{\type_1}{\type_2}{\nnatbiA}{\dmap}{\nnatA})}$.\\
%
The first two goals are proved , we prove the third proposition
$((\stepiA -j), (\efix f(x). \expr, \env)) \in
\lrv{(\tarr{\type_1}{\type_2}{\nnatbiA}{\dmap}{\nnatA})}$. To prove
this,  we first prove on general theorem: \\
set $\stepiA - j = \stepiA'$, $\forall m \leq \stepiA', (m, (\efix f(x). \expr, \env)) \in \lrv{(\tarr{\type_1}{\type_2}{\nnatbiA}{\dmap}{\nnatA})}$.\\
%
Induction on $m$:

{\bf Subcase 1:} $m = 0$,

	TS: $\forall j' < 0$, $(j', \env[\dots] \expr) \in \lre{\nnatA}{\dmap[\dots]}{(\tarr{\type_1}{\type_2}{\nnatbiA}{\dmap}{\nnatA})}$,
	
	it is obviously true because $j' < 0 \notin \mathbb{N}$.

{\bf Subcase 2:} $m = m' + 1 \leq \stepiA'$, 

	TS: $ (m, (\efix f(x). \expr, \env)) \in \lrv{(\tarr{\type_1}{\type_2}{\nnatbiA}{\dmap}{\nnatA})}$.

	Pick $\forall j' < m' + 1$, $\forall (j', \valr_m) \in \lrv{\type_1}$,
	
	STS: $(j', (\env[x \mapsto \valr_m, f \mapsto (\efix f(x).\expr, \env)], \expr)) \in \lre{\dmap[x: \nnatbiA, f: \infty]}{\nnatA}{\type_2} ~ (\star)$.
	
	By sub ih, we have:
	$(m', (\efix f(x). \expr, \env)) \in \lrv{(\tarr{\type_1}{\type_2}{\nnatbiA}{\dmap}{\nnatA})} ~ (a)$.

	Pick $\env' = \env[x \mapsto \valr_m, f \mapsto (\efix f(x).\expr, \env)]$,
	
	we know: $(j', \env') \in \lrv{\Gamma,
          f:(\tarr{\type_1}{\type_2}{\nnatbiA}{\dmap}{\nnatA}),  x:
          \type_1} ~ (\diamond)$ proved from the following premises:\\ 
	
	1. $ (\stepiA, \env) \in \lrv{\Gamma}$, applying Lemma~\ref{lem:downward} on assumption, we get: $(j', \env) \in \lrv{\Gamma}$.
	
	2. $(j', \valr_m) \in \lrv{\type}$, from the assumption.
	
	3. $(j', (\efix f(x). \expr, \env)) \in \lrv{(\tarr{\type_1}{\type_2}{\nnatbiA}{\dmap}{\nnatA})}$ from $(a)$.\\
%
From above, $\star$ is proved by induction hypothesis on $\diamond$ and $\triangle$.\\
%


\noindent {\bf case}
\[
    \inferrule*[right = APP]
    {
      \Gamma; \dmap_1 \tvdash{\nnatA_1} \expr_1: (\tarr{\type_1}{\type_2}{\nnatbiA}{\dmap}{\nnatA})~(\star) \\
      \Gamma; \dmap_2 \tvdash{\nnatA_2} \expr_2: \type_1 ~(\diamond)\\\\
      \nnatA' = \nnatA_1 + \max(\nnatA, \nnatA_2 + \nnatbiA) \\
      \dmap' = \max(\dmap_1, \nnatA_1 + \max(\dmap, \dmap_2 + \nnatbiA))
    }{
      \Gamma; \dmap' \tvdash{\nnatA'} \expr_1 \eapp \expr_2 : \type_2
    }
\]
%
Assume $(\stepiA, \env) \in \lrv{\Gamma} ~ (\square)$, TS: $(\stepiA, (\env, \expr_1 \eapp \expr_2)) \in \lre{\nnatA'}{\dmap'}{\type_2}$.\\
%
By inversion, pick any $\valr, \tr, j$ s.t. $((\env, \expr_1 \eapp \expr_2) \bigstep (\valr, \tr)) \land (\size{\tr} = j) \land (j \leq \stepiA) $.\\
%
STS: $(\adap(\tr) \leq \nnatA') \land (\forall x \in \mbox{Vars}. \ddep{x}(\tr) \leq \dmap'(x)) \land (((\stepiA - j), \valr) \in \lrv{\type_2})$.\\
%
By induction hypothesis on $\star$ and $\square$, we get: $(\stepiA, (\env, \expr_1)) \in \lre{\dmap_1}{\nnatA_1}{\tarr{\type_1}{\type_2}{\nnatbiA}{\dmap}{\nnatA}} ~(1) $.\\
%
Inversion on $(1)$, we get:\\
%
Pick any $\valr_1, \tr_1, j_1$, s.t. $((\env, \expr_1) \bigstep (\valr_1, \tr_1)) ~(a) \land (\size{\tr_1} = j_1) \land (j_1 < \stepiA)$, \\
%
we know: $(\adap(\tr_1) \leq \nnatA_1)~(2) \land (\forall x \in \mbox{Vars}. \ddep{x}(\tr_1) \leq \dmap_1(x))~(3) \land ((\stepiA - j_1), \valr_1) \in \lrv{\tarr{\type_1}{\type_2}{\nnatbiA}{\dmap}{\nnatA}} ~ (4)$\\
%
we have: $\valr_1$ is a function.
%
Let $\valr_1 = (\efix f(x). \expr, \env') ~(b)$ s.t. $\tr_1= \efix f(x). \expr$\\
By inversion on $(4)$, we have $\forall j' < (\stepiA - j_1). \forall (j', \valr') \in \lrv{\type_1}. (j', (\env'[x \mapsto \valr', f \mapsto (\efix f(x).\expr, \env')], \expr)) \in \lre{\dmap[x : \nnatbiA, f: \infty]}{\nnatA}{\type_2} ~ (5)$.\\ 
%
By induction hypothesis on $\diamond$ and $\square$, we get:
%
$(\stepiA, (\env, \expr_2)) \in \lre{\dmap_2}{\nnatA_2}{\type_1} ~(6)$.\\
%
Inversion on $(6)$, we get:\\
%
Pick any $\valr_2, \tr_2, j_2$, s.t. $((\env, \expr_2) \bigstep (\valr_2, \tr_2))~(c) \land (\size{\tr_2} = j_2) \land (j_2 \leq \stepiA)$,\\
%
we know: $(\adap(\tr_2) \leq \nnatA_2)~(7) \land (\forall x \in \mbox{Vars}. \ddep{x}(\tr_2) \leq \dmap_2(x))~(8) \land ((\stepiA - j_2), \valr_2) \in \lrv{\type_1} ~ (9)$\\
%
Apply Lemma~\ref{lem:downward} on $(9)$, we have $((\stepiA - j_2 - j_1-1), \valr_2) \in \lrv{\type_1}$\\
%
Pick $j' = \stepiA - j_1 - j_2 - 1, \valr' = \valr_2$, we have: $(\stepiA - j_1 - j_2-1, (\env'[x \mapsto \valr_2, f \mapsto \valr_1], \expr)) \in \lre{\dmap[x : \nnatbiA, f: \infty]}{\nnatA}{\type_2} ~ (10)$ from $(5)$.\\
%
Inversion on $(10)$, let $\env'' = \env'[x \mapsto \valr_2, f \mapsto \valr_1]$, pick any $\valr'', \tr'', j''$, s.t. $((\env'', \expr) \bigstep (\valr'', \tr''))~(d) \land (\size{\tr''} = j'') \land (j'' \leq \stepiA - j_1 - j_2-1)$, we have:\\
%
$\adap(\tr'') \leq n ~(11)  \land (\forall x \in \ddep{x}(\tr'')\leq
\dmap[x : \nnatbiA, f: \infty](x)) ~(12) \land (\stepiA - j_1 - j_2 - j''-1, \valr'') \in \lrv{\type_2}~(13)$.\\
%
Apply E-APP rule on $(a) (b) (c) (d)$ we have:
\[
  \inferrule{
    \env, \expr_1 \bigstep \valr_1, \tr_1 ~ (a) \\
    \valr_1 = (\efix f(x).\expr, \env')~(b) \\\\
    \env, \expr_2 \bigstep \valr_2, \tr_2 ~ (c) \\
    \env'[f \mapsto \valr_1, x \mapsto \valr_2], \expr \bigstep \valr'', \tr'' ~(d)
  }{
    \env, \expr_1 \eapp \expr_2 \bigstep \valr'', \trapp{\tr_1}{\tr_2}{f}{x}{\tr''}
  }
\]
Pick $\valr = \valr'', j = j_1 + j_2 + j'' + 1, \tr =
\trapp{\tr_1}{\tr_2}{f}{x}{\tr''}$ s.t. $ \env, \expr_1 \eapp \expr_2
\bigstep \valr, \tr  \land |tr| = j \land j \leq k $.  \\
Suffice to show the follwing three:\\
%
1. $\adap(\tr) = \adap(\trapp{\tr_1}{\tr_2}{f}{x}{\tr''}) =
\adap(\tr_1) + \max(\adap(\tr''), \adap(\tr_2) + \ddep{x}(\tr'')) \leq
\nnatA_1 + \max(\nnatA, \nnatA_2 + \nnatbiA) = \nnatA'$ proved by $(2),(7),(11),(12)$.\\
%
2. $\forall y \in \mbox{Vars}. \ddep{y}(\tr) = \max(\ddep{y}(\tr_1), \adap(\tr_1) +
\max(\ddep{y}(\tr''), \ddep{y}(\tr_2) + \ddep{x}(\tr''))) \leq
\max(\dmap_1, \nnatA_1 + \max(\dmap, \dmap_2 + \nnatbiA)) = \dmap'(y)$
proved by $(2),(3),(8),(12)$. \\
%
3. $(\stepiA - j, \valr) = (\stepiA - j_1 - j_2 - j''-1, \valr'') \in
\lrv{\type_2}$ proved by $(13)$.\\
%


\noindent {\bf case}
\[
    \inferrule*[right = IF]{
      \Gamma; \dmap_1 \tvdash{\nnatA_1} \expr_1: \tbool ~ (\star) \\
      \Gamma; \dmap \tvdash{\nnatA} \expr_2: \type ~(\diamond) \\
      \Gamma; \dmap \tvdash{\nnatA} \expr_3: \type ~(\triangle) \\\\
      \nnatA' = \nnatA_1 + \nnatA \\
      \dmap' = \max(\dmap_1, \nnatA_1 + \dmap)
    }{
      \Gamma; \dmap' \tvdash{\nnatA'} \eif(\expr_1, \expr_2, \expr_3):  \type
    }
\]
Assume $(\stepiA, \env) \in \lrv{\Gamma}$, TS: $(\stepiA, (\env, \eif(\expr_1, \expr_2, \expr_3))) \in \lre{\dmap'}{\nnatA'}{\type}$.\\
%
Inversion on it, $\forall \valr, \tr, j$ $(\env, \eif(\expr_1, \expr_2, \expr_3) \bigstep \valr, \tr) \land (\size{\tr} = j) \land (j \leq \stepiA)$\\
%
STS: $(\adap(\tr) \leq \nnatA') \land (\forall x \in \mbox{Vars}. \ddep{x}(\tr) \leq \dmap'(x)) \land ((\stepiA - j, \valr) \in \lrv{\type})$.\\
%
By induction hypothesis on $\star$ and $(\stepiA-1, \env) \in
\lrv{\Gamma}$ by  Lemma~\ref{lem:downward}, we get: $(\stepiA-1, (\env, \expr_1)) \in \lre{\dmap_1}{\nnatA_1}{\tbool} ~(1)$.\\
%
Inversion on $(1)$, pick $ \valr_1, \tr_1, j_1. (\env, \expr_1 \bigstep \valr_1, \tr_1) ~ (a) \land (\size{\tr_1} = j_1) \land (j_1 \leq \stepiA-1)$,\\
%
we know: $(\adap(\tr_1) \leq \nnatA_1)~(4) \land (\forall x. \in
\ddep{x}(\tr_1) \leq \dmap_1(x)) ~(5) \land ((\stepiA -1- j_1, \valr_1) \in \lrv{\tbool})$\\
%
By induction hypothesis on $\diamond$ and $(\stepiA-1-j_1, \env) \in
\lrv{\Gamma}$ by Lemma~\ref{lem:downward} on the assumption, we get: $(\stepiA-1-j_1, (\env, \expr_2)) \in \lre{\dmap}{\nnatA}{\type} ~(2)$\\
%
By induction hypothesis on $\triangle$ and $(\stepiA-1-j_1, \env) \in
\lrv{\Gamma}$ , we get: $(\stepiA-1-j_1, (\env, \expr_3)) \in \lre{\dmap}{\nnatA}{\type} ~(3)$\\
%
Induction on $\valr_1$, we have two following subcases:

{\bf Subcase1:} $\valr_1 = \etrue$, \\
%
inversion on $(2)$, pick any $\valr_2, \tr_2, j_2. (\env, \expr_2 \bigstep \valr_2, \tr_2) ~ (b) \land (\size{\tr_2} = j_2) \land (j_2 \leq \stepiA-1-j_1)$,\\
%
we know: $(\adap(\tr_2) \leq \nnatA)~(6) \land (\forall x \in \mbox{Vars}. \ddep{x}(\tr_2) \leq \dmap(x))~(7) \land ((\stepiA-1 - j_1-j_2, \valr_2) \in \lrv{\type})~(8)$.\\
%
Apply E-IFT on $(a) (b)$, we get:
\[
  \inferrule{
    \env, \expr_1 \bigstep \etrue, \tr_1 ~ (a) \\
    \env, \expr_2 \bigstep \valr_2, \tr_2 ~ (b)
  }{
    \env, \eif(\expr_1, \expr_2, \expr_3) \bigstep \valr_2, \trift(\tr_1, \tr_2)
  }
\]
Pick $\valr = \valr_2, \tr = \trift(\tr_1, \tr_2), j =j_1+ j_2+1$ s.t. $
\env, \eif(\expr_1, \expr_2, \expr_3) \bigstep \valr, \tr \land j =
|tr| \land j = j_1 + j_2+1 \leq k$.\\
 STS the following 3 goals:\\
%
1. $\adap(\tr) = \adap(\trift(\tr_1, \tr_2)) = \adap(\tr_1) +
\adap(\tr_2)) \leq \nnatA_1 + \nnatA = \nnatA'$. proved by $(4),(6)$.\\
%
2. $\forall x \in \mbox{Vars} . \ddep{x}(\tr) = \max(\ddep{x}(\tr_1), \adap(\tr_1) +
\ddep{x}(\tr_2)) \leq \max(\dmap_1(x), \nnatA_1(x) + \dmap(x)) =
\dmap'(x)  $ proved by $(5), (7)$.\\
%
3. $(\stepiA - j, \valr) = (\stepiA-1 -j_1- j_2, \valr_2) \in
\lrv{\type}$ proved by $(8)$.

{\bf Subcase2:} $\valr_1 = \efalse$\\
%
inversion on $(3)$, pick any $\valr_3, \tr_3, j_3. (\env, \expr_3 \bigstep \valr_3, \tr_3) ~ (b) \land (\size{\tr_3} = j_3) \land (j_3 \leq \stepiA-1-j_1)$,\\
%
we know: $(\adap(\tr_3) \leq \nnatA) ~(9) \land (\forall x \in
\mbox{Vars}. \ddep{x}(\tr_3) \leq \dmap(x))~(10) \land ((\stepiA -1-j_1- j_3, \valr_3) \in \lrv{\type})~(11)$.\\
%
Apply E-IFT on $(a) (b)$, we get:
\[
  \inferrule{
    \env, \expr_1 \bigstep \etrue, \tr_1 ~ (a) \\
    \env, \expr_3 \bigstep \valr_3, \tr_3 ~ (b)
  }{
    \env, \eif(\expr_1, \expr_2, \expr_3) \bigstep \valr_3, \trift(\tr_1, \tr_3)
  }
\]
Pick $\valr = \valr_3, \tr = \trift(\tr_1, \tr_3), j =j_1+ j_3+1$,  s.t. $
\env, \eif(\expr_1, \expr_2, \expr_3) \bigstep \valr, \tr \land j =
|tr| \land j = j_1 + j_3+1 \leq k$.\\
 STS the following 3 goals:\\
%
1. $\adap(\tr) = \adap(\trift(\tr_1, \tr_3)) = \adap(\tr_1) +
\adap(\tr_3)) \leq \nnatA_1 + \nnatA = \nnatA'$  proved by $(4),(9)$.\\
%
2. $\forall x \in \mbox{Vars}. \ddep{x}(\tr) = \max(\ddep{x}(\tr_1), \adap(\tr_1) +
\ddep{x}(\tr_3)) \leq \max(\dmap_1(x), \nnatA_1(x) + \dmap(x)) =
\dmap'(x) $ proved by $(5),(10)$.\\
%
3. $(\stepiA - j, \valr) = (\stepiA -1 - j_1-j_3, \valr_3) \in
\lrv{\type} $ proved by $(11)$.\\



\noindent {\bf case}
\[
    \inferrule*[right = FST]{
      \Gamma; \dmap \tvdash{\nnatA} \expr: \type_1 \times \type_2
    }{
      \Gamma; \dmap \tvdash{\nnatA} \eprojl(\expr): \type_1
    }
\]
Assume $(\stepiA, \env) \in \lrv{\Gamma}$, TS: $(\stepiA, (\env, \eprojl(\expr))) \in \lre{\dmap}{\nnatA}{\type_1} $.\\
%
Unfold, pick any $ \valr, \tr, j. (\env, \eprojl(\expr)   \bigstep \valr, \tr) \land (\size{\tr} = j) \land (j \leq \stepiA) $,\\
%
STS: $ (\adap(\tr) \leq \nnatA) \land (\forall x \in \mbox{Vars}. \ddep{x}(\tr) \leq \dmap(x)) \land (\stepiA - j, \valr) \in \lrv{\type_1} $.\\
%
By induction hypothesis, we get: $(\stepiA-1, (\env, \expr)) \in \lre{\dmap}{\nnatA}{\type_1 \times \type_2} ~(1)$.\\
%
Inversion on $(1)$, $\forall \valr', \tr', j'. (\env, \expr \bigstep \valr', \tr') \land (\size{\tr'} = j') \land (j' \leq \stepiA-1) $,\\
%
We know: $(\adap(\tr') \leq \nnatA) ~ (a) 
\land (\forall x \in \mbox{Vars}. \ddep{x}(\tr') \leq \dmap(x)) ~ (b)
\land ((\stepiA -1 - j', \valr') \in \lrv{\type_1 \times \type_2}) ~ (c)$.\\
%
Pick any $\valr_1, \valr_2$, $\valr' = (\valr_1, \valr_2)$,
% Let $\expr = (\expr_1, \expr_2)$, by E-PAIR, we have:\\
% %
% $\tr' = (\tr_1, \tr_2), \valr' = (\valr_1, \valr_2), j' = \size{\tr'} = \size{\tr_1} + \size{\tr_2} = j_1 + j_2$.\\
%
inversion on $(c)$, we have:\\
%
$(\stepiA - j', \valr_1) \in \lrv{\type_1}~(d) \land (\stepiA - j', \valr_2) \in \lrv{\type_2}$.\\
%
By E-FST, pick $\valr = \valr_1, j = j'+1, \tr = \trprojl(\tr')$, STS:\\
%
1. $\adap(\tr) = \adap(\trprojl(\tr')) = \adap(\tr') \leq \nnatA$ by $(a)$.\\
%
2. $\forall x .\ddep{x}(\tr) \implies \forall x . \ddep{x}(\tr') \leq \dmap(x)$ by $(b)$.\\
%
3. $(\stepiA - j, \valr) = (\stepiA -1- j', \valr_2) \in
\lrv{\type_1}$ by $(d)$.
\\




\noindent {\bf case}
\[
    \inferrule*[right = SND]{
      \Gamma; \dmap \tvdash{\nnatA} \expr: \type_1 \times \type_2
    }{
      \Gamma; \dmap \tvdash{\nnatA} \eprojr(\expr): \type_2
    }
\]
Assume $(\stepiA, \env) \in \lrv{\Gamma}$, TS: $(\stepiA, (\env, \eprojr(\expr))) \in \lre{\dmap}{\nnatA}{\type_2} $.\\
%
Unfold, pick any $ \valr, \tr, j. (\env, \eprojr(\expr) \bigstep \valr, \tr) \land (\size{\tr} = j) \land (j \leq \stepiA) $,\\
%
STS: $ (\adap(\tr) \leq \nnatA) \land (\forall x \in \mbox{Vars}. \ddep{x}(\tr) \leq \dmap(x)) \land (\stepiA - j, \valr) \in \lrv{\type_1} $.\\
%
By induction hypothesis, we get: $(\stepiA-1, (\env, \expr)) \in \lre{\dmap}{\nnatA}{\type_1 \times \type_2} ~(1)$.\\
%
Inversion on $(1)$, $\forall \valr', \tr', j'. (\env, \expr \bigstep \valr', \tr') \land (\size{\tr'} = j') \land (j' \leq \stepiA-1) $,\\
%
We know: $(\adap(\tr') \leq \nnatA) ~ (a) 
\land (\forall x \in \ddep{x}(\tr') \leq \dmap(x)) ~ (b)
\land ((\stepiA -1- j', \valr') \in \lrv{\type_1 \times \type_2}) ~ (c)$.\\
%
Pick any $\valr_1, \valr_2$, $\valr' = (\valr_1, \valr_2)$,
% Let $\expr = (\expr_1, \expr_2)$, by E-PAIR, we have:\\
% %
% $\tr' = (\tr_1, \tr_2), \valr' = (\valr_1, \valr_2), j' = \size{\tr'} = \size{\tr_1} + \size{\tr_2} = j_1 + j_2$.\\
%
inversion on $(c)$, we have:\\
%
$(\stepiA - j', \valr_1) \in \lrv{\type_1}~(d) \land (\stepiA - j', \valr_2) \in \lrv{\type_2}~(e)$.\\
%
By E-SND, pick $\valr = \valr_2, j = j'+1, \tr = \trprojr(\tr')$, STS:\\
%
1. $\adap(\tr) = \adap(\trprojr(\tr')) = \adap(\tr') \leq \nnatA$ by $(a)$\\
%
2. $\forall x \in \mbox{Vars} .\ddep{x}(\tr) \implies \forall x . \ddep{x}(\tr') \leq
\dmap(x)$ proved by $(b)$.\\
%
3. $(\stepiA - j, \valr) = (\stepiA -1 - j', \valr_2) \in \lrv{\type_2}$
proved by $(e)$.\\


\noindent {\bf case}
\[
    \inferrule*[right = TRUE]{
    }{
      \Gamma; \dmap \tvdash{\nnatA} \etrue: \tbool
    }
\]
Assume $ (\stepiA, \env) \in \lrv{\tbool} $, TS: $(\stepiA, (\env, \etrue)) \in \lre{\dmap}{\nnatA}{\tbool}$.\\
%
By inversion, STS: $\forall \valr, \tr, j. (\env, \etrue \bigstep \valr, \tr) \land (\size{\tr} = j) \land (j \leq \stepiA) $\\
$\Rightarrow$ 
$ (\adap(\tr) \leq \nnatA) ~ (a) 
\land (\forall x \in \mbox{Vars}. \ddep{x}(\tr) \leq \dmap(x)) ~ (b)
\land (\stepiA - j, \valr) \in \lrv{\tbool} ~ (c)$\\
%
By E-TRUE, let $\valr = \etrue$, $\tr = \etrue$ and $j = \size{\etrue} = 0$.\\
%
The following 3 items are proved:\\
%
1. $\adap(\tr) = 0 \leq \nnatA$.\\
2. $\forall x \in \mbox{Vars}. \ddep{x}(\etrue) = 0 \leq \dmap(x)$\\
3. $(\stepiA - j, \valr) = (\stepiA, \etrue) \in \lrv{\tbool}$.\\



\noindent {\bf case}
\[
    \inferrule*[right = FALSE]{
    }{
      \Gamma; \dmap \tvdash{\nnatA} \efalse: \tbool
    }
\]
Assume $ (\stepiA, \env) \in \lrv{\tbool} $, TS: $(\stepiA, (\env, \efalse)) \in \lre{\dmap}{\nnatA}{\tbool}$.\\
%
By inversion, STS: $\forall \valr, \tr, j. (\env, \efalse \bigstep \valr, \tr) \land (\size{\tr} = j) \land (j \leq \stepiA) $\\
$\Rightarrow$ 
$ (\adap(\tr) \leq \nnatA) ~ (a) 
\land (\forall x \in  \mbox{Vars}. \ddep{x}(\tr) \leq \dmap(x)) ~ (b)
\land (\stepiA - j, \valr) \in \lrv{\tbool} ~ (c)$\\
%
By E-TRUE, let $\valr = \efalse$, $\tr = \efalse$ and $j = \size{\efalse} = 0$.\\
%
The following 3 items are proved:\\
%
1. $\adap(\tr) = 0 \leq \nnatA$.\\
2. $\forall x \in \mbox{Vars}. \ddep{x}(\efalse) = 0 \leq \dmap(x)$\\
3. $(\stepiA - j, \valr) = (\stepiA, \efalse) \in \lrv{\tbool}$.\\


\noindent {\bf case}
\[
    \inferrule*[right = PRIMITIVE]{
      \Gamma; \dmap \tvdash{\nnatA} \expr: \tbase ~ (\star) \\
      \nnatA' = 1 + \nnatA \\
      \dmap' = 1 + \dmap
    }{
      \Gamma; \dmap' \tvdash{\nnatA'} \eop(\expr): \tbool
    }
\]
Assume $(\stepiA, \env) \in \lrv{\Gamma}$, TS: $(\stepiA, (\eop(\expr), \env)) \in \lre{\dmap'}{\nnatA'}{\tbool}$.\\
%
Unfold, $\forall \valr, \tr, j. (\env, \eop(\expr) \bigstep \valr, \tr) \land (\size{\tr} = j) \land (j \leq \stepiA)$.\\
%
STS: $(\adap(\tr) \leq \nnatA') \land (\forall x \in \mbox{Vars}. \ddep{x}(\tr) \leq \dmap'(x)) \land ((\stepiA - j, \valr) \in \lrv{\tbool})$.\\
%
By induction hypothesis on $\star$, we get: $(\stepiA-1, (\expr, \env)) \in \lre{\dmap}{\nnatA}{\tbase} ~ (1)$.\\
%
Inversion on $(1)$, pick $\forall \valr', \tr', j'$. s.t. $ (\env, \expr \bigstep \valr', \tr') \land (\size{\tr'} = j') \land (j' \leq \stepiA-1)$.\\
%
We know: $(\adap(\tr') \leq \nnatA) ~ (a)
\land (\forall x \in \ddep{x}(\tr') \leq \dmap(x)) ~ (b)
\land ((\stepiA -1- j', \valr') \in \lrv{\tbase}) ~ (c)$.\\
%
Pick $\valr = \eop(\valr')$, then by E-PRIMITIVE, we have $\env, \eop(\expr) \bigstep \valr, \eop(\tr')$.\\
%
Pick $\tr = \eop(\tr'), j = j' + 1$ s.t.  $j \leq k$, STS:\\
%
1. $\adap(\tr) = \adap(\eop(\tr')) = 1 + \adap(\tr') \leq 1 + \nnatA = \nnatA'$ proved by $(a)$\\
%
2. $\forall x \in \mbox{Vars}. \ddep{x}(\tr) = \ddep{x}(\eop(\tr')) = 1 + \ddep{x}(\tr') \leq 1 + \dmap(x) = \dmap'(x)$ proved by $(b)$\\
%
3. $(\stepiA - j, \valr) = (\stepiA - j' - 1, \eop(\valr')) \in \lrv{\tbool} $.\\
%
By typing rule PRIMITIVE, we have $\eop(\valr'): \tbool$. $\eop(\valr')$ is either $\etrue$ or $\efalse$. So, we have $(\stepiA - j' - 1, \eop(\valr')) \in \lrv{\tbool}$.\\
%



\noindent {\bf case}
\[    
	\inferrule*[right = VAR]{
      \Gamma(x) = \type \\ 0 \leq \dmap(x) \mbox{ or equiv.\ } \dmap(x) \neq \bot
    }{
      \Gamma; \dmap \tvdash{\nnatA} x: \type
    }
\]
Assume $(\stepiA, \env) \in \lrv{\Gamma}$, TS: $(\stepiA, (\env, x)) \in \lre{\dmap}{\nnatA}{\type}$.\\
%
By inversion, STS: $\forall \valr, \tr, j. (\env, x \bigstep \valr, \tr) \land (\size{\tr} = j) \land (j \leq \stepiA) $\\
$\Rightarrow$ 
$ (\adap(\tr) \leq \nnatA) ~ (a) 
\land (\forall x \in \mbox{Vars}. \ddep{x}(\tr) \leq \dmap(x)) ~ (b)
\land (\stepiA - j, \valr) \in \lrv{\type} ~ (c)$\\
%
By E-VAR, pick $\valr = \env(x)$, $\tr = x$, $j = \size{x} = 0$, following 3 items are proved:\\
%
1. $(\adap(\tr) = \adap(x) = 0 \leq \nnatA)$\\
2. $\forall y \in \ddep{y}(x)$, \\
$~~ y = x ~~ \ddep{y}(x) = 0 \leq \dmap(x)$\\
$~~ y \neq x ~~ \ddep{y}(x) = \bot \leq \dmap(y)$\\
3. $(\stepiA - j, \valr) = (\stepiA, \env(x)) \in \lrv{\type}$.\\
$~~$By definition of $(\stepiA, \env) \in \lrv{\Gamma}$, we have: $(\stepiA, \env(x))\in \lrv{\Gamma(x)}$, and $\Gamma(x) = \type$. 


\noindent {\bf case}
\[    
 \inferrule{
     \dmap \wf{\type} \\
    }{
      \Gamma; \dmap \tvdash{\nnatA} \enil: \tlist{\type}
    }
\]
Assume $(\stepiA, \env) \in \lrv{\Gamma}$, TS: $(\stepiA, (\env, \enil)) \in \lre{\dmap}{\nnatA}{\tlist{\type}}$.\\
%
By inversion, STS: $\forall \valr, \tr, j. (\env, \enil \bigstep \valr, \tr) \land (\size{\tr} = j) \land (j \leq \stepiA) $\\
$\Rightarrow$ 
$ (\adap(\tr) \leq \nnatA) ~ (a) 
\land (\forall x \in \mbox{Vars}. \ddep{x}(\tr) \leq \dmap(x)) ~ (b)
\land (\stepiA - j, \valr) \in \lrv{\type} ~ (c)$\\
%
By E-NIL, we know : $ v = \enil $ and $ \tr = \trnil$ and $
\size{\enil} = 0 \leq k$. \\
STS: 
%
1. $(\adap(\tr) = \adap(\enil) = 0 \leq \nnatA)$, because $\nnatA$ is
not negative.\\
2. $\forall x \in \mbox{Vars}. \ddep{x}(\enil)$, $  \ddep{x}(\enil) = \bot \leq
\dmap(x)$ proved from the definition of $\bot$. \\
3. $(\stepiA - 0, \enil) =  \in \lrv{ \tlist{ \type} }$, proved by
inversion of the interpretation of $\lrv{ \tlist{ \type} } $.\\

\noindent{\bf case}
\[
  \inferrule{
   \Gamma; \dmap_1 \tvdash{\nnatA_1} \expr_1 : \type ~(\star) \\
   \Gamma; \dmap_2 \tvdash{\nnatA_2} \expr_2 : \tlist{\type} ~(\diamond)\\
   \dmap' = \max(\dmap_1, \dmap_2) \\
   \nnatA' = \max ( \nnatA_1, \nnatA_2 )
   }
   { \Gamma; \dmap' \tvdash{\nnatA'} \econs(\expr_1, \expr_2) :
     \tlist{\type}  }
\]

Assume $(\stepiA, \env) \in \lrv{\Gamma}$, TS: $(\stepiA, (\env,
\econs(\expr_1 , \expr_2 ) )) \in \lre{\dmap'}{\nnatA'}{\tlist{\type}}$.\\
%
By inversion, STS: $\forall \valr, \tr, j. (\env, \econs(e_1,e_2) \bigstep \valr, \tr) \land (\size{\tr} = j) \land (j \leq \stepiA) $\\
$\Rightarrow$ 
$ (\adap(\tr) \leq \nnatA')  
\land (\forall x \in \mbox{Vars}. \ddep{x}(\tr) \leq \dmap'(x)) 
\land (\stepiA - j, \valr) \in \lrv{\tlist{\type}} $
%

  By ih on $(\star)$, we get: $(\stepiA, (\env,
\expr_1  )) \in \lre{\dmap_1}{\nnatA_1}{\type}~(1)$.\\
%
By inversion, we pick $v_1$, $\tr_1$ and $j_1$ s.t. $\env, \expr_1
\bigstep \valr_1, \tr_1$ and $\size{\tr_1} = j_1$ and $j_1 \leq \stepiA$.\\
%
We know : $ (\adap(\tr_1) \leq \nnatA_1) ~ (2) 
\land (\forall x \in \mbox{Vars}. \ddep{x}(\tr_1) \leq \dmap_1(x)) ~ (3)
\land (\stepiA - j_1, \valr_1) \in \lrv{\type} ~ (4)$.

 By ih on $(\diamond)$ and $(\stepiA-j_1, \env) \in \lrv{\Gamma}$ by Lemma~\ref{lem:downward}, we get: $(\stepiA-j_1, (\env,
\expr_2  )) \in \lre{\dmap_2}{\nnatA_2}{ \tlist{ \type} }~(5)$.\\
%
By inversion, we pick $v_2$, $\tr_2$ and $j_2$,  s.t. $\env, \expr_2
\bigstep \valr_2, \tr_2$ and $\size{\tr_2} = j_2$ and $j_2 \leq
\stepiA-j_1$.\\
%
We know : $ (\adap(\tr_2) \leq \nnatA_2) ~ (6) 
\land (\forall x \in \mbox{Vars}. \ddep{x}(\tr_2) \leq \dmap_2(x)) ~ (7)
\land (\stepiA - j_2, \valr_2) \in \lrv{\tlist{\type}} ~ (8)$.
%
\[
\inferrule{
\env, \expr_1 \bigstep \valr_1, \tr_1 \\
\env, \expr_2 \bigstep \valr_2, \tr_2
}
{ \env, \econs (\expr_1, \expr_2)  \bigstep \econs (\valr_1, \valr_2),
  \trcons(\tr_1, \tr_2)
}
\]
%
By E-Cons, we set : $\valr = \econs(\valr_1, \valr_2)$ and $\tr =
\trcons(\tr_1, \tr_2)$ s.t. $j = \size{\tr}= j_1 + j_2 \leq k$.\\
STS: 
%
1. $(\adap(\tr) = \adap(\trcons(\tr_1, \tr_2)) \leq
\nnatA')$, by $(2)$ and $(6)$.\\
2. $\forall x \in \mbox{Vars}. \ddep{x}(\trcons(\tr_1, \tr_2))
= \max ( \ddep{x}(\tr_1), \ddep{x}(\tr_2) ) \leq
\dmap'(x)$ proved by $(3)$ and $(7)$. \\
3. $(\stepiA - j_1 -j_2, \econs(\valr_1,\valr_2)  )  \in \lrv{ \tlist{
    \type} }$, by inversion of the definition of
$\lrv{\tlist{\type}}$, suffice to show: $(\stepiA-j_1-j_2, \valr_1) \in
 \lrv{\type}$ proved by Lemma~\ref{lem:downward} on $(4)$, $(\stepiA-j_1-j_2, \valr_2) \in
 \lrv{ \tlist{\type}} $ proved by $(8)$.\\


\noindent{\bf case}
\[
 \inferrule{
     \Gamma; \dmap_1 \tvdash{\nnatA_1} \expr_1 : \type_1~(\star) \\
     \Gamma, x:\type_1 ; \dmap_2[x:q] \tvdash{\nnatA_2} \expr_2 :
     \type_2 ~(\diamond)\\
     \dmap' = \max( \dmap_2, \dmap_1 + q ) \\
     \nnatA' = \max ( \nnatA_2, \nnatA_1 + q )
   }
   {  \Gamma; \dmap' \tvdash{\nnatA'}  \elet x = \expr_1 \ein \expr_2 : \type}
\]
Assume $(\stepiA, \env) \in \lrv{\Gamma}$, TS: $(\stepiA, (\env,
\elet x = \expr_1 \ein \expr_2 )) \in \lre{\dmap'}{\nnatA'}{\type}$.\\
%
By inversion, STS: $\forall \valr, \tr, j. (\env, \elet x = \expr_1 \ein \expr_2 \bigstep \valr, \tr) \land (\size{\tr} = j) \land (j \leq \stepiA) $\\
$\Rightarrow$ 
$ (\adap(\tr) \leq \nnatA')  
\land (\forall x \in \mbox{Vars}. \ddep{x}(\tr) \leq \dmap'(x)) 
\land (\stepiA - j, \valr) \in \lrv{\type} $
%

By ih on $(\star)$, we get: $(\stepiA, (\env,
\expr_1  )) \in \lre{\dmap_1}{\nnatA_1}{\type_1}~(1)$.\\
%
By inversion, we pick $v_1$, $\tr_1$ and $j_1$ s.t. $\env, \expr_1
\bigstep \valr_1, \tr_1$ and $\size{\tr_1} = j_1$ and $j_1 \leq \stepiA$.\\
%
We know : $ (\adap(\tr_1) \leq \nnatA_1) ~ (2) 
\land (\forall x \in \mbox{Vars}. \ddep{x}(\tr_1) \leq \dmap_1(x)) ~ (3)
\land (\stepiA - j_1, \valr_1) \in \lrv{\type_1} ~ (4)$.
%
From the assumption  $(\stepiA, \env) \in \lrv{\Gamma}$, by
Lemma~\ref{lem:downward}, we get : $(\stepiA-j_1, \env) \in
\lrv{\Gamma}~(5)$. \\
Set $\env' = \env[x \mapsto \valr_1]$, we know $(\stepiA-j_1, \env')
\in \lrv{\Gamma,x:\type_1} ~(6) $ by $(4)$ and $(5)$.
%

By ih on $(\diamond)$ and $(6)$, we know: $(\stepiA-j_1, (\env',
\expr_2  )) \in \lre{\dmap_2[x:q]}{\nnatA_2}{\type} ~(7) $.\\
%
By inversion $(7)$, we pick $v_2$, $\tr_2$ and $j_2$ s.t. $\env', \expr_2
\bigstep \valr_2, \tr_2$ and $\size{\tr_2} = j_2$ and $j_2 \leq
\stepiA - j_1$.\\
%
We know:  $ (\adap(\tr_2) \leq \nnatA_2) ~ (8) 
\land (\forall x \in \mbox{Vars}. \ddep{x}(\tr_2) \leq \dmap_2[x:q](x)) ~ (9)
\land (\stepiA - j_1 - j_2, \valr_2) \in \lrv{\type} ~ (10)$.
%
\[
\inferrule{
  \env, \expr_1 \bigstep \valr_1, \tr_1 \\
  \env[x \mapsto \valr_1] , \expr_2 \bigstep \valr_2, \tr_2
}
{\env, \elet x;q = \expr_1 \ein \expr_2 \bigstep \valr_2, \trlet (x,
  \tr_1, \tr_2) }
\]
By E-LET, we know : $\valr = c/valr_2$ and $\tr = \trlet (x,
  \tr_1, \tr_2)  $. s.t. $j = j_1 +j_2 \leq k$.\\
%
STS: 
%
1. $(\adap(\tr) = \adap(\trlet (x,
  \tr_1, \tr_2) ) \leq
\nnatA')$, proved by $(2)$ ,$(8)$and $(9)$.\\
2. $\forall y \in \mbox{Vars}. \ddep{y}(\trlet (x,
  \tr_1, \tr_2)  ) \leq
\dmap'(y)$ proved by $(3)$ and $(9)$. \\
3. $(\stepiA - j_1 -j_2, \valr_2 )  \in \lrv{ 
    \type }$, proved by $(10)$.\\

\end{proof}

\clearpage

\section{Examples}

\begin{algorithm}
\caption{A two-round analyst strategy for random data (Algorithm 4 in ...)}
\label{alg:BitGOF}
\begin{algorithmic}
\REQUIRE Mechanism $\mathcal{M}$ with a hidden state $X\in \{-1,+1\}^{n\times (k+1)}$.
\STATE  {\bf for}\ $j\in [k]$\ {\bf do}.  
\STATE \qquad {\bf define} $q_j(x)=x(j)\cdot x(k)$ where $x\in \{-1,+1\}^{k+1}$.
\STATE \qquad {\bf let} $a_j=\mathcal{M}(q_j)$ 
\STATE \qquad \COMMENT{In the line above, $\mathcal{M}$ computes approx. the exp. value  of $q_j$ over $X$. So, $a_j\in [-1,+1]$.}
\STATE {\bf define} $q_{k+1}(x)=\mathrm{sign}\big (\sum_{i\in [k]} x(i)\times\ln\frac{1+a_i}{1-a_i} \big )$ where $x\in \{-1,+1\}^{k+1}$.
\STATE\COMMENT{In the line above,  $\mathrm{sign}(y)=\left \{ \begin{array}{lr} +1 & \mathrm{if}\ y\geq 0\\ -1 &\mathrm{otherwise} \end{array} \right . $.}
\STATE {\bf let} $a_{k+1}=\mathcal{M}(q_{k+1})$
\STATE\COMMENT{In the line above,  $\mathcal{M}$ computes approx. the exp. value  of $q_{k+1}$ over $X$. So, $a_{k+1}\in [-1,+1]$.}
\RETURN $a_{k+1}$.
\ENSURE $a_{k+1}\in [-1,+1]$
\end{algorithmic}
\end{algorithm}





\newpage

% \[\begin{array}{llll}
% \mbox{Term} & \term & ::= & \return ~ \expr ~|~ \bernoulli ~ \expr ~|~ \uniform ~ \expr
% \end{array}\]

%  \[
% \begin{array}{llll}
%   \mbox{Type} & \type & ::= & \treal ~|~ \tmonad ~ \type
% \end{array}
% \]

% \begin{figure}
%   \begin{mathpar}
%     \inferrule{
%       \Gamma \tvdash{\nnatA} \expr: \type
%     }{
%       \Gamma \tvdash{\nnatA} \return ~ \expr: \tmonad(\type)
%     }
%     %
%     \and
%     %
%     \inferrule{
%       \Gamma \tvdash{\nnatA} \expr: \type
%     }{
%       \Gamma \tvdash{\nnatA} \bernoulli ~ \expr: \tmonad(\type)
%     }
%     %
%     \and
%     %
%     \inferrule{
%       \Gamma \tvdash{\nnatA} \expr: \type
%     }{
%       \Gamma \tvdash{\nnatA} \uniform ~ \expr: \tmonad(\type)
%     }
%     % %
%     % \and
%     % %
%     % \inferrule{
%     % }{
%     %   \Gamma; \dmap_1 \tvdash{\nnatA} \expr_1: \tmonad(\type_1)
%     % }
%     % %
%     % \and
%     % %
%     % \inferrule{
%     % }{
%     %   \Gamma, x: \type_1; \dmap_2 \tvdash{\nnatA} \expr_2: \tmonad(\type_2)
%     % }
%   \end{mathpar}
%   \caption{typing rules - monad}
%   \label{fig:type-rules-monad}
% \end{figure}

% \begin{figure}
% \begin{mathpar}
%   \inferrule{\expr \bigstep \valr}{\return ~ \expr \bigstep^{1} \valr}
%   %
%   \and
%   %
%   \inferrule{\expr \bigstep \valr}{\bernoulli ~ \expr \bigstep^{\frac{1}{2}} \etrue}
%   %
%   \and
%   %
%   \inferrule{\expr \bigstep \valr}{\uniform ~ \expr \bigstep^{\frac{1}{2}} \valr}
% \end{mathpar}
%   \caption{Big-step semantics - monad}
%   \label{fig:big-step-monad}
% \end{figure}

% \begin{figure}
%   \begin{mathpar}
%     \begin{array}{lll}
%       \lr{\type_1 \times \type_2} & = & \lr{\type_1}  \times \lr{\type_2} \\
%       %
%       \lr{\tmonad ~ \type} & = & \tmonad \lr{\type} =  \{ d : \lr{\type} \rightarrow [0,1] \} \\
%       %
%       \lr{\tlist{\type}} & = & \{ \amalg_{\nnatA \in \nat} \lr{\type} \times \dots \times \lr{\type} ~|~ \sum_{x \in \lr{\type}} d(x) = 1 \}\\
%       %
%       \lr{\tarr{\type_1}{\type_2}{\nnatbiA}{\dmap}{\nnatA}} & = &
%       \{(f, \nnatbiA, \dmap, \nnatA ) ~|~ f: \type_1 \rightarrow \type_2, ~ \nnatbiA \in \natbi, \nnatA \in \natbi, \dmap ~ given\} \\
%       %
%       \lr{\Gamma, \dmap \tvdash{\nnatA} \expr: \type} & = & \{ \lr{\Gamma \tvdash{\nnatA} \expr: \type}, \dmap, \nnatA
%       \}
%     \end{array}
%   \end{mathpar}
%   \caption{Logical relation - monad}
%   \label{fig:lr:monad}
% \end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%EXAMPLES---TWO ROUNDS%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\begin{figure}

Two-rounds:

\[
\begin{array}{l}
 \elet \eapp  g = \efix \eapp  f(j). \lambda k.  \\
 \hspace{.2cm} \eif \big (  (j < k)  ,  \\
  \hspace{.8cm} \elet \eapp  a = \eop \eapp  \boxed{( \lambda x. (x \eapp j)\cdot (x \eapp k) )}  \eapp  \ein \\
  \hspace{1.2cm} (a, j) :: (f  \eapp (j+1) \eapp  k) \\
 \hspace{1.2cm} , \eapp  [] \big) \\
  \hspace{.2cm} \ein \\
  \elet \eapp  l = g \eapp  0\eapp  K \eapp  \ein \\
  \elet \eapp   q =  \lambda x. \mathsf{sign} \eapp  (\mathsf{foldl} \eapp  (\lambda acc. \lambda (a,i). \big(acc\eapp + (x \eapp  i) *lg(\frac{1+a}{1-a})  \big) \eapp  0 \eapp  l )) \eapp  \ein \\
  \eop ( q )
\end{array}
\]
\end{figure}


\begin{tabbing}
    $ x: \trow \equiv \tarr{\tbase}{\treal}{0}{[]}{0}$ \\
    $ \cdot: \tbase * \tbase \to \tbase $   \\
    $ g: \tarr{ \tbase }{ \tarr{\tbase}{\tlist{\treal * \tbase}}{1}{[j:1]}{1} }{0}{[]}{0}  $\\
    $ q: \tbox{  (\tarr{ \trow }{ \treal }{0}{[l:0]}{0})     } $\\
    $ \eop : \tbox{  (\tarr{ \trow }{ \treal }{0}{\dmap''}{0})     } \to \treal $\\
    $\mathsf{foldL} : (\treal \to \tlist{(\treal * \tbase)} \to \treal) \to \treal \to \tlist{\tbase * \treal} \to \treal = FL$
\end{tabbing}

\begin{figure}
Type derivation:\\
    $A = \tarr{ \tbase }{ \tarr{\tbase}{\tlist{\treal * \tbase}}{0}{[j:0]}{1} }{\bot}{[]}{0} $, \\
    $FL1 = \treal \to \tlist{\tbase * \treal} \to \treal$, $FL2 = \treal \to \tlist{\treal * \tbase} \to \treal$\\
    $Q_2 = \tbox{  (\tarr{ \trow }{ \treal }{0}{[l:0]}{0})} $,\\
    $Q_1 = \tbox{  (\tarr{ \trow }{ \treal }{0}{[j:0, k:0]}{0})}$\\
    $\Gamma = f: A,  j: \tbase, k: \tbase$; $\Gamma' = \Gamma, a: \treal$; $\Gamma'' = \Gamma, x: \trow$,\\
    $\Delta = g: A, l: \tlist{\treal * \tbase}$; $\Delta' = \Delta, q:Q_2$; $\Delta'' = \Delta, x: \trow$\\

\[
  \inferrule*[ right = LET-B ]
   {
     \inferrule
     {
        \Pi_L \vartriangleright
     }
     {
        \tvdash{1} \efix \eapp  f(j). \cdots : A
      }
     \and
     \inferrule
     {
        \Pi_R \vartriangleright
     }
     {
      g: A, [g : 1] \tvdash{2} \elet l = \cdots \ein \elet q = \cdots \ein \eop ( q ) : \treal
    }
     \\
     n' = \max(n_1 + 1, n_2 ) = 2
     \and
     [] = \max([] + 1, [])
   }
   { \tvdash{2} \elet g = \cdots \ein \elet l = \cdots \ein \cdots :  \treal }
\]

Derivation $\Pi_L$ and $\Pi_R$ are shown as follows:\\
$\Pi_L$:
\begin{mathpar}
      \inferrule*[right = FIX]
      {
        \inferrule*[right = FIX]
        {
          \inferrule*[right = IF]
          {
            \inferrule*[right = BOOL]
            {
              \empty
            }
            {
              \Gamma; \dmap_1' = [j:0, k:0] \tvdash{0} {j<k : \tbool}
            }
            \\
            \inferrule*[right = LET]
            {
              \dots
            }
            {
              \Gamma; \dmap_2' \tvdash{1} \elet a = \eop ( \cdots ) \ein (a, j) :: \cdots : \tlist{\treal * \tbase}
            }
            \\
            \inferrule*[right = NIL]
            {
              \empty
            }
            {
              \Gamma; \dmap_2'=[f: \infty, j: 0, k: 0] \tvdash{1} {[] : \tlist{\treal * \tbase}}
            }
            \\
            \nnatA' = \nnatA_0 + \nnatA_1 = 0 + 1 = 1
            \and
            \dmap_1' = \max(\dmap_2' + 0 , \dmap_1') = [f: \infty, j: 0, k: 0]
          }
          {
            \Gamma ;  [f: \infty, j: 0, k: 0] 
            \tvdash{1} \eif \cdots : \tlist{\treal * \tbase}
          }
        }
        {
          f: A, j : \tbase; [f: \infty, j: \bot ] \tvdash{1} {\lambda k. \eif \cdots : \tarr{\tbase}{\tlist{\treal * \tbase}}{0}{[j:0]}{1} }
        }
      }
      {
        \tvdash{1} \efix \eapp  f(j). \cdots : A 
      }    
    
    \inferrule*[right = LET]
    {
    \inferrule
        {
         \inferrule
            {
                \Pi_{L1} \vartriangleright
            }
            {
                \Gamma; \dmap_4' \tvdash{0} \lambda x. (x \eapp j)\cdot (x \eapp k) : Q_1
            \\\\
            \dmap_4' = [j: \bot, k : \bot]
            }
        }
        {
            \Gamma; \dmap_3' \tvdash{1} \eop ( \lambda x. (x \eapp j)\cdot (x \eapp k)) : \treal
        }
    \and 
    \inferrule
        {
        \inferrule
            {
              \inferrule*[right = VAR]
              {
                \empty
              }
              {
                \Gamma'; [a:0] \tvdash{0} a: \treal
              }
              \and
              \inferrule*[right = VAR]
              {
                \empty
              }
              {
                \Gamma'; [j:0] \tvdash{0} j : \tbase
              }
            }
            {
                \Gamma'; [a:0, j:0] \tvdash{0} (a, j) : \treal * \tbase
            }
            \\
        \inferrule*[right = APP]
            {
                \Pi_{L2} \vartriangleright
            }
            {
                \Gamma'; \dmap_5' \tvdash{1} f \eapp  j+1 \eapp  k : \tlist{\treal * \tbase}
            }
            \\
            \nnatA' = \max(\nnatA_1, \nnatA_2) = 1
            \and
            \dmap_5' = [f: \infty, a: 0, j : 0, k : 0]
        }
        {
            \Gamma'; \dmap_2'[a: 0] \tvdash{1} 
            (a, j) ::(\cdots) : \tlist{\treal * \tbase}
        }
      \\
      \dmap_3' = [j: \bot, k: \bot]
      \and
      \nnatA' = \max(\nnatA_2, \nnatA_1 + q) = 1
      \and
      \dmap_2' = \max(\dmap_3' + 1, \dmap_2') = [j:0, k:0, f:\infty]
    }
    {
      \Gamma; \dmap_2'  \tvdash{1} 
      \elet a = \eop (\lambda x. (x \eapp j)\cdot (x \eapp k)) \ein (a, j) ::(f \eapp  j+1 \eapp  k): \tlist{\treal * \tbase}
    }
    \end{mathpar}
\end{figure}


\begin{figure}
$\Pi_{L2}$:
\begin{mathpar}

    \inferrule*[right = APP]
    {
      \inferrule*[right = APP]
      {
      \inferrule*[right = VAR]
      {
      \empty
      }
      {
      \Gamma'; [f:\infty] \tvdash{0} f: A
      }
      \and
       \inferrule*[right = VAR]
      {
      \empty
      }
      {
      \Gamma'; [j:0] \tvdash{0} j + 1: \tbase
      }
      \\
      \nnatA' = \max(\nnatA_2 + q, \nnatA) + \nnatA_1 = 0 
      }
      {
      \Gamma'; \dmap_6' \tvdash{0} f \eapp j+1 : \tarr{\tbase}{\tlist{\treal * \tbase}}{0}{\dmap = [j:0]}{1}
      }
      \and
      \inferrule*[right = VAR]
      {
      \empty
      }
      {
      \Gamma'; \dmap_7' \tvdash{0} k : \tbase
      }
      \\
      \dmap_6' = [j:0, f: \infty, a : 0]
      \and
      \dmap_5' = \max(\dmap_6', 0 + \max(\dmap, \dmap_7' + 0))
      \and
      \dmap_7' = [k:0]
      \\\\
      \nnatA' = \nnatA_1 + \max(\nnatA, \nnatA_2 + q) = 1
    }
    {
    \Gamma'; \dmap_5' = [f: \infty, a: 0, j : 0, k : 0] \tvdash{1} f \eapp  j+1 \eapp  k : \tlist{\treal * \tbase}
    }
    \end{mathpar}
\end{figure}



\begin{figure}
$\Pi_{L1}$:
\begin{mathpar}
\inferrule
{
  \inferrule
  {
    \inferrule
    {
      \inferrule
      {
        \inferrule
        {
        \empty
        }
        {
          \Gamma''; [x:0] \tvdash{0} x: \trow
        }
        \and
        \inferrule
        {
          \empty
        }
        {
          \Gamma''; [j:0] \tvdash{0} j : \tbase
        }
      }
      {
        \Gamma''; [x: 0, j:0] \tvdash{0} (x \eapp j) : \treal
      }
      \and
       \inferrule
      {
        \inferrule
        {
        \empty
        }
        {
          \Gamma''; [x:0] \tvdash{0} x: \trow
        }
        \and
        \inferrule
        {
          \empty
        }
        {
          \Gamma''; [k:0] \tvdash{0} k : \tbase
        }
      }
      {
        \Gamma''; [x : 0, k : 0] \tvdash{0} (x \eapp k) : \treal
      }
    }
    {    
      \Gamma''; [x:0, j : 0, k: 0] \tvdash{0} (x \eapp j) \cdot (x \eapp k) : \treal
    }  
  }
  {
    \Gamma; \dmap_4' \tvdash{0} \lambda x. (x \eapp j)\cdot (x \eapp k) : \tarr{\trow}{\treal}{0}{[j:0,k:0]}{0}
  }
}
{
  \Gamma; \dmap_4' \tvdash{0} \lambda x. (x \eapp j)\cdot (x \eapp k) : Q_1
}
\end{mathpar}
\end{figure}


\begin{figure}
$\Pi_R$:
\begin{mathpar}
\inferrule*[right = LET]
    {
    \inferrule
    {
      \inferrule
      {
        \inferrule
        {
          \empty
        }
        {
            g: A ; [g: 0] \tvdash{0} {g : A }
        }
        \and
        \inferrule
        {
          \empty
        }
        {
          g: A; \tvdash{0} 0 : \tbase
        }
      }
      {
         g: A; [g: 0] \tvdash{0} {g \eapp  0  : \tarr{\tbase}{ \tlist{\treal * \tbase}}{1}{[j:1]}{1} }
      }
      \and
      \inferrule
      {
      \empty
      }
      {
        g: A; \tvdash{0} K : \tbase
      }
    }
    {
        g: A; [g:0] \tvdash{1} { g \eapp  0 \eapp  K : \tlist{\treal * \tbase}}
    }
    \and
    \cdots
    \\
    \nnatA' = \max(\nnatA_1 + q, \nnatA_2) = 2
    \and
    [g:1] = \max(([g:0] + 1), [g:1])
    }
    {
    g: A; [g:1] \tvdash{2} \elet l = \cdots \ein \elet q = \cdots \ein \eop ( q ) : \treal   
    }

    \inferrule*[right = LET]
        {
        \inferrule
            {
            \inferrule
            {
              \inferrule
                  {
                    \cdots
                  }
                  {
                      \Delta''; [x: 0,l: 0] \tvdash{0} {\mathsf{sign}(\dots) :  \treal}
                  }          
            }
            {
                \Delta; \dmap_3''\tvdash{0} {\lambda x. \dots : \tarr{\trow}{\treal}{0}{[l:0]}{0} }
            }
            }
            {
                \Delta; \dmap_3'' = [l:\bot]\tvdash{0} {\lambda x. \dots : Q_1}
            }
        \and
        \inferrule
          {
          \inferrule
              {
                  \empty
              }
              {
                  \Delta'; [g:0, l:0, q: 0] \tvdash{0} { q : Q_2}
              }
          }
          {
                  \Delta'; \dmap_2'' = \dmap_1''[q:1] \tvdash{1} {\eop (q) : \treal}
          }
          \\
          \nnatA' = \max(\nnatA_1 + q, \nnatA_2) = 1
          \\
          \dmap_1'' = \max([l:\bot] + 1, \dmap_2'')
        }
        {
            \Delta; \dmap_1'' = [g:1, l:1]  \tvdash{1} \elet q = \cdots \ein \cdots : \treal
        }

\inferrule
{
  \inferrule
  {
    \empty
  }
  {
    \Delta, x: \trow;  \tvdash{0} \mathsf{sign} :  \treal \to \treal
  }
  \and
  \inferrule
  {
    \inferrule
    {
    \cdots
    }
    {
      \Delta''; [x:0] \tvdash{0} \mathsf{foldl}(\cdots) \eapp 0 : \tlist{\tbase * \treal} \to \treal
    }
    \\
    \inferrule
    {
      \empty
    }
    {
      \Delta''; [l:0] \tvdash{0} l : \tlist{\tbase * \treal}
    }
  }
  {
    \Delta''; \dmap_4'' \tvdash{0} \mathsf{foldl}(\cdots) \eapp 0 \eapp l : \treal 
  }
}
{
  \Delta''; \dmap_4'' = [x: 0, l:0] \tvdash{0} \mathsf{sign}(\dots) :  \treal
}

\inferrule
{
  \inferrule
  {
    \inferrule
    {
      \empty
    }
    {
      \Delta'';  \tvdash{0} \mathsf{foldl} : FL
    }
    \and
    \inferrule
    {
      \cdots
    }
    {
      \Delta''; [x : 0] \tvdash{0} \lambda acc. \cdots : FL2
    }
  }
  {
    \Delta''; [x : 0] \tvdash{0} \mathsf{foldl}(\cdots) :FL1 
  }
  \and
  \inferrule
  {
    \empty
  }
  {
    \Delta''; \tvdash{0} 0 : \tbase
  }
}
{
  \Delta''; [x : 0] \tvdash{0} \mathsf{foldl}(\cdots) \eapp 0 : \tlist{\tbase * \treal} \to \treal
}

\inferrule
{
  \inferrule
  {
    \inferrule
    {
      \inferrule
      {\empty
      }
      {
        \Delta_2''; \dmap_6'' \tvdash{0} acc: \treal
        \\\\
        \dmap_6'' = [acc:0]
      }
      \and
      \inferrule
      {
        \inferrule
        {
          \inferrule
          {
          \empty
          }
          {
            \Delta_2''; [x:0] \tvdash{0} x : \trow
          }
          \\
          \inferrule
          {
            \empty
          }
          {
            \Delta_2''; [i:0] \tvdash{0} i : \tbase
          }
        }
        {
          \Delta_2''; [x:0, i:0] \tvdash{0} x \eapp i: \treal
        }
        \and
        \inferrule
        {
          \empty
        }
        {
          \Delta_2''; [a:0] \tvdash{0} \mathsf{lg}(\cdot): \treal
        }
      }
      {
        \Delta_2''; [x:0, (a, i):0] \tvdash{0} (x\eapp i) * \cdots: \treal
      }
    }
    {
      \Delta_2''; \dmap_5''[(a,i):0] \tvdash{0} acc + \cdots : \treal
      \\
      \Delta_2'' = \Delta_1'', (a,i): \tlist{\treal * \tbase}
    }
  }
  {
    \Delta_1''; \dmap_5'' = [x : 0, acc : 0] \tvdash{0} \lambda (a,i). \cdots :  \to \treal
    \and
    \Delta_1'' = \Delta'', acc: \treal
  }
}
{
  \Delta''; [x : 0] \tvdash{0} \lambda acc. \cdots : FL2
}
\end{mathpar}
\vspace{-0.5cm}
\caption{Type Derivation of Two Round Example}
\end{figure}


\clearpage

\begin{algorithm}
\footnotesize
\caption{A multi-round analyst strategy for random data (Algorithm 5 in ...)}
\label{alg:multiRound}
\begin{algorithmic}
\REQUIRE Mechanism $\mathcal{M}$ with a hidden state $X\in [N]^{n}$ sampled u.a.r., control set size $c$
\STATE Define control dataset $C = \{0,1, \cdots, c - 1\}$
\STATE Initialize $Nscore(i) = 0$ for $i \in [N]$, $I = \emptyset$ and $Cscore(C(i)) = 0$ for $i \in [c]$
\STATE  {\bf for}\ $j\in [k]$\ {\bf do} 
\STATE \qquad {\bf let} $p=\uniform(0,1)$ 
\STATE \qquad {\bf define} $q (x) = \bernoulli ( p )$ .
\STATE \qquad {\bf define} $qc (x) = \bernoulli ( p )$ .
\STATE \qquad {\bf let} $a = \mathcal{M}(q)$ 
\STATE \qquad {\bf for}\ $i \in [N]$\ {\bf do}
\STATE \qquad \qquad $Nscore(i) = Nscore(i) + (a - p)*(q (i) - p)$ if $i \notin I$
\STATE \qquad {\bf for}\ $i \in [c]$\ {\bf do}
\STATE \qquad \qquad $Cscore(C(i)) = Cscore(C(i)) + (a - p)*(qc (i) - p)$
\STATE \qquad {\bf let} $I = \{i | i\in [N] \land Nscore(i) > \max(Cscore)\}$
\STATE \qquad {\bf let} $X = X \setminus I$
\RETURN $X$.
% \ENSURE 
\end{algorithmic}
\end{algorithm}


\clearpage

\begin{figure}


Multi-rounds:
\[
\begin{array}{l}
 \efix \eapp  \mathsf{multiRound}(\_). \Lambda k. \Lambda j. \lambda k. \lambda j. \lambda sc. \lambda scc. \lambda
  I.   \lambda N. \lambda C. \lambda D.\\
 \hspace{.2cm} \eif   \big (   (j < k)  ,  \\
  \hspace{.2cm} \elet \eapp p = \uniform \eapp 0 \eapp 1 \ein \\
  \hspace{0.4cm} \elet \eapp q = \lambda x. \bernoulli \eapp p \ein \\
 \hspace{0.4cm} \elet \eapp qc = \lambda c. \bernoulli \eapp p \ein \\
 \hspace{0.4cm} \elet \eapp a = \eop (q)  \ein \\
 \hspace{0.8cm} \elet \eapp sc' =  \mathsf{updtSC} \eapp () \eapp sc  \eapp a \eapp p
 \eapp q \eapp I \eapp  \eapp 0 \eapp  N
  \eapp  \ein \\
\hspace{0.8cm} \elet \eapp scc' =  \mathsf{updtSCC} \eapp () \eapp scc \eapp a \eapp p
 \eapp qc \eapp  \eapp 0 \eapp  C \ein \\
\hspace{0.8cm} \elet \eapp maxScc =  \mathsf{foldl} \eapp (\lambda acc. \lambda a. \eif ( acc < a, a, acc)) \eapp 0 \eapp scc' \ein \\
\hspace{0.8cm} \elet \eapp I' =  \mathsf{updtI}  \eapp () \eapp maxScc \eapp sc
  \eapp 0 \eapp N  \ein \\
  \hspace{0.8cm} \elet \eapp D' =  D \setminus I' \ein \\
  \hspace{1.2cm} \mathsf{multiRound} () [k] [j+1] \eapp  k \eapp (j+1)  \eapp sc' \eapp scc' \eapp I'
  \eapp N \eapp C \eapp D'\\ 
\hspace{0.2cm}   ,     D  \big ) \\
 
\end{array}
\]

UpdtSC
\[
\begin{array}{l}
 \mathsf{updtSC} = \efix \eapp  \mathsf{f}(\_). \lambda sc. \lambda a. \lambda
  p. \lambda q.  \lambda I. \lambda i. \lambda N. \\
 \hspace{.2cm} \eif   \Big (   (i < N)  ,  \\
 \hspace{0.4cm}  \eif \big( ( i \eapp \mathsf{in} I  ) ,       \\
 \hspace{0.8cm} \elet \eapp x =( \mathsf{nth} \eapp sc \eapp i) + (a-p)*(q
  \eapp i - p)  \ein \\
 \hspace{0.8cm} \elet \eapp sc' =  \mathsf{updt} \eapp sc \eapp i
  \eapp x \ein \\
  \hspace{1.2cm} \mathsf{f}  \eapp () \eapp sc' \eapp a \eapp p
 \eapp q \eapp I \eapp  \eapp (i+1) \eapp  N  \\ 
\hspace{0.4cm}  ,  \mathsf{f}  \eapp () \eapp sc \eapp a \eapp p
 \eapp q \eapp I \eapp  \eapp (i+1) \eapp  N \big )  \\ 
\hspace{0.2cm}   ,  sc  \Big ) \\
 
\end{array}
\]
UpdtSCC
\[
\begin{array}{l}
 \mathsf{updtSCC} = \efix \eapp  \mathsf{f}(\_). \lambda scc. \lambda a. \lambda
  p. \lambda qc.  \lambda i. \lambda C. \\
 \hspace{.2cm} \eif   \Big (   (i < C)  ,  \\
 \hspace{0.8cm} \elet \eapp x =( \mathsf{nth} \eapp scc \eapp i) + (a-p)*(qc
  \eapp i - p)  \ein \\
 \hspace{0.8cm} \elet \eapp scc' =  \mathsf{updt} \eapp scc \eapp i
  \eapp x \ein \\
  \hspace{1.2cm} \mathsf{f}  \eapp () \eapp scc' \eapp a \eapp p
 \eapp qc   \eapp (i+1) \eapp  C  \\ 
\hspace{0.2cm}   ,  scc  \Big ) \\
\end{array}
\]
UpdtI
\[
\begin{array}{l}
 \mathsf{updtI} = \efix \eapp  \mathsf{f}(\_). \lambda maxScc. \lambda sc. \lambda
  i. \lambda N. \\
 \hspace{.2cm} \eif   \Big (   (i < N)  ,  \\
\hspace{0.4cm}  \eif \big( ( ( \mathsf{nth} \eapp scc \eapp i)  >  maxScc  ) ,       \\
 \hspace{0.8cm}   i :: ( \mathsf{f}  \eapp () \eapp maxScc \eapp sc
  \eapp (i+1) \eapp N  )\\
 \hspace{0.8cm} , \mathsf{f}  \eapp () \eapp maxScc \eapp sc
  \eapp (i+1) \eapp N  \big )  \\
\hspace{0.2cm}   ,  [] \Big ) \\
\end{array}
\]
\end{figure}




\begin{figure}
UpdtSC:
\begin{mathpar}
      \inferrule*[right = FIX]
      {
        \inferrule*[right = FIX...]
        {
          \inferrule*[right = IF]
          {
            \inferrule*[right = BOOL]
            {
              \empty
            }
            {
             i:\tint , I : \tlist{\tint} , \Gamma \tvdash{0} {i
               <  N : \tbool}
            }
            \\
            \inferrule*[right = IF]
            {
              \dots
            }
            {
              f:., \Gamma; \tvdash{0}  \eif (i \in I)\cdots : \tlist{\treal }
            }
            \and
            \inferrule*[right = VAR]
            {
            }
            {
              f:., sc:. ,\Gamma \tvdash{0} {sc : \tlist{\treal}}
            }
            \\
            \and
          }
          {
          f: ., sc: \tlist{\treal}, a:\tint, i:\tint \dots \Gamma
            \tvdash{0} \eif (i < N)  \cdots : \tlist{\treal}
          }
        }
        {
          f: \tunit \rightarrow \dots
          \tlist{\treal}, \Gamma \tvdash{0} {\lambda
            sc. \dots \lambda N.
            \eif \cdots :  \tlist{\treal} \rightarrow \dots \tlist{\treal}   }
        }
      }
      {
       \Gamma \tvdash{0} \efix \eapp  f( \_ ). \lambda sc. \lambda
        a. \dots \lambda N. \eif \Big ( (i <N), \dots, sc \Big ) : \tunit
        \rightarrow \tlist{\treal} \rightarrow \dots \rightarrow \tlist{\treal} 
      }

   \inferrule*[ right = IF ]
   {
     \inferrule
     {
     }
     {
       \Gamma \tvdash{0}. f \eapp () \eapp sc' \dots \eapp N : \tlist{\treal}
      }
     \and
     \inferrule
     {
     \dots
     }
     {
      \Gamma\tvdash{0}  \elet x = \dots \ein \elet sc' = \dots
      \ein f \eapp () \eapp sc' \dots : \tlist{\treal}
    }
     \\
     i :\tint , I : \tlist{\tint},\Gamma \tvdash{0} i \in I : \tbool
   }
   { \Gamma \tvdash{0}  \eif \big(  (i \in I), \elet x = \dots  ,  f \eapp ()
     \eapp sc \dots N \big) : \tlist{\treal }    }

    
    \inferrule*[right = LET]
    {
    \inferrule*[right = LET]
        {
        \inferrule*[right = APP]
            {
            }
            {
                \Gamma \tvdash{0} \mathsf{updt} \eapp sc \eapp
                i \eapp x : \tlist{\treal}
            }
            \and
        \inferrule*[right = APP]
            {
                \dots
            }
            {
                \Gamma \tvdash{0} f () \eapp sc \dots \eapp  (i+1) \eapp  N : \tlist{\treal }
            }
            \\
            {  }
            \and
            {}
        }
        {
            x: \treal ,\Gamma \tvdash{0} 
             \elet sc' = \mathsf{updt} \eapp sc \eapp i \eapp x \ein \dots : \tlist{\treal}
        }
      \\
      \inferrule
        {
          \dots
        }
        {
            \Gamma \tvdash{0} ( \mathsf{nth} \eapp sc \eapp i  )+ (a-p)*(q \eapp i -
      p) : \treal
        }
    }
    {
      \tvdash{0} 
      \elet x =( \mathsf{nth} \eapp sc \eapp i  )+ (a-p)*(q \eapp i -
      p) \ein \dots: \tlist{\treal }
    }
    \end{mathpar}
\end{figure}


Type derivation of Multi-rounds example:
\[
\begin{array}{ll} 
  \mathsf{multiRound} :& \tunit \to \forall  J,K.
                          \tint[K] \to \tint[J] \to \tlist{\treal} \to \tlist{\treal} \to \tlist{\tint} \\
                        & \to \tint \to \tint \to \tarr{\tlist{\tint}}{\tlist{\tint}}{0}{\dmap}{K - J} \\
  \mathsf{updtSC} : & \tunit \to \tlist{\treal} \to \treal \to \treal \to \tbox{ \tint \to \tint } \\
                    & \to \tlist{\tint} \to \tint[J] \to \tarr{\tint}{\tlist{\treal}}{0}{[\_ : 0]}{0}\\
  \mathsf{updtSCC} : & \tunit \to \tlist{\treal} \to \treal \to \treal \to \tbox{ \tint \to \tint } \\
                    & \to \tint[J] \to \tarr{\tint}{\tlist{\treal}}{0}{[\_ : 0]}{0}\\
  \mathsf{updtI} : & \tunit \to \treal \to \tlist{\treal} \to \tint[J] \to \tarr{\tint}{\tlist{\tint}}{0}{[\_ : 0]}{0}\\
  \mathsf{foldl} : & (\treal \to \treal \to \treal) \to \treal \to \tlist{\treal}\\
  q :              & \tbox{\tint \to \tint}\\
  qc :             & \tbox{\tint \to \tint}\\
\end{array}
\]
$\to$ without annotations is equivalent to $\tarr{}{}{\bot}{\dmap_{\bot}}{0}$ in types of $\mathsf{multiRound}, \mathsf{updtSC}, \mathsf{updtSCC}$ and $ \mathsf{updtI} $ functions, where $\forall x, \dmap_{\bot}(x) = \bot$.

\begin{figure}
Multi-rounds:
\begin{mathpar}
\inferrule*[right = FIX]
{
  \inferrule
  {
    \inferrule*[right = FIX]
    {
      \inferrule*[right = IF]
      {
        \inferrule
        {
          \empty
        }
        {
          \Delta; \Gamma; \dmap_1' = [j : 0, k : 0] \tvdash{0} j<k : \tbool
        }
        \\
        \inferrule
        {
          \cdots
        }
        {
          \Delta; \Gamma; \dmap_1 \tvdash{K - J} \elet p = \cdots \ein \cdots : \tlist{\tint}
        }
        \and
        \inferrule
        {
          \empty
        }
        {
          \Delta; \Gamma; \dmap_1 \tvdash{0} D : \tlist{\tint}
        }
      }
      {
        \Delta; \Gamma_0', sc: \tlist{\treal}, \cdots; \dmap_0 
        \tvdash{K - J} \eif(j<k, \elet p = \cdots \ein \cdots, D) : \tlist{\tint}   
      }
    }
    {
    \Delta; \Gamma_0'; [\mathsf{multiRound}: \infty, () : \bot] \tvdash{0} \lambda k. \cdots : \tint[K] \cdots  
    }
  }
  {
  \Delta; \Gamma_0 , \mathsf{multiRound} : \tunit \to \cdots; [\mathsf{multiRound}: \infty, () : \bot]
  \tvdash{0} \Lambda. \Lambda. \cdots : \forall. \forall. \cdots  
  }
}
{
  \Delta; \Gamma_0; [] \tvdash{0} \efix \, \mathsf{multiRound ()}. \cdots : \tunit \to \cdots
}

\inferrule*[right = LET]
{
  \inferrule
  {
    \inferrule
    {
    \empty
    }
    {
    \tvdash{0} 0: \treal    
    }
    \and
    \inferrule
    {
      \empty
    }
    {
      \tvdash{0} 1: \treal
    }
  }
  {  
    \Gamma; [] \tvdash{0} \uniform \eapp 0 \eapp 1 : \treal
  }  
  \and
  \inferrule
  {
    \cdots
  }
  {
    \Delta; \Gamma, p : \treal; \dmap_2 \tvdash{K - J} \elet q = \lambda x. \cdots \ein \cdots : \tlist{\tint}
  }
}
{
  \Delta; \Gamma; \dmap_1 \tvdash{K - J} \elet p = \cdots \ein \cdots : \tlist{\tint}
}

\inferrule*[right = LET]
{
  \inferrule
  {
    \inferrule
    {
      \inferrule
      {
        \inferrule
        {
          \empty
        }
        {
          \tvdash{0} p : \treal        
        }
      }
      {
        \Gamma_{1}, x: \tint; [x: 0] \tvdash{0} \bernoulli \eapp p : \tint
      }
    }
    { 
      \Gamma_{1}; [] \tvdash{0} \lambda x. \bernoulli \eapp p : \tint \to \tint
    }
  }
  {
    \Gamma_{1}; [] \tvdash{0} \lambda x. \bernoulli \eapp p : \tbox{\cdots}
  }
  \and
  \inferrule
  {
    \inferrule
    {
      \inferrule
      {
        \inferrule
        {
          \inferrule
          {
            \empty
          }
          {
            \Gamma_{3}; [q:0]  \tvdash{0} q : \tbox{\tint \to \tint}
          }
        }
        { 
          \Gamma_{3}; [q:1] \tvdash{1} \eop (q): \treal
        }
        \and
        \Pi_1  \vartriangleright
      }
      {
        \Delta; \Gamma_{3}; \dmap_4 \tvdash{K - J} \elet a = \eop ( q ) \ein \cdots : \tlist{\tint}
      }
    }
    {
      \cdots
    }
  }
  {
    \Delta; \Gamma_1, q: \tbox{\cdots}; \dmap_3 \tvdash{K - J} \elet qc = \lambda x. \cdots : \tlist{\tint}
  }
}
{
  \Delta; \Gamma_{1}; \dmap_2 \tvdash{K - J} \elet q = \lambda x. \bernoulli \eapp p \ein \cdots : \tlist{\tint}
}
\end{mathpar}

$\Pi_1:$
\begin{mathpar}
\inferrule*[right = LET]
{ 
  \inferrule
  {
    \inferrule
    {
      \inferrule
      {
        \empty
      }
      {
        \Gamma_4;\dmap_6 \tvdash{0} \mathsf{updtSC} : \cdots
      }
      \\
      \inferrule
      {
        \empty
      }
      {
        \Gamma_4; \dmap_6 \tvdash{0} () : \tunit
      }
    }
    {
      \cdots
    }
  }
  {
    \Gamma_4; \dmap_6 \tvdash{0} \mathsf{updtSC} \eapp () \eapp sc \cdots : \tlist{\treal}
  }
  \and
  \inferrule
  {
    \inferrule
    {
      \Pi_2 \vartriangleright
    }
    {
      \Delta; \Gamma_7; \dmap_7 \tvdash{K - J - 1} \elet D' = \cdots \ein \cdots : \tlist{\tint}
    }
  }
  {
    \cdots
  }
}
{
  \Delta; \Gamma_3, a: \treal; \dmap_5 \tvdash{K - J - 1} \elet sc' = \mathsf{updtSC} \cdots \ein \cdots : \tlist{\tint}
}
\end{mathpar}


$\Pi_2$:
\begin{mathpar}
\inferrule
  {
    \inferrule
    {
      \inferrule
      {
        \empty
      }
      {
        \Gamma_7 \tvdash{0} D: \tlist{\tint}
      }
      \and
      \inferrule
      {
        \empty
      }
      {
        \Gamma_7 \tvdash{0} I': \tlist{\tint}
      }
    }
    {
      \Gamma_7; \dmap_8 \tvdash{0} D \setminus I' : \tlist{\tint}
    }
    \and
    \inferrule
    {
      \cdots
    }
    {
      \Delta; \Gamma_8; \dmap_8 \tvdash{K - J - 1} \mathsf{multiRound} \cdots : \tlist{\tint}
      \\\\
      \Gamma_8 = \Gamma_7, D' : \tlist{\tint}
    }
  }
  {
    \Delta; \Gamma_7; \dmap_7 \tvdash{K - J - 1} \elet D' = \cdots \ein \cdots : \tlist{\tint}
  }
\end{mathpar}
\end{figure}

\begin{figure}
\begin{mathpar}
    \inferrule
{
  \inferrule
  {  
    \inferrule
    {
      \inferrule
      {
        \Pi_3 \vartriangleright
      }
      {
        \Delta; \Gamma_8; \dmap_8 
        \tvdash{0} \mathsf{multiRound} \eapp () \eapp [ ] [ ] : \tint[k] \to \tint[J + 1] \to \cdots
      }
    }
    {
      \cdots
    }
  }
  {
    \Delta; \Gamma_8; \dmap_8 
    \tvdash{0} \mathsf{multiRound} \eapp () \eapp [ ] [] \cdot : \tarr{\cdot}{\cdot}{0}{\dmap}{K - (J + 1)}
  }
  \and
  \inferrule
  {
  \empty
  }
  {
    \Delta; \Gamma_8; [D':0] \tvdash{0} D' : \tlist{\tint}
  }
}
{
  \Delta; \Gamma_7, D' : \tlist{\tint}; \dmap_8 
  \tvdash{K - J - 1} \mathsf{multiRound} \eapp () \cdots : \tlist{\tint}
}
\end{mathpar}

$\Pi_3$:
\begin{mathpar}
\inferrule
{
  \inferrule
  {
    \inferrule
    {
          \inferrule
      {
        \empty
      }
      {
        \Delta; \Gamma_8; \dmap_8 \tvdash{0} \mathsf{multiRound} : \cdots
      }
      \and
      \inferrule
      {
        \empty
      }
      {
        \Delta; \Gamma_8; \dmap_8 \tvdash{0} () : \tunit
      }
    }
    {
      \Delta; \Gamma_8; \dmap_8 
      \tvdash{0} \mathsf{multiRound} \eapp (): \tint[K] \to \tarr{\cdots}{\cdots}{0}{\dmap}{K - J}
    }
    \and
    \inferrule
    {
      \Delta(K) = S
    }
    {
      \Delta \tvdash{} K :: S
    }
  }
  {
    \Delta; \Gamma_8; \dmap_8 
    \tvdash{0} \mathsf{multiRound} \eapp () \eapp [] : \tint[K] \to \tint[J] \to \tarr{\cdots}{\cdots}{0}{\dmap}{K - J}
  }
  \and
  \inferrule
  {
    \Delta(J) = S
  }
  {
    \Delta \tvdash{} J :: S
  }
}
{
  \Delta; \Gamma_8; \dmap_8 
  \tvdash{0} \mathsf{multiRound} \eapp () \eapp [ ] [ ] : \tint[K] \to \tint[J + 1] \to \cdots \tarr{\cdots}{\cdots}{0}{\dmap}{K - (J + 1)}
}

\end{mathpar}

\end{figure}


The \emph{depth map} in the type derivation of Multi-rounds example:
\[
\begin{array}{lll}
\dmap     & = & [sc : 0, scc : 0, I : 0, j : 0, k : 0, N : 0, C: 0, D : 0] \\
\dmap_0   & = & [\mathsf{multiRound}: \infty, () : \bot, sc : 0, scc : 0, I : 0, j : 0, k : 0, N : 0, C: 0, D : 0] \\
\dmap_1   & = & [\mathsf{multiRound}: \infty, () : \bot, sc : 0, scc : 0, I : 0, j : 0, k : 0, N : 0, C: 0, D : 0] \\
\dmap_2   & = & \dmap_1[p : K - J]\\
\dmap_3   & = & \dmap_2[q : K - J]\\
\dmap_4   & = & \dmap_3[qc : 0]\\
\dmap_5   & = & \dmap_4[a : K - J - 1]\\
\dmap_6   & = & \dmap_5\\
\dmap_7   & = & \dmap_5[sc' : 0, scc' : 0, I' ; 0]\\
\dmap_8   & = & \dmap_7[D' : 0]\\
\end{array}
\]

$\Delta = [J : S, K : S]$


\newpage
\bibliographystyle{plain}
\bibliography{adaptivity.bib}

\end{document}



