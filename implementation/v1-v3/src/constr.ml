(* ---------------------------------------------------------------------- *)
(* Constraints                                                            *)
(* ---------------------------------------------------------------------- *)

(* Type of constraints generated by the type-checker.
   A constraint has the form

    - equality constraints (S = S') between size expressions
    - inequality constraints (S <= S') between size expressions
    - plus usual connectives like /\, \/, -> and existential and universal quantification
*)

open IndexSyntax
open Support.FileInfo

(* Constraints  *)
type constr =
  | CTrue
  | CFalse
  | CEq       of iterm * iterm
  | CLeq      of iterm * iterm
  | CAnd      of constr * constr
  | COr       of constr * constr
  | CImpl     of constr * constr
  | CForall   of var_info * sort * constr
  | CExists   of var_info * sort * constr
  | CArrPos   of iterm * iterm  (**  IArray, pos *) 
  | CLt       of iterm * iterm
  | CBetaEq 
  | CBetaIn
  | CBetaSub
  | CNot      of constr
(* Constrains for Depth*)
  | CDEq       of dterm * dterm
  | CDLeq      of dterm * dterm

let empty_constr = CTrue



let rec constr_free_i_vars (cs: constr) : var_info list =
match cs with
| CTrue | CFalse -> []
| CEq (it1, it2) 
| CLeq (it1, it2) -> dedup  (iterm_free_i_vars it1 @ iterm_free_i_vars it2)
| CLt (it1, it2) -> dedup  (iterm_free_i_vars it1 @ iterm_free_i_vars it2)
| CAnd (cs1, cs2) 
| COr (cs1, cs2) 
| CImpl (cs1, cs2) -> dedup (constr_free_i_vars cs1 @ constr_free_i_vars cs2)
| CForall(x, s, cs') 
| CExists(x, s, cs') -> List.filter (fun y -> x.v_name <> y.v_name ) (constr_free_i_vars cs')
 | CArrPos (o,l) -> []
  |_ -> []

(* Substitution cs[it/x] for index vars *)
let rec constr_subst x it cs =
 let csub = constr_subst x it in
 match cs with
  | CTrue | CFalse -> cs
  | CEq (it1, it2) -> CEq (iterm_subst x it it1, iterm_subst x it it2)
  | CLeq (it1, it2) -> CLeq (iterm_subst x it it1, iterm_subst x it it2)
  | CLt (it1, it2) -> CLt (iterm_subst x it it1, iterm_subst x it it2)
  | CAnd (cs1, cs2) -> CAnd (csub cs1, csub cs2)
  | COr (cs1, cs2) -> COr (csub cs1, csub cs2)
  | CImpl (cs1, cs2) -> CImpl (csub cs1, csub cs2)
  | CForall(y, s, cs') -> if x = y then csub cs' else CForall(y, s, csub cs')
  | CExists(y, s, cs') -> if x = y then csub cs' else CExists(y, s, csub cs')
  | CArrPos (o,l) -> cs
   |_ -> cs

let rec constr_map f cs =
 let cmap = constr_map f in
 match cs with
  | CTrue | CFalse -> cs
  | CEq (IConst 0, IConst 0) -> CTrue
  | CEq (it1, it2) -> if it1 = it2 then CTrue else CEq (f it1,f it2)
(*   | CLeq (IConst 0, IConst 0) -> CTrue *)
  | CLeq (IConst 0, IConst 0) -> CTrue
  | CLeq (it1, it2) -> if it1 = it2 then CTrue else CLeq (f it1, f it2)
  | CLt (IConst 0, IConst 0) -> CFalse
  | CLt (it1, it2) -> if it1 = it2 then CFalse else CLt (f it1, f it2)
  | CAnd (cs1, cs2) -> 
    let r1 = cmap cs1 in
    let r2 = cmap cs2 in
    if r1 = CTrue then r2 else if r2 = CTrue then r1 else CAnd (r1,r2)
  | COr (cs1, cs2) -> COr (cmap cs1, cmap cs2)
  | CImpl (cs1, cs2) -> CImpl (cmap cs1, cmap cs2)
  | CForall(x, s, cs') -> CForall(x, s, cmap cs')
  | CExists(x, s, cs') -> CExists(x, s, cmap cs')
  | CArrPos (o,l) -> cs
   |_ -> cs

let constr_simpl cs = 
constr_map iterm_simpl cs

let merge_cs c1 c2 =
  match c1,c2 with
  | CTrue, _ -> c2
  | _, CTrue -> c1
  | _, _ -> CAnd (c1,c2)



let rec  quantify_all_exist psi_ctx c : constr =
match psi_ctx with
| [] -> c
| (id,s) :: tl ->  CExists (id, s, (quantify_all_exist tl c))

let rec  quantify_all_universal psi_ctx c : constr =
match psi_ctx with
| [] -> c
| (id,s) :: tl ->  CForall (id, s, (quantify_all_universal tl c))


let option_combine (sl : iterm option) (sr : iterm option) (f: iterm * iterm -> 'a ) : 'a option =
match sl, sr with
| Some x, Some y -> Some (f (x, y))
| _ -> None


(* this helper function should disappear or be modified once the quantifications have sorts*)
let is_in_ctx v in_ctx : bool =
List.mem v (List.map fst in_ctx)



