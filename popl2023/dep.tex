%
%
%
\subsection{Events Dependency}
%
\begin{defn}[Variable May Dependency].
  \label{def:var_dep}
  \\
  An variable ${x}_2^{l_2} \in \lvar_{{c}}$ is in the \emph{variable may-dependency} relation with another
  variable ${x}_1^{l_1} \in \lvar_{{c}}$ in a program ${c}$, denoted as 
  %
  $\vardep({x}_1^{l_1}, {x}_2^{l_2}, {c})$, if an only if.
  %
%   \[
%     \begin{array}{l}
%   \exists \event_1, \event_2 \in \eventset^{\asn}, D \in \dbdom. ~
%   (\pi_{1}{(\event_1)}, \pi_{2}{(\event_1)}) = ({x}_1, l_1)
%   \land
%   (\pi_{1}{(\event_2)}, \pi_{2}{(\event_2)}) = ({x}_2, l_2)
%   \\ \quad 
%   \land 
%  \left(
%   \exists \trace \in \mathcal{T} \st 
%   \eventdep^{val}(\event_1, \event_2, \trace, c, D) 
%   \lor
%   \left( \exists \event_b \in \eventset^{\test} \st \eventdep^{val}(\event_1, \event_b, \trace, c, D) \land \eventdep^{\ctl}(\event_b, \event_2, c, D)  \right)  
%  \right)
%     \end{array}
%   \]
\[
  \begin{array}{l}
\exists \event_1, \event_2 \in \eventset^{\asn}, \trace \in \mathcal{T} , D \in \dbdom \st
(\pi_{1}{(\event_1)}, \pi_{2}{(\event_1)}) = ({x}_1, l_1)
\land
(\pi_{1}{(\event_2)}, \pi_{2}{(\event_2)}) = ({x}_2, l_2)
% \\ \quad 
\land 
\eventdep(\event_1, \event_2, \trace, c, D) 
  \end{array}
\]  %
, where $\eventdep$ is defined below in Definition~\ref{def:event_dep}.
  % , where $\eventdep^{val}$ and $\eventdep^{\test}$ is defined in \ref{def:event_valdep} and \ref{def:event_ctldep}.
  % %
  %
  \end{defn}
  %
Explanation: 
Among all events corresponding to the evaluations of the assignment commands associated to the two labelled variables respectively, 
as long as there is one pair of events satisfying the \emph{Event May-Dependency} relation in Definition~\ref{def:event_dep}, 
then we say the two variables have \emph{Variable May-Dependency} relation.
% \begin{defn}
% [Value Dependency of Events \todo{Explicit Dependency}]
% \label{def:event_valdep}.
% \\
% An event $\event_2$ is in the \emph{value may-dependency} relation with an assignment
% event $\event_1 \in \eventset^{\asn}$ in a program ${c}$
% with hidden database $D$, denoted as 
% %
% $\eventdep^{val}(\event_1, \event_2, c, D)$, if and only if
% %
% \[
% \exists \vtrace_0,
% \vtrace_1, \vtrace_2, \vtrace_2' \in \mathcal{T}, \event_2' \in \eventset, \event_1' \in \eventset^{\asn}, {c}_1, {c}_2,  {c}_2'.
%   \left(
%   \begin{array}{ll}   
%  & \config{{c}, \vtrace_0} \rightarrow^{*} 
% \config{{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
%   \config{{c}_2,  \vtrace_1 \cdot \event_1 \cdot \vtrace_2 \cdot \event_2 } 
%   % 
%  \\ 
%  \bigwedge &
%   \config{{c}_1, \vtrace_1 \cdot \event_1'}  \rightarrow^{*} 
%   \config{{c}_2',  \vtrace_1 \cdot \event_1'  \cdot \vtrace_2' \cdot \event_2' } 
% \\
% \bigwedge & \event_1 \sigeq \event_1' \land \diff(\event_2,\event_2')
% \end{array}
% \right)
%  \] 
%  % \wq{$\forall \vtrace_0$? is there any requirement of $c_2$ and $c_2'$? For example, you go 2 steps to get $\event_2$ while $\event_2'$ can be empty if it just goes 0 steps. Shall we set some requirement on $\event_2'$, for example, both goes to the end of $c_2$ or certain line?}
% %
% \end{defn}
%
% \jl{Better to Combine these two  \emph{may-dependency} definitions}
% \begin{defn}
% [Value Dependency of Events \todo{Explicit Dependency}]
% \label{def:event_valdep}.
% \\
% An event $\event_2$ is in the \emph{value may-dependency} relation with an assignment
% event $\event_1 \in \eventset^{\asn}$ in a program ${c}$
% with hidden database $D$ and a trace $\trace \in \mathcal{T}$ denoted as 
% %
% $\eventdep^{val}(\event_1, \event_2, [\event_1 ] \tracecat \trace \tracecat [\event_2], c, D)$, if and only if
% %
% \[
% \exists \vtrace_0,
% \vtrace_1, \vtrace' \in \mathcal{T}, \event_2' \in \eventset, \event_1' \in \eventset^{\asn}, {c}_1, {c}_2  \in \cdom  \st
%   \left(
%   \begin{array}{ll}   
%  & \config{{c}, \vtrace_0} \rightarrow^{*} 
% \config{{c}_1, \vtrace_1 \tracecat [\event_1]}  \rightarrow^{*} 
%   \config{{c}_2,  \vtrace_1 \tracecat [\event_1] \tracecat \vtrace \tracecat [\event_2] } 
%   % 
%  \\ 
%  \bigwedge &
%   \config{{c}_1, \vtrace_1 \tracecat [\event_1']}  \rightarrow^{*} 
%   \config{{c}_2,  \vtrace_1 \tracecat[ \event_1'] \tracecat \vtrace' \tracecat [\event_2'] } 
% \\
% \bigwedge &  \pi_1(\event_1) = \pi_1(\event_1') \land \pi_2(\event_1) = \pi_2(\event_1') 
% \\
% \bigwedge & 
% \diff(\event_2,\event_2' ) \land 
% \vcounter(\vtrace) ~ \pi_2(\event_2)
% = 
% \vcounter(\vtrace') ~ \pi_2(\event_2)\\
% \end{array}
% \right)
%  \]
% %  \wq{I realize Diff is little bit unclear, it means same variable, label, but only different in value:- Maybe DiffValue?}
% %
% \end{defn}
% % \begin{defn}
% % [Testing Dependency of Events]
% % \label{def:event_testdep}.
% % \\
% % One event $\event_2$ may have a testing dependency on a testing event $\event_1 = ({b}_1, l_1, n_1, v_1)$
% % in a program ${c}$, with a hidden database $D$, 
% % denoted as 
% % %
% % $\eventdep^{\ctl}(\event_1, \event_2, c, D)$, is defined as follows: 
% % %
% % \[
% % \exists \event_1' \in \eventset^{\test}, \vtrace_0,
% % \vtrace_1, \vtrace_2, \vtrace_2', {c}_1.
% %   \left(
% %   \begin{array}{ll}   
% %   & \config{{c}, \vtrace_0} \rightarrow^{*} 
% %     \config{{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
% %     \config{\eskip,  \vtrace_1 \cdot \event_1 \vtrace_2} 
% %   \\ 
% %   \bigwedge &
% %   \config{{c}_1, \vtrace_1 \cdot \event_1'}  \rightarrow^{*} 
% %   \config{\eskip,  \vtrace_1 \cdot \event_1 \vtrace_2' } 
% %   \\
% %   \bigwedge &
% %   \event_2 \sigin \vtrace_2 \land \event_2 \notsigin \vtrace_2'
% % \end{array}
% % \right)
% %  \]
% % %
% % \end{defn}
% %
% % \begin{defn}
% % [Control Dependency of Events \todo{Implicit Dependency}]
% % \label{def:event_ctldep}.
% % \\
% % An event $\event_2$ is in the \emph{control may-dependency} relation with an assignment
% % event $\event_1 \in \eventset^{\asn}$ in a program ${c}$
% % with hidden database $D$, denoted as 
% % %
% % $\eventdep^{\ctl}(\event_1, \event_2, c, D)$, if and only if: 
% % %
% % \[
% % \exists \vtrace_1, \vtrace_2, \vtrace_2', \vtrace_0 \in \mathcal{T}, 
% % \event_1' \in \eventset^{\asn}, {c}_1.
% % \left(
% % \begin{array}{ll}   
% %   & \config{{c}, \vtrace_0} \rightarrow^{*} 
% %     \config{{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
% %     \config{\eskip,  \vtrace_1 \cdot \event_1 \cdot \vtrace_2} 
% %   \\ 
% %   \bigwedge &
% %   \config{{c}_1, \vtrace_1 \cdot \event_1'}  \rightarrow^{*} 
% %   \config{\eskip,  \vtrace_1 \cdot \event_1' \cdot \vtrace_2' } 
% %   \\
% %   \bigwedge & \event_1 \sigeq \event_1' \land 
% %   \event_2 \sigin \vtrace_2 \land \event_2 \notsigin \vtrace_2'
% % \end{array}
% % \right)
% %  \]
% % %
% % \end{defn}
% %
% \begin{defn}
% [Control Dependency of Events \todo{Implicit Dependency}]
% \label{def:event_ctldep}.
% \\
% An event $\event$ is in the \emph{control may-dependency} relation with an assignment
% event $\event_b \in \eventset^{\test}$ in a program ${c}$
% with hidden database $D$, denoted as 
% %
% % doesn't rely on trace
% % $\eventdep^{\ctl}(\event_1, \event_2, \wq{\tau,} c, D)$, if and only if: 
% %
% % \[
% % \exists \vtrace_1, \vtrace_2, \vtrace_2', \vtrace_0 \in \mathcal{T}, 
% % \event_1' \in \eventset^{\asn}, {c}_1.
% % \left(
% % \begin{array}{ll}   
% %   & \config{{c}, \vtrace_0} \rightarrow^{*} 
% %     \config{{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
% %     \config{\eskip,  \vtrace_1 \cdot \event_1 \tracecat \vtrace_2} 
% %   \\ 
% %   \bigwedge &
% %   \config{{c}_1, \vtrace_1 \cdot \event_1'}  \rightarrow^{*} 
% %   \config{\eskip,  \vtrace_1 \cdot \event_1' \tracecat \vtrace_2' } 
% %   \\
% %   \bigwedge &  \pi_1(\event_1) = \pi_1(\event_1') \land \pi_2(\event_1) = \pi_2(\event_1') \\
% %   \bigwedge & l_1 = \pi_2(\event_1) \land l_2 = \pi_2(\event_2)
% %   \\
% %   \bigwedge &  \land \vcounter(\vtrace_2') l_2 \neq \vcounter(\trace_2) l_2 
% % \end{array}
% % \right)
% %  \]%
% %
% \\
% $\eventdep^{\ctl}(\event_b, \event, c, D)$, if and only if: 
% %
% % \[
% % \exists \vtrace_1, \vtrace_2', \vtrace_0 \in \mathcal{T}, 
% % \event_1, \event_1' \in \eventset^{\asn},  {c}_1.
% % \left(
% % \begin{array}{ll}   
% %   & \config{{c}, \vtrace_0} \rightarrow^{*} 
% %     \config{{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
% %     \config{c_2,  \vtrace_1 \cdot \event_1 \tracecat \trace_2 \cdot \event_b \cdot \trace_3} 
% %   \\ 
% %   \bigwedge &
% %   \config{{c}_1, \vtrace_1 \cdot \event_1'}  \rightarrow^{*} 
% %   \config{c_2,  \vtrace_1 \cdot \event_1 {\wq{\event_1'?}} \tracecat \trace_2' \cdot (\neg \event_b)\wq{+ \cdot \event_3' ?}} 
% %   \\
% %   \bigwedge &  \diff(\event_1, \event_1') \\ 
% %   \bigwedge & l_b = \pi_2(\event_b) \land \vcounter(\vtrace_2') l_b = \vcounter(\trace_2) l_b
% %     \land \event \in \trace_3
% % \end{array}
% % \right)
% %  \]
% %  %
% %  \[
% % \exists \vtrace_0, \vtrace_1, \vtrace_2, \trace_2', \vtrace_3 \in \mathcal{T}, 
% % \event_1, \event_1' \in \eventset^{\asn},  {c}_1, c_2 \in \cdom.
% % \left(
% % \begin{array}{ll}   
% %   & \config{{c}, \vtrace_0} \rightarrow^{*} 
% %     \config{{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
% %     \config{c_2,  \vtrace_1 \cdot \event_1 \tracecat \trace_2 \cdot \event_b \tracecat  \trace_3} 
% %   \\ 
% %   \bigwedge &
% %   \config{{c}_1, \vtrace_1 \cdot \event_1'}  \rightarrow^{*} 
% %   \config{c_2,  \vtrace_1 \cdot \event_1' \tracecat \trace_2' \cdot (\neg \event_b)} 
% %   \\
% %   \bigwedge &  \diff(\event_1, \event_1') \\ 
% %   \bigwedge & l_b = \pi_2(\event_b) \land \vcounter(\vtrace_2') l_b = \vcounter(\trace_2) l_b
% %     \land \event \in \trace_3
% % \end{array}
% % \right)
% %  \]
%  %
%  \[
% \exists \vtrace_0, \vtrace_1, \vtrace_2, \trace_2', \vtrace_3, \vtrace_3'  \in \mathcal{T}, 
% \event_1, \event_1' \in \eventset^{\asn},  {c}_1, c_2 \in \cdom.
% \left(
% \begin{array}{ll}   
%   & \config{{c}, \vtrace_0} \rightarrow^{*} 
%     \config{{c}_1, \vtrace_1 \tracecat [\event_1]}  \rightarrow^{*} 
%     \config{c_2,  \vtrace_1 \tracecat [\event_1] \tracecat \trace_2 \tracecat [\event_b] \tracecat  \trace_3} 
%   \\ 
%   \bigwedge &
%   \config{{c}_1, \vtrace_1 \tracecat [\event_1']}  \rightarrow^{*} 
%   \config{c_2,  \vtrace_1 \tracecat [\event_1'] \tracecat \trace_2' \tracecat [(\neg \event_b)] \tracecat \trace_3'} 
%   \\
%   \bigwedge &  \diff(\event_1, \event_1') \land \tlabel_{\trace_3} \cap \tlabel_{\trace_3'} = \emptyset\\ 
%   \bigwedge & l_b = \pi_2(\event_b) \land \vcounter(\vtrace_2') l_b = \vcounter(\trace_2) l_b
%     \land \event \in \trace_3
% \end{array}
% \right)
%  \]
%  %
% \end{defn}
%
\begin{defn}[Event May Dependency].
\label{def:event_dep}
\\ 
  An event $\event_2$ is in the \emph{event may-dependency} relation with an assignment
  event $\event_1 \in \eventset^{\asn}$ in a program ${c}$
  with a hidden database $D$ and a trace $\trace \in \mathcal{T}$ denoted as 
  %
  $\eventdep(\event_1, \event_2, [\event_1 ] \tracecat \trace \tracecat [\event_2], c, D)$, if and only if
  %
  \[
    \begin{array}{l}
  \exists \vtrace_0,
  \vtrace_1, \vtrace' \in \mathcal{T},\event_1' \in \eventset^{\asn}, {c}_1, {c}_2  \in \cdom  \st
  \diff(\event_1, \event_1') \land 
      \\ \quad
      (
        \exists  \event_2' \in \eventset \st 
    \left(
    \begin{array}{ll}   
   & \config{{c}, \vtrace_0} \rightarrow^{*} 
  \config{{c}_1, \vtrace_1 \tracecat [\event_1]}  \rightarrow^{*} 
    \config{{c}_2,  \vtrace_1 \tracecat [\event_1] \tracecat \vtrace \tracecat [\event_2] } 
    % 
   \\ 
   \bigwedge &
    \config{{c}_1, \vtrace_1 \tracecat [\event_1']}  \rightarrow^{*} 
    \config{{c}_2,  \vtrace_1 \tracecat[ \event_1'] \tracecat \vtrace' \tracecat [\event_2'] } 
  \\
  \bigwedge & 
  \diff(\event_2,\event_2' ) \land 
  \vcounter(\vtrace) ~ \pi_2(\event_2)
  = 
  \vcounter(\vtrace') ~ \pi_2(\event_2)\\
  \end{array}
  \right)
  \\ \quad
  \lor 
  \exists \vtrace_3, \vtrace_3'  \in \mathcal{T}, \event_b \in \eventset^{\test} \st 
  \left(
  \begin{array}{ll}   
    & \config{{c}, \vtrace_0} \rightarrow^{*} 
      \config{{c}_1, \vtrace_1 \tracecat [\event_1]}  \rightarrow^{*} 
      \config{c_2,  \vtrace_1 \tracecat [\event_1] \tracecat \trace \tracecat [\event_b] \tracecat  \trace_3} 
    \\ 
    \bigwedge &
    \config{{c}_1, \vtrace_1 \tracecat [\event_1']}  \rightarrow^{*} 
    \config{c_2,  \vtrace_1 \tracecat [\event_1'] \tracecat \trace' \tracecat [(\neg \event_b)] \tracecat \trace_3'} 
    \\
    \bigwedge &  \tlabel_{\trace_3} \cap \tlabel_{\trace_3'} = \emptyset
     \land \vcounter(\trace') ~  \pi_2(\event_b) = \vcounter(\trace) ~  \pi_2(\event_b)
      \land \event_2 \eventin \trace_3
    \land \event_2 \not\eventin \trace_3'
  \end{array}
  \right)
  )
\end{array}
   \]
  %  
%
\end{defn}
%

%
\begin{defn}[labelled Variables ($\lvar_{c} \subseteq \mathcal{VAR} \times \mathbb{N}$ or 
$\lvar : c \to \mathcal{P}(\mathcal{VAR} \times \mathbb{N})$]
$$
  \lvar_{c} \triangleq
  \left\{
  \begin{array}{ll}
      \{{x}^l\}                   
      & {c} = [{\assign x e}]^{l} 
      \\
      \{{x}^l\}                   
      & {c} = [{\assign x \query(\qexpr)}]^{l} 
      \\
      \lvar_{{c_1}} \cup \lvar_{{c_2}}  
      & {c} = {c_1};{c_2}
      \\
      \lvar_{{c}} \cup \lvar_{{c_2}} 
      & {c} =\eif([\bexpr]^{l}, c_1, c_2) 
      \\
      \lvar_{{c}'}
      & {c}   = \ewhile ([\bexpr]^{l}, {c}')
\end{array}
\right.
$$
\end{defn}
%
\begin{defn}[Query Variables ($\qvar_{c} \subseteq \mathcal{VAR} \times \mathbb{N}$)].
\\
Given a program $c$, its query variables $\qvar$ is a vector containing all variables newly assigned by a query in the programm, $\qvar \subset \mathcal{VAR}$.
It is defined as follows:
$$
  \qvar_{{c}} \triangleq
  \left\{
  \begin{array}{ll}
      \{\}                  
      & {c} = [{\assign x e}]^{(l, w)} 
      \\
      \{{x}^l\}                  
      & {c} = [{\assign x \query(\qexpr)}]^{(l, w)} 
      \\
      \qvar_{{c_1}} \cup \qvar_{{c_2}}  
      & {c} = {c_1};{c_2}
      \\
      \qvar_{{c_1}} \cup \qvar_{{c_2}} 
      & {c} =\eif([\bexpr]^{l}, c_1, c_2) 
      \\
      \qvar_{{c}'}
      & {c}   = \ewhile ([\bexpr]^{l}, {c}')
\end{array}
\right.
$$
\end{defn}
%
%
\begin{defn}[Execution Based Dependency Graph]
\label{def:trace_graph}
Given a program ${c}$,
its \emph{Execution-Base Dependency Graph} $\traceG({c}) = (\vertxs, \edges, \weights, \qflag)$ is defined as follows,
%
\[
\begin{array}{rlcl}
  \text{Vertices} &
  \vertxs & := & \left\{ 
  x^l \in \mathcal{VAR} \times \mathbb{N} 
  ~ \middle\vert ~ x^l \in \lvar_{c}
  \right\}
  \\
  \text{Directed Edges} &
  \edges & := & 
  \left\{ 
  (x^i, y^j) \in (\mathcal{VAR} \times \mathbb{N}) \times (\mathcal{VAR} \times \mathbb{N})
  ~ \middle\vert ~
  x^i, y^j \in \lvar_{{c}}, \vardep(x^i, y^j, c)
  
  \right\}
  \\
  \text{Weights} &
  \weights & := & 
  \left\{ 
  (x^l, n) \in (\mathcal{VAR} \times \mathbb{N}) \times \mathbb{N}
  ~ \middle\vert ~ 
  x^l \in \lvar_{c},
  n = \max \left\{ \vcounter(\vtrace') l ~ \middle\vert~
  \forall \vtrace \in \mathcal{T} \st \config{{c}, \trace} \to^{*} \config{\eskip, \trace\cdot\vtrace'} 
   \right\}
  \right\}
  \\
  \text{Query Flags} &
  \qflag & := & 
  \left\{(x^l, n)  \in( \mathcal{VAR} \times \mathbb{N} ) \times \{0, 1\} 
  ~ \middle\vert ~
   x^l \in \lvar_{c},
   \left\{
  \begin{array}{ll}
  n = 1 & x^l \in \qvar_{c} \\ 
  n = 0 & o.w.
  \end{array}
  \right\}
  \right\}
\end{array}
\]
, where $\lvar_c$ is its assigned variables.
\end{defn}
%
For any program $c$, by the injectivity of $\weights$ in its dependency graph, $\traceG({c}) = (\vertxs, \edges, \weights, \qflag)$, 
$\weights$ forms a function. We use $\weights(v)$ to indicate the image of $v$ in $\weights$.
%
\begin{defn}[Finite Walk ($k$)].
\label{def:finitewalk}
\\
Given a labelled weighted graph $G = (\vertxs, \edges, \weights, \qflag)$, a \emph{finite walk} $k$ in $G$ is a sequence of edges $(e_1 \ldots e_{n - 1})$ 
for which there is a sequence of vertices $(v_1, \ldots, v_{n})$ such that:
\begin{itemize}
    \item $e_i = (v_{i},v_{i + 1})$ for every $1 \leq i < n$.
    \item every vertex $v \in \vertxs$ appears in this vertices sequence $(v_1, \ldots, v_{n})$ of $k$ at most 
    $\weights(v)$ times.  
    % \[
    %   \forall v \in (v_1, \ldots, v_{n}), (v, n) \in \weights \st 
    %   \visit((v_1, \ldots, v_{n}), v) \leq n
    %   \]
      \[
        \forall v \in (v_1, \ldots, v_{n})\st 
        \visit((v_1, \ldots, v_{n}), v) \leq \weights(v)
      \]
\end{itemize}
$(v_1, \ldots, v_{n})$ is the vertex sequence of this walk, and $\visit((v_1, \ldots, v_{n}), v) $ counts the occurrence times of
$v$ in sequence $(v_1, \ldots, v_{n})$.
\\
%
Length of this finite walk $k$ is the number of vertices in its vertex sequence, i.e., $\len(k) = n$.
\end{defn}
%
Given a labelled weighted graph $G = (\vertxs, \edges, \weights, \qflag)$, 
we use $\walks(G)$ to denote a set containing all finite walks $k$ in $G$;
and $k_{v_1 \to v_2} \in \walks(G)$ with $v_1, v_2 \in \vertxs$ denotes the walk from vertex $v_1$ to $v_2$ .
%
%
\begin{defn}[Length of Finite Walk w.r.t. Query ($\qlen$)].
\label{def:qlen}
\\
Given a labelled weighted graph $G = (\vertxs, \edges, \weights, \qflag)$ and a \emph{finite walk} $k$ in $G$ with its vertex sequence $(v_1, \ldots, v_{n})$, the length of $k$ w.r.t query is defined as:
\[
  \qlen(k) = \len\big(
  v \mid v \in (v_1, \ldots, v_{n}) \land \flag(v) = 1 \big)
\]
, where $\big(v \mid v \in (v_1, \ldots, v_{n}) \land \flag(v) = 1 \big)$ is a subsequence of $k$'s vertex sequence.
\end{defn}
%
%
% \subsection{SSA Transformation and Soundness of Transformation}
% in File {\tt ``ssa\_transform\_sound.tex''}
% \input{ssa_transform_sound}
%
The following lemma describes a property of the trace-based dependency graph.
For any program $c$ with a database $D$ and a initial trace $\trace$,
the directed edges in its trace-based dependency graph can only be constructed from variable with  
smaller labels variables of greater ones.
There doesn't exist backward edges with direction from greater labelled variables to smaller ones.
% \begin{lem}
% \label{lem:edgeforwarding}
% [Edges are Forwarding Only].
% \\
% %
% %
% $$
% \forall \trace \in \mathcal{T}, D \in \dbdom \st G(c, D) =  (\vertxs, \edges, \weights, \qflag) 
% \implies
% \forall (\event', \event) \in \edges \st \event' \eventleq \event
% $$
% %
% \end{lem}
% %
% \begin{proof}
% Proof in File: {\tt ``edge\_forward.tex''}.
% % \input{edge_forward}
% \end{proof}
%
%
% %
% \begin{lem}
% \label{lem:DAG}
% [Trace-based Dependency Graph is Directed Acyclic].
% \\
% %
% $\forall \trace \in \mathcal{T}, D \in \dbdom $, $G(c, D)$ is a directed acyclic graph.
% \end{lem}
%