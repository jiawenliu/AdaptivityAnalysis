\begin{lem}[The One-Step Event Dependency Inversion]
	\label{lem:flowsto_soundness_emptytrace}
	For every $ c \in \cdom, D \in \dbdom$ and two assignment events $\event_1, \event_2 \in \eventset^{\asn}$,
	if $\eventdep(\event_1, \event_2, [\event_1; \event_2],  c, D) $,
	then, $\flowsto(\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c)$.
	%
	\[
	\begin{array}{l}
		\forall \event_1, \event_2 \in \eventset^{\asn}, c \in \cdom, D \in \dbdom 
		\st 
		\eventdep(\event_1, \event_2, [\event_1; \event_2],  c, D) 
		\\ \quad 
		\implies 
		\flowsto(\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c)
	\end{array}
	\]
\end{lem}
Proof Summary:
\\
1. case of (the labelled unique assignment command associated to the $\event_2$ 
is executed but the value assigned to the variable in this event is changed in second execution)
\\
show x directly used by the assignment of the second event
\\
2.(the labelled unique assignment command associated to the $\event_2$ isn't executed in second execution)
\\
show x is directly used by the boolean expression for a conditional command and second event shows in the body of that conditional command 
%
\begin{proof}
	By the Definition~\ref{def:event_dep} for $\eventdep(\event_1, \event_2, [\event_1; \event_2], c, D)$, 
	we know there are 2 cases:
	%
	\caseL{1}
		\textbf{(the labelled unique assignment command associated to the $\event_2$ 
		is executed but the value assigned to the variable in this event is changed in second execution).}
	\input{base_case_val}
	% \end{case}
	\caseL{2}
		\textbf{(the labelled unique assignment command associated to the $\event_2$ isn't executed in second execution).}
		\\
		Proof Summary:
		\\
		1. Let $\event_b$ be the testing event,
		in the same way of case 1, we get:
		 $\pi_1(\event_1) \in VAR(\pi_1(\event_b)) 
		 \land 
		%  l_1 \in \live^{l_b}$
		\pi_1(\event_1)^{l_1} \in \live(l_b, c)$
		%
		 \\
		 2. By Lemma~\ref{lem:ctldep_inv}, we know:
		   $\forall z \in VAR(\pi_1(\event_b)) \st \exists i \in \mathbb{N} \st
		 \flowsto(z^i, \pi_1(\event)^{\pi_2(\event)}, c)$
		 %
		 \\
		 3. By $\flowsto$ definition we have:
		   $\flowsto(\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c)$
		\input{base_case_ctl}
\end{proof}
%
\begin{lem}[Control Dependency Inversion]
	\label{lem:ctldep_inv}
	For every $c \in \cdom$, $D \in \dbdom, \trace \in \mathcal{T}$ and two assignment events $\event_1, \event_2 \in \eventset^{\asn} $, if they are in the second case of the \emph{Event May-Dependency} relation from Definition.~\ref{def:event_dep},
	$\eventdep(\event, \event, c, \trace, D)$ as Eq.~\ref{eq:ctlflowsto_inv},
	then for all  $z \in VAR(\pi_1(\event_b))$ there exists a label $i \in \mathbb{N}$ such that 
	$\flowsto(z^i, \pi_1(\event)^{\pi_2(\event)}, c)$
	\begin{equation}
		\label{eq:ctlflowsto_inv},		
		\begin{array}{l}
			\forall D \in \dbdom , c \in \cdom, \trace \in \mathcal{T},
			\event_1, \event_2 \in \eventset^{\asn} \st 
			\\ 
			\exists \vtrace_0,
			\vtrace_1, \vtrace', \vtrace_3, \vtrace_3' \in \mathcal{T},\event_1' \in \eventset^{\asn}, {c}_1, {c}_2  \in \cdom, 
			\event_b \in \eventset^{\test},
			\trace_{ih} \in \mathcal{T} \st 
		\trace = [\event_1] \tracecat \trace_{ih} \tracecat [\event_2]
		\\ \quad \implies	  
			  \config{{c}, \vtrace_0} \rightarrow^{*} 
				\config{{c}_1, \vtrace_1 \tracecat [\event_1]}  \rightarrow^{*} 
				\config{c_2,  \vtrace_1 \tracecat [\event_1] \tracecat \trace \tracecat [\event_b] \tracecat  \trace_3} 
			  \\ \qquad \land
			  \config{{c}_1, \vtrace_1 \tracecat [\event_1']}  \rightarrow^{*} 
			  \config{c_2,  \vtrace_1 \tracecat [\event_1'] \tracecat \trace' \tracecat [(\neg \event_b)] \tracecat \trace_3'} 
			  \\ \qquad \land
			\tlabel_{\trace_3} \cap \tlabel_{\trace_3'} = \emptyset
			   \land \vcounter(\trace') ~  \pi_2(\event_b) = \vcounter(\trace) ~  \pi_2(\event_b)
				\land \event_2 \eventin \trace_3
			  \land \event_2 \not\eventin \trace_3'
		\\ \quad \implies	
		\forall z \in VAR(\pi_1(\event_b)) \st 
		\exists l \in \mathbb{N} \st 
		\flowsto(z^l, \pi_1(\event_2)^{\pi_2(\event_2)},c)
	\end{array}
\end{equation}
	\end{lem}
	Proof Summary:
	\\
	Proving by using the Inversion Lemmas~\ref{lem:inv_expr}, \ref{lem:inv_expr_gnl}, 
	\ref{lem:inv_event}, and \ref{lem:inv_live}, and the \emph{Event May-Dependency} definition of the second case.
%
	\begin{proof}
		Take arbitrary $D \in \dbdom , c \in \cdom, \trace \in \mathcal{T},
		\event_1, \event_2 \in \eventset^{\asn} $,
%
let $\vtrace_0,
\vtrace_1, \vtrace', \vtrace_3, \vtrace_3' \in \mathcal{T}, 
\event_2' \in \eventset, \event_1' \in \eventset^{\asn}, \event_b, {c}_1, {c}_2$ be the traces, 
events and commands satisfying the executions,
by Inversion Lemma~\ref{lem:inv_event} on 
$\event_2$, and $\event_b$,
we have the following instance of the first execution in Eq.~\ref{eq:ctlflowsto_inv},
 %
%
% Let $\event_{ih} = (b, l_b, n_b, v_b)$, by Eq.~\ref{eq:ctldep_inv1} and {Inversion Lemma~\ref{lem:inv_test}}, we have:
\begin{equation}
% \label{eq:ctldep_inv1}
  \begin{array}{l}   
\config{{c}, \vtrace_0} \rightarrow^{*} 
% \config{[\assign{{x}_1}{\expr_1 / \query(\qexpr_1)}]^{l_1} ; {c}_1, \vtrace_1}  
% \rightarrow^{\rname{assn/query}}
%  \config{c_1, \vtrace_1 \tracecat [\event_1]} 
%  \\ \qquad 
%  \rightarrow^{*} 
  \config{\eif ([b]^{l_b}, c_t, c_f) / \ewhile [b]^{l_b} \edo c_w;{c}_3', 
  \vtrace_1 \tracecat [\event_1] \tracecat \trace} 
  \\
  \qquad 
   \rightarrow^{\rname{if-b / while-b}} 
  \config{(c_t;c_3' / c_f;c_3') /(c_w; \ewhile [b]^{l_b} \edo c_w;c_3'/[\eskip]; c_3'), 
  \trace_1 \tracecat [\event_1] \tracecat \trace \tracecat [\event_b]} 
  \\
  \qquad  \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2}; c_{3b}', 
  \trace_1 \tracecat [\event_1] \tracecat \trace \tracecat [\event_b] \tracecat  \trace_{3a}}
  \\ \qquad \rightarrow^{\rname{assn/query}}
  \config{ c_{3b}', 
  \trace_1 \tracecat [\event_1] \tracecat \trace \tracecat [\event_b] \tracecat  \trace_{3a} \tracecat [\event_2]}
  \rightarrow^{*} 
  \config{c_3, 
  \trace_1 \tracecat [\event_1] \tracecat \trace \tracecat [\event_b] \tracecat  \trace_{3a} \tracecat [\event_2] \tracecat \trace_{3b}}
  % 
\end{array}
\end{equation}
%  %
, where $\trace_3 = \trace_{3a} \tracecat [\event_2] \tracecat \trace_{3b}$,
% $x_1 = \pi_1(\event_1)$, $l_1 = {\pi_2(\event_1)}$, 
$x_2 = \pi_1(\event_2)$, $l_2 = \pi_2(\event_2)$, 
and $\eif ([b]^{l_b}, c_t, c_f) / \ewhile [b]^{l_b} \edo c_w$ 
is the conditional command of the assignment commands associated to the 
$\event_b$ from Inversion Lemma~\ref{lem:inv_event} of testing event.
\\
% \[\begin{array}{l}   
% 	  \config{\eif ([b]^{l_b}, c_t, c_f) / \ewhile [b]^{l_b} \edo c_w;{c}_3', 
% 	  \vtrace_1 \tracecat [\event_1] \tracecat \trace} 
% 	  \\
% 	  \qquad 
% 	   \rightarrow^{\rname{if-b / while-b}} 
% 	  \config{(c_t;c_3' / c_f;c_3') /(c_3' / c_w; \ewhile [b]^{l_b} \edo c_w;{c}_3'), 
% 	  \trace_1 \tracecat [\event_1] \tracecat \trace \tracecat [\event_b]} 
% 	  % 
% 	\end{array}
% 	\]
% $\config{\eif ([b]^{l_b}, c_t, c_f) / \ewhile [b]^{l_b} \edo c_w;{c}_3', 
% \vtrace_1 \tracecat [\event_1] \tracecat \trace} 
%  \rightarrow^{\rname{if-b / while-b}} 
% \config{(c_t;c_3' / c_f;c_3') /(c_3' / c_w; \ewhile [b]^{l_b} \edo c_w;{c}_3'), 
% \trace_1 \tracecat [\event_1] \tracecat \trace \tracecat [\event_b]} 
% $
The notation $(c_t;c_3' / c_f;c_3') /(c_w; \ewhile [b]^{l_b} \edo c_w;c_3' / [\eskip]; c_3')$ represents:
\\
In case of $\eif ([b]^{l_b}, c_t, c_f)$, if $\pi_3(\event_b) = \etrue$, we have the evaluation:
$$
\config{\eif ([b]^{l_b}, c_t, c_f) ;{c}_3', 
\vtrace_1 \tracecat [\event_1] \tracecat \trace} 
 \rightarrow^{\rname{if-b}} 
\config{c_t;c_3' 
\trace_1 \tracecat [\event_1] \tracecat \trace \tracecat [\event_b]} 
$$
%
The same for case of $\eif ([b]^{l_b}, c_t, c_f)$ with $\pi_3(\event_b) = \efalse$,
and case of $\ewhile [b]^{l_b} \edo c_w$ with $\pi_3(\event_b) = \etrue$ and $\pi_3(\event_b) = \efalse$.
%
\\
By the command label consistency,
we also have the instance of second execution as follows:
\begin{equation}
\label{eq:ctldep_inv2}
\begin{array}{l}   
  \config{{c}, \vtrace_0} \rightarrow^{*} 
%   \config{[\assign{{x}_1}{\expr_1 / \query(\qexpr_1)}]^{l_1} ; {c}_1, \vtrace_1}  
%   \rightarrow^{\rname{\rname{assn/query}}}
%    \config{c_1, \vtrace_1 \tracecat [\event_1]} 
%    \\
%     \qquad \rightarrow^{*} 
    \config{\eif ([b]^{l_b}, c_t, c_f) / \ewhile [b]^{l_b} \edo c_w;{c}_3', 
    \vtrace_1 \tracecat [\event_1] \tracecat \trace'} 
    \\
    \qquad 
     \rightarrow^{\rname{if-b / while-b}} 
    \config{(c_f;c_3' / c_t;c_3') /([\eskip]; c_3' / c_w; \ewhile [b]^{l_b} \edo c_w;{c}_3' ), 
    \trace_1 \tracecat [\event_1]  \tracecat \trace' \tracecat [\neg \event_b]} 
    \\
    \qquad   \rightarrow^{*} 
    \config{c_3, 
    \trace_1 \tracecat [\event_1]  \tracecat \trace' \tracecat [\neg \event_b] \tracecat  \trace_3'}
    % 
  \end{array}
\end{equation}
%
By the label consistency, and $\tlabel_{\trace_3} \cap \tlabel_{\trace_3'} = \emptyset$, 
% i.e., 
% $ \trace_{3a} \tracecat [\event_2] \tracecat \trace_{3b} \cap \tlabel_{\trace_3'} = \emptyset$
we know $\trace_3$ and $\trace_3'$ doesn't contain any event of evaluating the commands in $c_3'$.
Otherwise, $\tlabel_{\trace_3} \cap \tlabel_{\trace_3'} \neq \emptyset$, which is a contradiction.
\\
Since $\trace_3= \trace_{3a} \tracecat [\event_2] \tracecat \trace_{3b} $, we know $\event_2$ doesn't comes from evaluating
of $c_3'$, i.e.,:
\\
In the case of $\eif ([b]^{l_b}, c_t, c_f)$, $\event_2$ comes from the evaluation of $c_t$ or $c_f$,
i.e., $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_t$ or $c_f$;
\\
and in the case of $\ewhile [b]^{l_b} \edo c_w$, $\event_2$ comes from the evaluation of $c_w$,
i.e., $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_w$.
\\
In both of the two cases, we know $\forall z \in VAR(\pi_1(\event_b)) $ there is a label $l \in \mathbb{N}$ for this variable,
and by the $\flowsto$ definition, 
$\flowsto(z^l, \pi_1(\event_2)^{\pi_2(\event_2)},c)$.
\\
This lemma is proved.
	\end{proof}
	%
	% \begin{lem}[One Step Dependency Inversion]
	% 	\label{lem:onestepdep_inv}
	% For all $ c \in \cdom, D \in \dbdom, x^i \in \lvar_c$, and $\event_y \in \eventset^{\asn}$, 
	% if $x^i \in VAR(\expr_y)$, 
	% or there exists $\event_b \in \eventset^{\test}$ such that 
	% $x^i \in VAR(\pi_1(\event_b)$ and 
	% $\eventdep^{\ctl}(\event_b, \event_y, c, D)$, then $\flowsto(x^i, \pi_1(\event_y)^{\pi_2(\event_y)}, c)$.
	% %
	% 	\[
	% 	\begin{array}{l}
	% 		\forall c \in \cdom, D \in \dbdom, x^i \in \lvar_c, \event_y \in \eventset^{\asn}
	% 		\st
	% 		\\ \quad
	% 		(x^i \in VAR(\expr_y)\lor 
	% 		(\exists \event_b \in \eventset^{\test} \st x^i \in VAR(\pi_1(\event_b)) 
	% 		\land \eventdep^{\ctl}(\event_b, \event_y, c, D)))
	% 		\implies \flowsto(x^i, \pi_1(\event_y)^{\pi_2(\event_y)}, c)
	% 	\end{array}
	% \]
	% \end{lem}
	% \begin{proof}
	% 	proving by using the Inversion Lemmas~\ref{lem:inv_expr_gnl}, ~\ref{lem:inv_expr},
	% 	\ref{lem:inv_event}, and \ref{lem:inv_live}, 
	% 	and Control Dependency Inversion Lemmas~\ref{lem:ctldep_inv}.
	% \end{proof}
	%
	%
\begin{lem}[The Multiple-Steps Event Dependency Inversion]
	\label{lem:depevents_exist}
For every $D \in \dbdom , c \in \cdom, \trace \in \mathcal{T}$, and two assignment events 
$\event_1, \event_2 \in \eventset^{\asn}$,
if the trace $trace$ has the form $\trace = [\event_1] \tracecat \trace' \tracecat [\event_2]$ with $\trace' \in \mathcal{T}$, and $\eventdep(\event_1, \event_2, \trace, c, D)$
then $\flowsto(\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c) $,
or otherwise there exists
$\event \in \trace'$ such that
$\left( 		
   \eventdep(\event_1, \event, \trace[\event_1:\event], c, D)
\land 
\flowsto(\pi_1(\event)^{\pi_2(\event)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c) 
\right)$.
%
	\[
	\begin{array}{l}
		\forall D \in \dbdom , c \in \cdom, \trace \in \mathcal{T} \st \forall \event_1, \event_2 \in \eventset^{\asn} \st
		 \exists \trace' \in \mathcal{T} \st \trace = [\event_1] \tracecat \trace' \tracecat [\event_2]
		\implies
		\eventdep(\event_1, \event_2, \trace, c, D) 
		\\ \quad 
		\implies 
		\flowsto(\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c) 
		\\ \qquad \quad \lor
		\exists \event \in \trace' \st 
		\left( 		
			\eventdep(\event_1, \event, \trace[\event_1:\event], c, D)
		\land 
		\flowsto(\pi_1(\event)^{\pi_2(\event)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c) 
	\right) 
		% \\ \qquad \qquad \lor
		% \flowsto(\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c) 
	\end{array}
	\]
\end{lem}
Proof Summary: 
\\
Proving by using Lemma~\ref{lem:inv_indepevents}, Lemma~\ref{lem:ctldep_inv}, and the Inversion Lemmas~\ref{lem:inv_expr}, \ref{lem:inv_expr_gnl},
\ref{lem:inv_event}, and \ref{lem:inv_live}
and showing a contradiction.
\begin{proof}
	Taking arbitrary 
	$ D \in \dbdom , c \in \cdom, \trace \in \mathcal{T} $ and two events 
	$\event_1, \event_2 \in \eventset^{\asn}$, where $\trace$ has the form 
	$\trace = [\event_1] \tracecat \trace' \tracecat [\event_2]$ 
	for some 
	$\trace' \in \mathcal{T}$ and $\eventdep(\event_1, \event_2, \trace, c, D)$
	\\ 
	Assume 
	\[
		\begin{array}{l}
	\neg \flowsto(\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c) ~ (1)
	\\ \quad 
	\land 
	\forall \event \in \trace' \st 
	\left( 		
		\neg \eventdep(\event_1, \event, \trace[\event_1:\event], c, D)
	\lor 
		\neg \flowsto(\pi_1(\event)^{\pi_2(\event)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c) 
	\right) ~ (2)
	\end{array}
	\]
	Then, by Lemma~\ref{lem:inv_indepevents} and $(2)$, we know 
	$$\flowsto(\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c)$$
	, which is contradict to $(1)$.
	\\
	This Lemma is proved.
\end{proof}
%
%
%
%
\begin{lem}[Independent Events Doesn't Block $\flowsto$ ]
		\label{lem:inv_indepevents}
		For every $D \in \dbdom , c \in \cdom, \trace \in \mathcal{T}$, one assignment events 
		$\event_1\in \eventset^{\asn}$, and another event $\event_2 \in \eventset$,
		if the trace $\trace$ has the form $\trace = [\event_1] \tracecat \trace' \tracecat [\event_2]$ with $\trace' \in \mathcal{T}$, 
		and $\eventdep(\event_1, \event_2, \trace, c, D)$,
		then the following two conclusions hold when $\event_2$ is an assignment event and a testing event respectively.
	\begin{itemize}
		\item
		If $\event_2 \in \eventset^{\asn}$,
		% For every $D \in \dbdom , c \in \cdom, \trace \in \mathcal{T}$, and two assignment events 
		% $\event_1, \event_2 \in \eventset^{\asn}$,
		% if the trace $\trace$ has the form $\trace = [\event_1] \tracecat \trace' \tracecat [\event_2]$ with $\trace' \in \mathcal{T}$, and $\eventdep(\event_1, \event_2, \trace, c, D)$,
		then for every $\event \in \trace'$, if it either doesn't have the \emph{Event May-Dependency} relation on $\event_1$, 
		or $\pi_1(\event)^{\pi_2(\event)}$ doesn't have the $\flowsto$ relation with $ \pi_1(\event_2)^{\pi_2(\event_2)}$,
		then the labelled variable $\pi_1(\event_1)^{\pi_2(\event_1)}$ directly flows to the other one $\pi_1(\event_2)^{\pi_2(\event_2)}$, 
		i.e., $\flowsto(\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c)$.
		%
		\[
		\begin{array}{l}
			\forall D \in \dbdom , c \in \cdom, \trace \in \mathcal{T} \st \forall \event_1, \event_2 \in \eventset^{\asn} \st
			 \exists \trace' \in \mathcal{T} \st \trace = [\event_1] \tracecat \trace' \tracecat [\event_2]
			\implies
			\eventdep(\event_1, \event_2, \trace, c, D) 
			\\ \quad 
			\implies 
			\left( \forall \event \in \trace' \st \neg \eventdep(\event_1, \event, \trace[\event_1:\event], c, D)
			\lor \neg \flowsto(\pi_1(\event)^{\pi_2(\event)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c) 
			\right) 
			\\ \quad 
			\implies 
			\flowsto(\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}, c)
		\end{array}
		\]
		\item
If $\event_2 \in \eventset^{\test}$, 
then for every $\event \in \trace'$, if it either doesn't have the \emph{Event May-Dependency} relations on $\event_1$,
or $\pi_1(\event) \notin VAR(\pi_1(\event_2)) $,
then 
$\pi_1(\event_1) \in VAR(\pi_1(\event_2))$, and $ {\pi_2(\event_1)} = \llabel(\trace)$
%
\[
\begin{array}{l}
	\forall D \in \dbdom , c \in \cdom, \trace \in \mathcal{T} \st \forall \event_1,\in \eventset^{\asn}, \event_2 \in \eventset^{\test} \st
	 \exists \trace' \in \mathcal{T} \st \trace = [\event_1] \tracecat \trace' \tracecat [\event_2]
	\implies
	\eventdep(\event_1, \event_2, \trace, c, D) 
	\\ \quad 
	\implies 
	\left( \forall \event \in \trace' \st 
	\neg \eventdep(\event_1, \event, \trace[\event_1:\event], c, D)
	\lor  \pi_1(\event) \notin VAR(\pi_1(\event_2))
	\right) 
	\\ \quad 
	\implies 
	\pi_1(\event_1) \in VAR(\pi_1(\event_2)) \land {\pi_2(\event_1)} = \llabel(\trace)
\end{array}
\]
\end{itemize}
\end{lem}
%
\begin{proof}
Taking arbitrary $D \in \dbdom , c \in \cdom$, and an assignment events $\event_1 \in \eventset^{\asn}$ and another event 
$\event_2\in \eventset$.
\\
Without loss of generalization, 
taking arbitrary trace has the form $\trace = [\event_1; \cdots; \event_2]$ for arbitrary $\trace_2 \in \mathcal{T}$,
 then we know $\exists \trace' \in \mathcal{T} \st \trace = [\event_1] \tracecat \trace' \tracecat [\event_2]$, let $\trace_2$ be this $\trace'$.
%
\caseL{$\event_2 \in \eventset^{\asn}$}
%
By the definition of $\eventdep(\event_1, \event_2, \trace, c, D)$, 
taking $ \event_1', \event_2' \in \eventset^{\asn},
\trace_2' \in \mathcal{T}, c_1, c_2 \in \cdom$ as the events, traces and commands satisfying the definition,
 we have following two executions:
% \[
%   \exists \event_1', \event_2' \in \eventset^{\asn},
%   \trace_2' \in \mathcal{T}, c_1, c_2 \in \cdom \st
% \]
%
\[
\begin{array}{l}
\config{c, \trace_0} \rightarrow^{*}
\config{c_1, \trace_1 \tracecat [\event_1]} \rightarrow^{*} \config{c_2, \trace_1 \tracecat [\event_1] \tracecat \trace_2 \tracecat [\event_2]} 
\\ \quad
% \land
\config{c_1, \trace_1 \tracecat [\event_1']} \rightarrow^{*} \config{c_2, \trace_1 \tracecat [\event_1'] \tracecat \trace_2' \tracecat [\event_2']} 
\end{array}
\]
%
%
By inversion Lemma.~\ref{lem:inv_event} on $\event_2$ and $\event_2'$ in the two executions
and $\diff(\event_2, \event_2)$,
 we have the following two execution instances:
\[
\config{c_1, \trace_1 \tracecat [\event_1]} \rightarrow^{*} \config{[\assign{\pi_1(\event_2)}{\expr_2 / \query(\qexpr_2)}]{}^{\pi_2(\event_2)};c_2, \trace_1 \tracecat [\event_1] \tracecat \trace_2} 
\rightarrow^\rname{asn / query} \config{c_2, \trace_1 \tracecat [\event_1] \tracecat \trace_2 \tracecat [\event_2]}  
\]
%
\[
\config{c_1, \trace_1 \tracecat [\event_1']} \rightarrow^{*} \config{[\assign{\pi_1(\event_2)}{\expr_2 / \query(\qexpr_2)}]{}^{\pi_2(\event_2)};c_2, \trace_1 \tracecat [\event_1'] \tracecat \trace_2'} 
\rightarrow^\rname{asn / query} \config{c_2, \trace_1 \tracecat [\event_1'] \tracecat \trace_2' \tracecat [\event_2']}  
\]
, where $\expr_2 / \qexpr_2$ is the expression of the assignment command associated to the $\event_2$ and $\event_2'$ by the Inversion Lemma.~\ref{lem:inv_event}.
\\
Taking arbitrary $\event_z \in \trace_2$, we know 
$\neg \eventdep(\event_1, \event, \trace[\event_1:\event_z], c, D)
\lor  \pi_1(\event_z) \notin VAR(\expr_2 / \qexpr_2)$.
\\
In case of $\neg \eventdep(\event_1, \event, \trace[\event_1:\event_z], c, D)$,
by Definition~\ref{def:event_dep}, we know $\event_z \in \trace_2'$ and 
\[
	\env(\trace_1 \tracecat \trace[\event_1:\event_z]) \pi_1(\event_z) = \env(\trace_1 \tracecat \trace[\event_1':\event_z]) \pi_1(\event_z)
	\]
%
In case of $ \pi_1(\event_z) \notin VAR(\expr_2 / \qexpr_2)$, by Inversion Lemma~\ref{lem:inv_expr}
 of arithmetic and query expression cases, we know:
%
\[
	\forall x^i \in \lvar, \trace, \trace' \in \mathcal{T}, v, v' \st
	\Big( \forall z^j \in \lvar / \{\pi_1(\event_z)^{\pi_2(\event_z)} \} \st 
	\env(\trace) z = \env(\trace') z \Big) \land 
	\config{\trace, \expr_2 / \qexpr_2} \aarrow v \land \config{\trace', \expr_2} \aarrow  v' \implies v = v'
	\]
	\[
		\forall x^i \in \lvar, \trace, \trace' \in \mathcal{T}, \qval, \qval' \st
		\Big( \forall z^j \in \lvar / \{\pi_1(\event_z)^{\pi_2(\event_z)} \} \st 
		\env(\trace) z = \env(\trace') z \Big) \land 
		\config{\trace, \qexpr_2} \qarrow \qval \land \config{\trace', \qexpr_2} \qarrow \qval' \implies \qval =_{q} \qval'
		\]
for $\expr_2$ or $\qexpr_2$ respectively.
\\
Let $\kw{use}_{\trace_2}$ a subset of the events in $\trace_2$, satisfying: 
\[
	\begin{array}{l}
		\forall \event \in \eventset^{\asn} \st 
	\event \in \kw{use}_{\trace_2} \Longleftrightarrow 
	\event \in \trace_2 \land
	\pi_1(\event) \in VAR(\expr_2 / \qexpr_2)
\end{array}		
\]
Then we also know for every $\event_z \in \kw{use}_{\trace_2}$, 
$\neg \eventdep(\event_1, \event_z, \trace[\event_1:\event_z], c, D)$, i.e.,:
\[
	\forall z^l \in \lvar \setminus 
	\big( 
		( \lvar_{\trace_2} \setminus \lvar_{\kw{use}_{\trace_2}}) \cup \{\pi_1(\event_1)^{\pi_2(\event_1)}\} \big)
	\st
	\env(\trace_1 \tracecat [\event_1] \tracecat \trace_2) z = \env(\trace_1 \tracecat [\event_1'] \tracecat \trace_2') z
	~ (1)
\]
 and
 \\ 
$
	\forall z^l \in \lvar \setminus ( \lvar_{\trace_2} \setminus \lvar_{\kw{use}_{\trace_2}}), 
	\trace, \trace' \in \mathcal{T}, v, v' \st 
	\env(\trace) z = \env(\trace') z 
	\land 
	\config{\trace, \expr_2} \aarrow v 
	\land 
	\config{\trace', \expr_2} \aarrow v'
	\implies 
	v = v' 
	~ (2a)
$;
\\
$
	\forall z^l \in \lvar \setminus ( \lvar_{\trace_2} \setminus \lvar_{\kw{use}_{\trace_2}}), 
	\trace, \trace' \in \mathcal{T}, \qval, \qval' \st 
	\env(\trace) z = \env(\trace') z 
	\land 
	\config{\trace, \qexpr_2} \qarrow \qval 
	\land 
	\config{\trace', \qexpr_2} \qarrow \qval'
	\implies 
	\qval =_q \qval' 
	~ (2q)
$,
\\
where $\lvar_{\trace_2}$ and $\lvar_{\kw{use}_{\trace_2}}$ are
 the sets of labelled variables of every event in $\trace_2$ and $\kw{use}_{\trace_2}$ respectively .
% \\
% and 
% $
% 	\forall\event_z \in \lvar/\kw{diff}_{\eventset}, 
% 	\trace, \trace' \in \mathcal{T}, v, v' \st 
% 	\env(\trace) \pi_1(\event_z) = \env(\trace') \pi_1(\event_z) 
% 	\land 
% 	\config{\trace, \expr_2} \aarrow v 
% 	\land 
% 	\config{\trace', \expr_2} \aarrow v'
% 	\implies 
% 	v = v' 
% $
% \\
% By the label consistency, we know 
% \[
% 	\forall \event_z \in \kw{use}_{\trace_2} \st
% 	\env(\trace_1 \tracecat [\event_1] \tracecat \trace_2) \pi_1(\event_z) 
% 	= \env(\trace_1 \tracecat [\event_1'] \tracecat \trace_2']) \pi_1(\event_z)
% \]
% \[
% 	\forall\event_z \in \trace_2 \setminus \kw{use}_{\eventset}, 
% 	\trace, \trace' \in \mathcal{T}, v, v' \st 
% 	% \env(\trace) \pi_1(\event_z) = \env(\trace') \pi_1(\event_z) 
% 	% \land 
% 	\config{\trace, \expr_2} \aarrow v 
% 	\land 
% 	\config{\trace', \expr_2} \aarrow v'
% 	\implies 
% 	v = v' 
% \]
% Let $\diff_{\eventset}$ be a subset of the events in $\trace_2$, satisfying: 
% % \todo{refine the notation}
% \[
% 	\begin{array}{l}
% 		\forall \event_z \in \eventset^{\asn} \st 
% 	\event_z \in \diff_{\eventset} \Leftrightarrow 
% 	\exists \trace_2^h, \trace'^h_2, \trace_2^t, \trace'^t_2, \event_z' \in \trace_2' \st 
% 	\trace_2 = \trace_2^h \tracecat [\event_z] \tracecat \trace_2^t
% 	\\ \quad
% 	\land 
% 	\trace_2' = \trace'^h_2 \tracecat [\event_z'] \tracecat \trace'^t_2
% 	\land 
% 	\diff(\event_z, \event_z')
% 	\land 
% 	\vcounter(\trace_2^h) \pi_1(\event_z) = \vcounter(\trace'^h_2)(\event_z)
% \end{array}		
% \]
%
% Then we know for all $\event_z \in  \diff_{\eventset}$,
%  $\eventdep(\event_1, \event_z, \trace[\event_1:\event_z], c, D)$;
% \\
% and $\forall z^j \in (\lvar \setminus (\mathbb{LV}_{\diff_{\eventset}} \cup\{\pi_1(\event_1)^{\pi_2(\event_2)}\}) ) \st 
% \env(\trace_1 \tracecat [\event_1] \tracecat \trace_2) z = \env(\trace_1 \tracecat [\event_1'] \tracecat \trace_2') z $,
% \\
% where $\mathbb{LV}_{\diff_{\eventset}}$ is the set of labelled variables of every event in $\diff_{\eventset}$.
% We also know for all $\event_z \in  \diff_{\eventset}$, $\pi_1(\event_z) \notin VAR(\pi_1(\event_2))$ and follows:
% $\neg \eventdep(\event_z, \event_2, \trace[\event_z:\event_2], c, D) $.
% \\
% Then by $\eventdep$ definition, we know 
% $\forall \event_z', \event_2'' \in \eventset^{\asn}, \trace_z',\trace_z,  \trace_1' \in \mathcal{T}, c_z \in \cdom$ satisfying following two executions, we have $\event_2 \eventeq \event_2''$.
% \[
% 	\begin{array}{l}
% 		\config{c, \trace_0} \rightarrow^{*}
% 		\config{c_z, \trace_1' \tracecat [\event_z]} \rightarrow^{*} \config{c_2, \trace_1' \tracecat [\event_z] \tracecat \trace_z \tracecat [\event_2]} 
% 		\\ \quad
% 		\land
% 		\config{c_z, \trace_1' \tracecat [\event_z']} \rightarrow^{*} \config{c_2, \trace_1' \tracecat [\event_z'] \tracecat \trace_z' \tracecat [\event_2']'} 
% 		\end{array}		
% \]
%
% Then we know 
% \todo{type correctness}
% \[
% 	\forall z^j \in (\lvar \setminus \mathbb{LV}_{\diff_{\eventset}} ), \trace, \trace' \in \mathcal{T}, v, v' \st 
% 	\env(\trace) z = \env(\trace') z 
% 	\land 
% 	\config{\trace, \expr_2} \aarrow v 
% 	\land 
% 	\config{\trace', \expr_2} \aarrow v'
% 	\land 
% 	v = v' 
% \]
%
Since $\diff(\event_2, \event_2')$, we also know:
%
\[	
\config{\trace_1 \tracecat [\event_1] \tracecat \trace_2, \expr_2} \aarrow \pi_3(\event_2)
\land 
\config{\trace_1 \tracecat [\event_1'] \tracecat \trace_2', \expr_2} \aarrow \pi_3(\event_2') 
\land 
\pi_3(\event_2) \neq \pi_3(\event_2')
\]
%
% By construction of $\diff_{\eventset}$, we also have:
% \\
% $\forall z^j \in (\lvar \setminus \diff_{\eventset} \cup\{\event_1\} ) \st 
% \env(\trace_1 \tracecat [\event_1] \tracecat \trace_2) z = \env(\trace_1 \tracecat [\event_1'] \tracecat \trace_2') z $.
% \\
% By $\forall \event \in (\trace[\event_1:\event_y]\setminus \{\event_1, \event_y\}) \st
%   \neg \eventdep (\event_1, \event, c, D) \lor \neg \eventdep (\event, \event_y, c, D)$,
We know $\event_1$ is the only cause of the difference in $\event_y$ and $\event_y'$ when evaluating 
$[\assign{\pi_1(\event_2)}{\expr_2 / \query(\qexpr_2)}]{}^{\pi_2(\event_2)}$.
%
\\
By inversion Lemma.~\ref{lem:inv_expr_gnl} of arithmetic and query expression cases, 
given the two traces
$\trace_1 \tracecat [\event_1'] \tracecat \trace_2'$ and 
$\trace_1 \tracecat [\event_1'] \tracecat \trace_2'$ 
satisfying this lemma by $(1)$, $(2a)$ and $(2q)$, 
we know
\[
  \pi_1(\event_1) \in VAR(\expr_2 / \qexpr_2) \land {\pi_2(\event_1)} = \llabel(\trace_1 \tracecat [\event_1] \tracecat \trace_2) \pi_1(\event_1) 
\]
%
By $\flowsto$ definition:
% \todo{add the Liveness inversion}
\[
  \flowsto(\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_y)^{\pi_2(\event_y)}, c)
\]
This case is proved.
%
\caseL{$\event_2 \in \eventset^{\test}$}
\\
By the definition of $\eventdep(\event_1, \event_2, \trace, c, D)$, 
taking $ \event_1' \in \eventset^{\asn},
\trace_2' \in \mathcal{T}, c_1, c_2 \in \cdom$ and $\event_2' \in \eventset^{\test}$
 as the events, traces and commands satisfying the definition,
 we have following two executions:
% \[
%   \exists \event_1', \event_2' \in \eventset^{\asn},
%   \trace_2' \in \mathcal{T}, c_1, c_2 \in \cdom \st
% \]
%
\[
\begin{array}{l}
\config{c, \trace_0} \rightarrow^{*}
\config{c_1, \trace_1 \tracecat [\event_1]} \rightarrow^{*} \config{c_2, \trace_1 \tracecat [\event_1] \tracecat \trace_2 \tracecat [\event_2]} 
\\ \quad
% \land
\config{c_1, \trace_1 \tracecat [\event_1']} \rightarrow^{*} \config{c_2, \trace_1 \tracecat [\event_1'] \tracecat \trace_2' \tracecat [\event_2']} 
\end{array}
\]
%
Taking arbitrary $\event_z \in \trace_2$, we know 
$\neg \eventdep(\event_1, \event, \trace[\event_1:\event_z], c, D)
\lor  \pi_1(\event_z) \notin VAR(\expr_2 / \qexpr_2)$.
\\
Then by the same proof in \textbf{case: $\event_2 \in \eventset^{\asn}$}, and applying the Inversion Lemma~\ref{lem:inv_expr} and \ref{lem:inv_expr_gnl} of the boolean expression case,
we have:
\[ 
	\pi_1(\event_1) \in VAR(\pi_1(\event_2)) \land {\pi_2(\event_1)} = \llabel(\trace)
	\]
	This case is proved.
\end{proof}
%
\input{lem_basicinversion.tex}
%
\begin{lem}[While Loop Inversion]
	\label{lem:inv_while}
	For every $\trace, \trace' \in \mathcal{T}, c, c_1, c_2 \in \cdom$ 
	if $ \config{c, \trace} \rightarrow^* \config{c_1; c_2, \trace'}$ and 
	$c_1 \in_c c_2$, 
	then there must exist a $\ewhile$ command in $c_2$ and $c_1$ must shows up in the body of that $\ewhile$ command,
	 i.e., $\exists l \in \mathbb{N}, b \in \mathcal{B}, c_w \in \cdom \st 
	(\ewhile [b]^l \edo c_w) \in_c c_2 \land c_1 \in_c c_w$.
	%
	\[
	\begin{array}{l}
	\forall \trace, \trace' \in \mathcal{T}, c, c_1, c_2 \in \cdom \st
		\\ \quad
		\config{c, \trace} \rightarrow^* \config{c_1; c_2, \trace'}
		\implies
		c_1 \in_c c_2
		\implies
		\exists l \in \mathbb{N}, b \in \mathcal{B}, c_w \in \cdom \st 
		(\ewhile [b]^l \edo c_w) \in_c c_2 \land c_1 \in_c c_w
	\end{array}
	\]
	\end{lem}	
	Proof Summary: trivially by induction on $c$ and enumerate all operational semantic rules.
\begin{proof}
	Take arbitrary $\trace \in \mathcal{T}$, by induction on $c$, we have following cases:
		\caseL{$c = [\assign{x}{\expr}]^l$}
		By the evaluation rule $\rname{assn}$, we have
		$
		{
		\config{[\assign{{x}}{\aexpr}]^{l},  \trace } 
		\xrightarrow{} 
		\config{\eskip, \trace \tracecat [({x}, l, v) ]}
		}$.
		\\
		Since there doesn't exist $c_1, c_2 \in \cdom$ satisfying $\eskip = c_1; c_2$, this theorem is vacuously true.
		\caseL{$c = [\assign{x}{\query(\qexpr)}]^l$}
		By the evaluation rule $\rname{query}$, we have
		$
		{
		\config{[\assign{{x}}{\query(\qexpr)}]^{l},  \trace } 
		\xrightarrow{} 
		\config{\eskip, \trace \tracecat [({x}, l, \qval, v) ]}
		}$.
		\\
		Since there doesn't exist $c_1, c_2 \in \cdom$ satisfying $\eskip = c_1; c_2$, this theorem is vacuously true.
		\caseL{$c = \eif([b]^{l}, c_1, c_2)$}
		By the evaluation rule $\rname{query}$ and $\rname{if-f}$, and the label consistency, we know:
		\\
		for all possible $c_{t1}$ and $c_{t2}$ 
		such that $c_t$ has the form $c_t = c_{t1};c_{t2}$;
		\\
		all possible $c_{f1}$ and $c_{f2}$ 
		such that $c_f$ has the form $c_f = c_{f1};c_{f2}$,
		\\
		$c_{t1} \notin c_{t1}$ and $c_{f1} \notin c_{f2}$.
		\\
		Then this theorem is vacuously true.
		\caseL{$c = c_{s1};c_{s2}$}
		By label consistency, we know for every $c_1' \in_c c_{s1}$, $c_1' \notin c_{s2}$.
		\\
		Then by the induction hypothesis on $c_{s1}$ and $c_{s2}$ separately, we have this case proved.
		\caseL{$\ewhile [b]^{l} \edo c$}
		By rule $\rname{while-t}$, we have:
		\[
			\config{{\ewhile [b]^{l} \edo c_w, \trace}}
			\xrightarrow{} 
			\config{{
			c_w; \ewhile [b]^{l} \edo c_w,  \eskip),
			\trace \tracecat [\event]}}
		\]
		%
		If $c_w$ is a sequence command,
		let $c_1 = c_{w1}$ be the any possible command in this sequence, for all possible $c_{w1}$ and $c_{w2}$ 
		such that $c_w$ has the form $c_w = c_{w1};c_{w2}$.
		\\
		Then we have $c_2 = c_{w2};\ewhile [b]^{l} \edo c_w,  \eskip)$ and $c_1 \in_c c_2$.
		\\
		And we also have the existence of $l = l_b, b$ and $c_w$, and $\ewhile [b]^{l} \edo c_w \in_c c_2$ and  $c_1 \in c_w$.
		\\
		If $c_w$ isn't a sequence command, let $c_1 = c_w$, then we have $c_2 = \ewhile [b]^{l} \edo c_w,  \eskip)$ 
		and $c_1 \in_c c_2$.
		\\
		And we also have the existence of $l = l_b, b$ and $c_w$, and $\ewhile [b]^{l} \edo c_w \in_c c_2$ and  $c_1 \in c_w$.
		\\
		This case is proved.
		\\
		By the evaluation rule $\rname{while-f}$, we have
		$
		{
			\config{{\ewhile [b]^{l}, \edo c_w, \trace}}
			\xrightarrow{} 
			\config{{
			[\eskip]^l ,
			\trace \tracecat [((b, l, \efalse))]}}
		}$.
		\\
		Since there doesn't exist $c_1, c_2 \in \cdom$ satisfying $\eskip = c_1; c_2$, this theorem is vacuously true.
	\end{proof}
%
%
\begin{lem}[Only $\eskip$ Command doesn't Produce Event].
	\label{lem:inv_skip}
	For all trace $\trace\in \mathcal{T}$, and $c, c' \in \cdom$,  
	$\config{c, \trace} \rightarrow \config{c', \trace}$ if and only if $c = [\eskip];c'$. 
	\[
		\forall \trace\in \mathcal{T}, c, c' \in \cdom \st
		\config{c, \trace} \rightarrow \config{c', \trace}
		\Leftrightarrow 
		c = [\eskip];c'
	% \footnote{$([\eskip];){}^*$ denotes a sequence command only composed of $[\eskip]$ commands.}
	\]
	\end{lem}
\begin{proof}
	Proved trivially by induction on $c$ and enumerate all operational semantic rules.
\end{proof}
% \begin{lem}[Independent Events Doesn't Block $\flowsto$ for Testing Event]
% 	\label{lem:inv_indepeventstest}
% 	%
% 	For every $D \in \dbdom , c \in \cdom, \trace \in \mathcal{T}$, an assignment event
% 	$\event_1 \in \eventset^{\asn}$ and a test event $\event_2 \in \eventset^{\test}$,
% 	if the trace $trace$ has the form $\trace = [\event_1] \tracecat \trace' \tracecat [\event_2]$ with $\trace' \in \mathcal{T}$, 
% 	and $\eventdep(\event_1, \event_2, \trace, c, D)$,
% 	and every $\event \in \trace'$ doesn't have the \emph{May-Dependency} relations both on $\event_1$ and to $\event_2$,
% 	then 
% 	$\pi_1(\event_1) \in VAR(\pi_1(\event_2))$, and $ {\pi_2(\event_1)} = \llabel(\trace)$
% 	%
% 	\[
% 	\begin{array}{l}
% 		\forall D \in \dbdom , c \in \cdom, \trace \in \mathcal{T} \st \forall \event_1,\in \eventset^{\asn}, \event_2 \in \eventset^{\test} \st
% 		 \exists \trace' \in \mathcal{T} \st \trace = [\event_1] \tracecat \trace' \tracecat [\event_2]
% 		\implies
% 		\eventdep(\event_1, \event_2, \trace, c, D) 
% 		\\ \quad 
% 		\implies 
% 		\left( \forall \event \in \trace' \st \neg \eventdep(\event_1, \event, \trace[\event_1:\event], c, D)
% 		\lor \neg \eventdep(\event, \event_2, \trace[\event:\event_2], c, D) 
% 		\right) 
% 		\\ \quad 
% 		\implies 
% 		\pi_1(\event_1) \in VAR(\pi_1(\event_2)) \land {\pi_2(\event_1)} = \llabel(\trace)
% 	\end{array}
% 	\]
% \end{lem}
%
% \begin{lem}[Flow Search Algorithm ($\mathcal{A}$) Inversion 1]
% \label{lem:inv_alg1}
% For all $D \in \dbdom , c \in \cdom, \trace \in \mathcal{T}, \event_1, \event_2 \in \eventset^{\asn}$, and a list $l$,
% if $l \in \mathcal{A}(\event_1, \event_2, \trace, c, D)$,
% then l must have the form $[\pi_1(\event_1)^{\pi_2(\event_1)},\ldots, \pi_1(\event_2)^{\pi_2(\event_2)}]$.
% \[
% \begin{array}{l}
%     \forall D \in \dbdom , c \in \cdom, \trace \in \mathcal{T}, l \st \forall \event_1, \event_2 \in \eventset^{\asn} \st
%   \\ \quad 
%  l\in \mathcal{A}(\event_1, \event_2, \trace, c, D)  \implies  l = [\pi_1(\event_1)^{\pi_2(\event_1)},\ldots, \pi_1(\event_2)^{\pi_2(\event_2)}]
% \end{array}
% \]
% \end{lem}
% %
% \begin{proof}
% % Let $l \in \mathcal{A}(\event_1, \event_2, \trace, c, D)$. By definition of $\mathcal{A}$ we have 
% % \[l\in \kw{setmap} 
% % 	% \bigcup\limits_{l \in \kw{dfs}(\trace, c, D) \land l = \event_1 :: l'}
% % 	\left(\emap 
% % 		(\efun  \event \to \pi_1(\event)^{\pi_2(\event)})	
% % 	(\efilter 
% % 		(\efun \event \to  \event \in \eventset^{\asn})) \right)
% % 	S
% % \]
% % for $S=\kw{setfilter}
% % 		(\efun l \to \exists l' \st l = \event_1 :: l' ++ [\event_2]) ~ \kw{dfs}(\trace, c, D)$.
% % So, in particular by definition of setmap there is a list $l_1\in S$ such that 
% % \[
% % 	% \bigcup\limits_{l \in \kw{dfs}(\trace, c, D) \land l = \event_1 :: l'}
% % \emap 
% % 		(\efun  \event \to \pi_1(\event)^{\pi_2(\event)})	
% % 	(\efilter 
% % 		(\efun \event \to  \event \in \eventset^{\asn}))
% % 	l_1 = l
% % \]
% % \[
% % l = [\event_1, \cdots, \event_2]
% % \]
% % \\
% Let  $l \in \mathcal{A}(\event_1, \event_2, \trace, c, D)$,
% by definition of $\mathcal{A}$, we know 
% %
% $$l\in \kw{setmap} 
% 	% \bigcup\limits_{l \in \kw{dfs}(\trace, c, D) \land l = \event_1 :: l'}
% 		\left(\efun l \to ( \emap 
% 		(\efun  \event \to \pi_1(\event)^{\pi_2(\event)})
% 	(\efilter 
% 		(\efun \event \to  \event \in \eventset^{\asn}) ~ l) \right)
% 	~ S,
% $$
% %
% where $S=(\kw{setfilter} ~(\efun l \to l = [\event_1, \cdots, \event_2]) ~ (\kw{dfs} \eapp \trace \eapp c \eapp  D))$.
% \\
% Then, by definition of $\kw{setmap}$, we know $l$ is an output of
% \\
% $\left(\efun l \to ( \emap 
% 		(\efun  \event \to \pi_1(\event)^{\pi_2(\event)})
% 	(\efilter 
% 		(\efun \event \to  \event \in \eventset^{\asn}) ~ l) \right)$.
% \\
% Then we know there exists a preimage
% $l_e \in S $
% for $l$ such that 
% $$
% \emap (\efun  \event \to \pi_1(\event)^{\pi_2(\event)}) 
% (\efilter (\efun \event \to  \event \in \eventset^{\asn}) ~ l_e) 
% = l.
% $$
%  %
% Since $l_e \in (\kw{setfilter} ~(\efun l \to l = [\event_1, \cdots, \event_2]) ~ (\kw{dfs} \eapp \trace \eapp c \eapp  D))$,
% \\
% by the $\kw{setfilter}$ function,
% we know only the lists of events in $(\kw{dfs} \eapp \trace \eapp c \eapp  D)$ having the form
% $ [\event_1, \cdots, \event_2] $ are preserved in $S$, i.e.,
% \[
% 	\forall l \in (\kw{setfilter} ~(\efun l \to l = [\event_1, \cdots, \event_2]) ~ \kw{dfs}(\trace, c, D))
% 	\st l = [\event_1, \cdots, \event_2]
% \]
% %
% Then we know $l_e$ also has the same form, 
% i.e., $l_e = [\event_1, \cdots, \event_2]$.
% %
% \\
% Let $l_{ef} = (\efilter (\efun \event \to  \event \in \eventset^{\asn})) ~ l_e$, 
% by $\event_1, \event_2 \in \eventset^{\asn}$, 
% we know $\event_1$ and $\event_2$ are preserved in $l_{ef}$, i.e.,:
% \[
% 	l_{ef} =[\event_1, \cdots, \event_2]
% \]
% %
% Then, by applying the function
% $\emap (\efun  \event \to \pi_1(\event)^{\pi_2(\event)})$ to 
% $l_{ef}$, we have $l$ as follows:
% \[
% 	[\pi_1(\event_1)^{\pi_2(\event_1)}, \cdots, \pi_1(\event_2)^{\pi_2(\event_2)}]
% \]
% %
% %
% This lemma is proved.
% \end{proof}
% %
% \begin{lem}[Flow Search Algorithm ($\mathcal{A}$) Inversion 2]
% \label{lem:inv_alg2}
% For every $\event_1, \event_2 \in \eventset^{\asn}, D \in \dbdom , c \in \cdom$, we have either one of the two following cases:
% \begin{enumerate}
%   \item $\mathcal{A}(\event_1, \event_2,  [\event_1; \event_2], c, D) = 
%   \left\{[\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}] \right \}$ 
%   and $\eventdep(\event_1, \event_2, [\event_1; \event_2], c, D)$.
%   \item  $\mathcal{A}(\event_1, \event_2, [\event_1; \event_2], c, D) = \{\}$ 
%   and $\neg \eventdep(\event_1, \event_2, [\event_1; \event_2] c, D)$;
% \end{enumerate}
% \end{lem}
% % \wq{ Good! I just realize this lemma is only used for case 4 of 5.3.}
% %\jl{Yes!}
% \begin{proof}
% By definition of $A$, we know:
% %
% \[
% 	\begin{array}{l}
% 	\mathcal{A}(\event_1, \event_2, [\event_1; \event_2], c, D)
% 	= 
% 	\kw{setmap} ~
% 	% \bigcup\limits_{l \in \kw{dfs}(\trace, c, D) \land l = \event_1 :: l'}
% 	\\ \qquad \qquad
% 	\left(\efun l \to ( \emap 
% 		(\efun  \event \to \pi_1(\event)^{\pi_2(\event)})
% 	(\efilter 
% 		(\efun \event \to  \event \in \eventset^{\asn}) ~ l) \right)
% 	\\ \qquad \qquad
% 	(\kw{setfilter} ~
% 		(\efun l \to l = [\event_1, \cdots, \event_2]) ~ 
% 		% \left(\left\{[\event_2]\right\} \cup \left\{ \event_1 \stackrel{[\event_1; \event_2]}{\uplus} [\event_2] \right\} \right))
% 		\left(\left\{[\event_2]\right\} \cup \left(  {\uplus} \eapp \event_1 \eapp {[\event_1; \event_2]} \eapp [\event_2] \right) \right))
% 	\end{array}
% \]
% by definition of $ {\uplus} \eapp \event_1 \eapp {[\event_1; \event_2]} \eapp [\event_2]  $, we know 
% \[
% 	\begin{array}{l}
% 	% \event_1 \stackrel{[\event_1; \event_2]}{\uplus} [\event_2]
% 	{\uplus} \eapp \event_1 \eapp {[\event_1; \event_2]} \eapp [\event_2] 
% 	=   
% 	\\ \quad \qquad 	
% 	\ecase \eventdep(\event_1, \event_2, [\event_1; \event_2], c, D)
% 	\to \left\{ [\event_1, \event_2] \right\}
% 	\\ \quad \qquad 	
% 	\ecase \_
% 	\to \left\{ \right\}
% \end{array}
% \]
% %
% By simplification of the $\kw{setfilter}$, $\emap$, $\efilter$ and $\kw{setmap}$ functions, we know
% \\
% in the case of $\eventdep(\event_1, \event_2, [\event_1; \event_2], c, D)$:
% % \\
% $\mathcal{A}(\event_1, \event_2, [\event_1; \event_2], c, D) = 
%   \left\{[\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}] \right \}$
% \\
% (1) is proved.
% \\
% And in the case of $\neg \eventdep(\event_1, \event_2, [\event_1; \event_2], c, D)$: 
% % \\
% $\mathcal{A}(\event_1, \event_2, \cdot  \event_1 \tracecat [\event_2], c, D) = 
%   \left\{ \right \}$
% \\
% (2) is proved.
% \end{proof}
%
%
% \begin{lem}[\todo{Assignment Evaluation Inversion}].
% 	\label{lem:inv_eval_asn}
% 	\[
% 	\begin{array}{l}
% 		\forall x \in \lvar_c, \kw{V_{ptl}} \in \subseteq \lvar_c \expr \st 
% 		\exists \trace, \trace' \in \mathcal{T} \st 
% 		\\ \quad
% 		\forall z \in \lvar_c \setminus (\{x\} \cup \kw{V_{ptl}}) \st 
% 		\env(\trace) z = \env(\trace') z 
% 		\\ \quad \land
% 		\forall \event \in \trace, \event' \in \trace' \st 
% 		\pi_1(\event) \in \kw{V_{ptl}} \land \diff(\event, \event') 
% 		\\ \quad
% 		\implies 
% 		\neg \eventdep(\event, \event_y, \trace[\event:\event_y] ) 
% 		\implies
% 		\config{\trace, [\assign{y}{\expr}]{}^l;c'} \rightarrow^{asn} \config{\trace\cdot \event_y, c'}
% 		\\ \quad
% 		\implies 
% 		\config{\trace', [\assign{y}{\expr}]{}^l;c'} \rightarrow^{asn} \config{\trace'\cdot \event_y',c'}
% 		\land \diff(\event_y, \event_y')
% 		\implies x \in VAR(\expr)
% 	\end{array}
% 	\]
% 	\end{lem}	
%
%
% \todo{Event Dependency Transitivity}
\begin{lem}
	\label{lem:valdep_trans}
(Event Dependency Transitivity)
For every $D \in \dbdom , c \in \cdom, \trace \in \mathcal{T}$, and $\event_1, \event_2, \event_3 \in \eventset^{\asn}, \trace_{12}, \trace_{23} \in \mathcal{T}$,
if $\eventdep(\event_1, \event_2, \trace_{12}, c, D)$
and $\eventdep(\event_2, \event_3, \trace_{23}, c, D) $,
then $\eventdep(\event_1, \event_3, \trace_{12}\tracecat\trace_{23}, c, D)$.
  % An event $\event_2 \in \eventset^{\asn}$ is in the \emph{may-dependency} relation with another
  % event $\event_1 \in \eventset^{\asn}$ in a program ${c}$ with a hidden database $D$, denoted as $\eventdep(\event_1, \event_2, c, D)$,
  % if and only if
  \[
	  \begin{array}{l}
  \forall D \in \dbdom , c \in \cdom, \event_1, \event_2, \event_3 \in \eventset^{\asn}, \trace_{12}, \trace_{23} \in \mathcal{T} \st 
  \eventdep(\event_1, \event_2, \trace_{12}, c, D) 
  \land
  \eventdep(\event_2, \event_3, \trace_{23}, c, D) 
  \\ \quad
  \implies
  \eventdep(\event_1, \event_3, \trace_{12}\tracecat\trace_{23}, c, D)
	  \end{array}
  \]
\end{lem}
%
%
% \begin{lem}(Control Dependency Transitivity)
% \label{lem:ctl_trans}
% For every $D \in \dbdom , c \in \cdom, \event_1, \event_2 \in \eventset^{\test}, \event_3 \in \eventset$
% if $\eventdep^{\ctl}(\event_1, \event_2, c, D)$ and $\eventdep^{\ctl}(\event_2, \event_3, c, D)$,
% then $\eventdep^{\ctl}(\event_1, \event_3, c, D)$.
% %
% \[
%   \forall D \in \dbdom , c \in \cdom, \event_1, \event_2 \in \eventset^{\test}, \event_3 \in \eventset \st
%   \eventdep^{\ctl}(\event_1, \event_2, c, D) 
%   \land \eventdep^{\ctl}(\event_2, \event_3, c, D)
%   \implies \eventdep^{\ctl}(\event_1, \event_3, c, D)
% \]
% \end{lem}
%
% \begin{lem}
% 	\label{lem:eventdep_trans}
% (\emph{Variable May-Dependency} Transitivity)
% 	\[
% 	\forall c \in \cdom, D \in \dbdom , \event_1, \event_2, \event_3 \in \eventset^{\asn}\st 
% 	\eventdep(\event_1, \event_2, c, D) 
% 	\land
% 	\eventdep(\event_2, \event_3, c, D) 
% 	\implies
% 	\eventdep(\event_1, \event_3, c, D)
% 	\]
%   \end{lem}
%
\begin{lem}[\emph{Variable May-Dependency} Transitivity]
	\label{lem:vardep_trans}
For every $c \in \cdom, x^i, y^j, z^l \in \lvar_c$, 
if $\vardep(x^i, y^j, c)$ and 
$\vardep(y^j, z^l, c)$, then $\vardep(x^i, z^l, c)$.
	\[
	\forall c \in \cdom, x^i, y^j, z^l \in \lvar_c \st 
	\vardep(x^i, y^j, c) 
	\land
	\vardep(y^j, z^l, c) 
	\implies
	\vardep(x^i, z^l, c)
	\]
  \end{lem}
  %
%
