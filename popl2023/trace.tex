%
\subsection{Trace}
%
% An event $\event \in \eventset$ belongs to a trace $\trace$, i.e., $\event \eventin \trace$ are defined as follows:
% %
% \begin{equation}
%   \event \eventin \trace  
%   \triangleq \left\{
%   \begin{array}{ll} 
%     \etrue                  & \trace =  (\trace' \tracecate \event') \land (\event \eventeq \event') \\
%     \event \eventin \trace' & \trace =  (\trace' \tracecate \event') \land (\event \eventneq \event') \\ 
%     \efalse                 & o.w.
%   \end{array}
%   \right.
% \end{equation}
% %
% A well-formed event $\event \in \eventset$ belongs to a trace $\trace$ in signature, 
% i.e., $\event \sigin \trace$ are defined as follows:
%   %
% \begin{equation}
%   \event \sigin \trace  
%   \triangleq \left\{
%   \begin{array}{ll} 
%     \etrue                  & \trace =  (\trace' \tracecate \event') \land (\event \sigeq \event') \\
%     \event \sigin \trace'   & \trace =  (\trace' \tracecate \event') \land (\event \signeq \event') \\ 
%     \efalse                 & o.w.
%   \end{array}
%   \right.
% \end{equation}
%
%
%
%
% \todo{
% \[
% \mbox{Post-Processed Trace} \qquad \trace \qquad ::= \qquad \tracecate | \trace \tracecate \event
% % %
% \]
% Trace appending: $\tracecate: \mathcal{T} \to \eventset \to \mathcal{T}$
% \[
%   \trace \tracecate \event \triangleq
%   \left\{
%   \begin{array}{ll} 
%     {} \tracecate \event           & \trace =  \tracecate \\
%     \trace \tracecate \event    & \trace =  \trace' \tracecate \event\\ 
%   \end{array}
%   \right.
% \]
%
Trace concatenation: $\tracecat: \mathcal{T} \to \mathcal{T} \to \mathcal{T}$
\[
  \trace_1 \tracecat \trace_2 \triangleq
  \left\{
  \begin{array}{ll} 
    \trace_2                                      & \trace_1 =  [] \\
    \event ::  (\trace_1'  \tracecat \trace_2 )   & \trace_1 =  \event :: \trace_1'\\ 
  \end{array}
  \right.
\]
%
\todo{ need to consider the occurrence times }
\\
Subtrace: $[ : ] : \mathcal{{T} \to \eventset \to \eventset \to \mathcal{T}}$ 
% \wqside{Confusing, I can not understand the subtraction, it takes a trace, and two events, and this operator is used to subtract these two events?}
\[
  \trace[\event_1 : \event_2] \triangleq
  \left\{
  \begin{array}{ll} 
  \trace'[\event_1: \event_2]             & \trace = \event :: \trace' \land \event \eventneq \event_1 \\
  \event_1 :: \trace'[:\event_2]  & \trace = \event :: \trace' \land \event \eventeq \event_1 \\
  {[]} & \trace = [] \\
  \end{array}
  \right.
\]
For any trace $\trace$ and two events $\event_1, \event_2 \in \eventset$,
$\trace[\event_1 : \event_2]$ takes the subtrace of $\trace$ starting with $\event_1$ and ending with $\event_2$ including $\event_1$ and $\event_2$.
\\
We use $\trace[:\event_2] $ as the shorthand of subtrace starting from head and ending with $\event_2$, and similary for $\trace[\event_1:]$.
\[
  \trace[:\event] \triangleq
  \left\{
  \begin{array}{ll} 
 \event' :: \trace'[: \event]             & \trace = \event' :: \trace' \land \event' \eventneq \event \\
  \event'  & \trace = \event' :: \trace' \land \event' \eventeq \event \\
  {[]}  & \trace = [] 
  \end{array}
  \right.
% \]
% \[
  \quad
  \trace[\event: ] \triangleq
  \left\{
  \begin{array}{ll} 
  \trace'[\event: ]     & \trace =  \event' :: \trace' \land \event \eventneq \event' \\
  \event' :: \trace'  & \trace = \event' :: \trace' \land \event \eventeq \event' \\
  {[ ] } & \trace = []
  \end{array}
  \right.
\]
%
An event $\event \in \eventset$ belongs to a trace $\trace$, i.e., $\event \eventin \trace$ are defined as follows:
%
\begin{equation}
  \event \eventin \trace  
  \triangleq \left\{
  \begin{array}{ll} 
    \etrue                  & \trace =  (\event' :: \trace') \land (\event \eventeq \event')
                              \\
    \event \eventin \trace' & \trace =  (\event' :: \trace') \land (\event \eventneq \event') \\ 
    \efalse                 & o.w.
  \end{array}
  \right.
\end{equation}
%
% An event $\event \in \eventset$ belongs to a trace $\trace$ up to value, 
% i.e., $\event \sigin \trace$ are defined as follows:
%   %
% \begin{equation}
%   \event \sigin \trace  
%   \triangleq \left\{
%   \begin{array}{ll} 
%     \etrue                  & \trace =  (\trace' \tracecate \event')                          \land \pi_1(\event_1) = \pi_1(\event_2) 
%                               \land  \pi_2(\event_1) = \pi_2(\event_2)  
%                               % \land \vcounter(\trace \event) = \vcounter()
%                               \\
%     \event \sigin \trace'   & \trace =  (\trace' \tracecate \event') 
%                               \land 
%                               (\pi_1(\event_1) \neq \pi_1(\event_2) 
%                               \lor  \pi_2(\event_1) \neq \pi_2(\event_2)) 
%                               \\ 
%     \efalse                 & o.w.
%   \end{array}
%   \right.
% \end{equation}
%
Counter $\vcounter : \mathcal{T} \to \mathbb{N} \to \mathbb{N}$ 
% \wq{The operator counter actually provides the number of times a specific label appears in a trace. Only a number, the position of label is ignored.}
% \[
% \begin{array}{lll}
% \vcounter((x, l, v) :: \trace ) l \triangleq \vcounter(\trace) l + 1
% &
% \vcounter((b, l, v):: \trace ) l \triangleq \vcounter(\trace) l + 1
% &
% \vcounter((x, l, \qval, v):: \trace ) l \triangleq \vcounter(\trace) l + 1
% \\
% \vcounter((x, l', v):: \trace ) l \triangleq \vcounter(\trace ) l
% &
% \vcounter((b, l', v):: \trace ) l \triangleq \vcounter(\trace ) l
% &
% \vcounter((x, l', \qval, v):: \trace ) l \triangleq \vcounter(\trace ) l
% \\
% \vcounter({[]}) l \triangleq 0
% &&
% \end{array}
% \]
\[
\begin{array}{lll}
\vcounter(\trace  \tracecat [(x, l, v)] ) l \triangleq \vcounter(\trace) l + 1
&
\vcounter(\trace  \tracecat [(b, l, v)] ) l \triangleq \vcounter(\trace) l + 1
&
\vcounter(\trace  \tracecat [(x, l, \qval, v)] ) l \triangleq \vcounter(\trace) l + 1
\\
\vcounter(\trace  \tracecat [(x, l', v)] ) l \triangleq \vcounter(\trace ) l
&
\vcounter(\trace  \tracecat [(b, l', v)] ) l \triangleq \vcounter(\trace ) l
&
\vcounter(\trace  \tracecat [(x, l', \qval, v)]) l \triangleq \vcounter(\trace ) l
\\
\vcounter({[]}) l \triangleq 0
&&
\end{array}
\]
%
% The Latest Label $\llabel : \mathcal{T} \to \mathcal{VAR} \to \mathbb{N}$ 
% The label of the latest assignment event which assigns value to variable $x$.
% \[
%   \begin{array}{lll}
% \llabel((x, l, v):: \trace) x \triangleq l
% &
% \llabel((b, l, v)):: \trace x \triangleq \llabel(\trace) x
% &
% \llabel((x, l, \qval, v):: \trace) x \triangleq l
% \\
% \llabel((y, l, v):: \trace) x \triangleq \llabel(\trace ) x
% &
% \llabel((y, l, \qval, v):: \trace) x \triangleq \llabel(\trace ) x
% \\
% \llabel({[]}) x \triangleq \bot
% &&
% \end{array}
% \]
%
The Latest Label $\llabel : \mathcal{T} \to \mathcal{VAR} \to \mathbb{N}$ 
The label of the latest assignment event which assigns value to variable $x$.
\[
  \begin{array}{lll}
\llabel(\trace  \tracecat [(x, l, v)]) x \triangleq l
&
\llabel(\trace  \tracecat [(b, l, v)]) x \triangleq \llabel(\trace) x
&
\llabel(\trace  \tracecat [(x, l, \qval, v)]) x \triangleq l
\\
\llabel(\trace  \tracecat [(y, l, v)]) x \triangleq \llabel(\trace ) x
&
\llabel(\trace  \tracecat [(y, l, \qval, v)]) x \triangleq \llabel(\trace ) x
\\
\llabel({[]}) x \triangleq \bot
&&
\end{array}
\]
%
The Trace Label Set $\tlabel : \mathcal{T} \to \mathcal{P}{(\mathbb{N})}$ 
The label of the latest assignment event which assigns value to variable $x$.
\[
  \begin{array}{llll}
\tlabel_{(\trace  \tracecat [(x, l, v)])} \triangleq \{l\} \cup \tlabel_{(\trace )}
&
\tlabel_{(\trace  \tracecat [(b, l, v)])} \triangleq \{l\} \cup \tlabel_{(\trace)}
&
\tlabel_{(\trace  \tracecat [(x, l, \qval, v)])} \triangleq \{l\} \cup \tlabel_{(\trace)}
&
\tlabel_{[]} \triangleq \{\}
\end{array}
\]
%
% Given a trace $\trace$, its -processed trace $\trace$ is computed by a function $p : \trace \to \trace$ as follows:
% \[
%   \trace \triangleq
%   \left\{
%   \begin{array}{ll} 
%   p(\trace' \tracecate (x, l, v)) & = p(\trace') \tracecate (x, l, \vcounter(\trace') l + 1, v) \\
%   p(\trace' \tracecate (b, l, v)) & = p(\trace') \tracecate (b, l, \vcounter(\trace') l + 1, v) \\
%   p(\trace' \tracecate (x, l, \qval, v)) & = p(\trace') \tracecate (x, l, \vcounter(\trace') l + 1, \qval, v) \\
%   p([]) & = []
%   \end{array}
%   \right.
% \]
%
%
% $\mathcal{T}$ : Set of Well-formed Traces (in Definition~\ref{def:wf_trace})
%
%
% \\
%

%
\begin{lem}
[Trace Non-Decreasing].
\\
$$
\forall \trace, \trace' \in \mathcal{T}, c \st
\config{c, \trace} \rightarrow^{*} \config{\eskip, \trace'} 
\implies \exists \trace'' \in \mathcal{T} \st \trace \tracecat \trace'' = \trace'
$$
\end{lem}
%
\begin{coro}
\label{coro:aqintrace}
\[
  \forall \event \in \eventset, \trace \in \mathcal{T} \st
\event \eventin \trace \implies \exists \trace_1, \trace_2 \in \mathcal{T}, 
\event' \in \eventset \st (\event \eventeq \event') \land \trace_1 \tracecat [\event'] \tracecat \trace_2 = \trace  
\]
\end{coro}
\begin{subproof}
Proof in File: {\tt ``coro\_aqintrace.tex''}
% \input{coro_aqintrace}
%
\end{subproof}
% \\
%
%
\todo{Not Necessary but keep it for now}
\\
Given a trace $\trace$, its post-processed trace $\trace_p$ is computed by a function $p : \trace \to \trace_p$ as follows:
\[
  p(\trace) \triangleq
  \left\{
  \begin{array}{ll} 
  p(\trace' \tracecat [(x, l, v)]) & = p(\trace') \tracecat [(x, l, \vcounter(\trace') l + 1, v)] \\
  p(\trace' \tracecat [(b, l, v)]) & = p(\trace') \tracecat [(b, l, \vcounter(\trace') l + 1, v)] \\
  p(\trace' \tracecat [(x, l, \qval, v)]) & = p(\trace') \tracecat [(x, l, \vcounter(\trace') l + 1, \qval, v)] \\
  p({[]}) & = []
  \end{array}
  \right.
\]
\\
\begin{defn}[Well-formed Post-Processed Trace $\mathcal{T_p}$]
\label{def:wf_trace}
A post-processed trace $\trace_p$ is well formed, i.e., $\trace_p \in \mathcal{T_p}$ if and only if it preserves the following two properties:
\begin{itemize}
\item{\emph{(Uniqueness)}} 
$\forall \event_1, \event_2 \eventin \trace_p \st \event_1 \signeq \event_2$
%
\item{\emph{(Ordering)}} $\forall \event_1, \event_2 \eventin \trace_p \st 
(\event_1 \eventlt \event_2) \Longleftrightarrow
\exists \trace_1, \trace_2, \trace_3 \in \mathbb{T_p},
 \event_1', \event_2' \in \eventset \st
(\event_1 \eventeq \event_1') \land (\event_2 \eventeq \event_2')
\land \trace_1 \tracecat [\event_1'] \tracecat \trace_2 \tracecat [\event_2'] \tracecat \trace_3 = \trace_p$
\end{itemize}
\end{defn}
%
%
\begin{thm}[Trace Generated from Operational Semantics after Post Processing is Well-formed $c \vDash \trace$].
\label{thm:os_wf_trace}
\\
\[
\forall \trace \in \mathcal{T}, c \st
\config{c, \vtrace} \to^{*} \config{\eskip, \trace \tracecat \trace'} \land \trace_p = p(\trace')
\implies
\trace_p\in \mathcal{T}
\] 
% \wqside{ is $p(\tau)$ defined some where? I guess it means post-processing.}
%
\end{thm}
\begin{proof}
Proof in File: {\tt ``thm\_os\_wf\_trace.tex''}.
% \input{thm_os_wf_trace}
\end{proof}
%
%
% \todo{
% \begin{lem}[While Map Remains Unchanged (Invariant)]
% \label{lem:wunchange}
% Given a program $c$ with a starting memory $m$, trace $t$ and while map $w$, s.t.,
% $\config{m, c, t, w} \to^{*} \config{m', \eskip, t', w'}$ and $Labels(c) \cap Keys(w) = \emptyset$, then 
% \[
%   w = w'
% \]
% \end{lem}
% \begin{subproof}[Proof of Lemma~\ref{lem:wunchange}]
% %
% Proof in File: {\tt ``lem\_wunchange.tex''}
% % \input{lem_wunchange}
% %
% \end{subproof}
% }
%
% \todo{
% \begin{lem}[Trace is Written Only]
% \label{lem:twriteonly}
% Given a program $c$ with starting trace $t_1$ and $t_2$,
% for arbitrary starting memory $m$ and while map $w$,
% if there exist evaluations
% $$\config{m, c, t_1, w} \to^{*} \config{m_1', \eskip, t_1', w_1'}$$
% % 
% $$\config{m, c, t_2, w} \to^{*} \config{m_2', \eskip, t_2', w_2'}$$
% %
% then:
% %
% \[
%   m_1' = m_2' \land w_1' = w_2'
% \]
% \end{lem}
% %
% \begin{subproof}[Proof of Lemma~\ref{lem:twriteonly}]
% %
% Proof in File: {\tt ``lem\_twriteonly.tex''}
% % \input{lem_twriteonly}
% \end{subproof}
% }
%
% \todo{
% \begin{lem}[Trace Uniqueness]
% \label{lem:tunique}
% Given a program $c$ with a starting memory $m$, \wq{a while map w,}
% for any starting trace $t_1$ and $t_2$, if there exist evaluations
% $$\config{m, c, t_1, w} \to^{*} \config{m_1', \eskip, t_1', w_1'}$$
% % 
% $$\config{m, c, t_2, w} \to^{*} \config{m_2', \eskip, t_2', w_2'}$$
% %
% then:
% %
% \[
% t_1' - t_1 = t_2' - t_2
% \]
% \end{lem}
% %
% \begin{subproof}[Proof of Lemma~\ref{lem:tunique}]
% %
% Proof in File: {\tt ``lem\_tunique.tex''}
% % \input{lem_tunique}
% \end{subproof}
% }
%

%
%
%
%
%
%
%
% \subsection{SSA Transformation and Soundness of Transformation}
% in File {\tt ``ssa\_transform\_sound.tex''}
% \input{ssa_transform_sound}
%
\clearpage