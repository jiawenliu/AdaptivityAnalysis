\documentclass{article}
\usepackage[utf8]{inputenc}
\input{prelude}
\input{ldef}
\begin{document}

\title{Adaptive Analysis}
\maketitle

% \begin{enumerate}
% \item [Type] the premise $\Delta;\psi_a; \Phi_a  \vDash  {\cleq{I' }{I} \land I' \in \beta}$ will generate the constraint $\forall \Delta. \forall \Psi_a. (\Phi \to \cleq{I' }{I} \land I' \in \beta ) $, where $\beta : array \, bool$ and $I' \in \beta$ is the same as $\beta[I'] = true$.  Z3 will first check this constraint from the premise and if the  result is valid, we keep on checking, otherwise, exit immediately. The reason why we can first check the premise is that $I' \leq I$ and $I' \in \beta$ do not rely on the new generated existential variables in $\Psi_1$ and $\Psi_2$. Right now what I am doing is generating this premise constraint using why3 array module. \\

% \item [let] I remove the separation logic in the let because it will bring non-determinism in the algorithmic typing rules of let. The corresponding algorithmic typing rules follows.

% \item [fix extension] using fix-extension rule in the last page, I plan to add one more annotation of fix with two unary type into the core language.


% \end{enumerate}

 \begin{figure}[h]
 $$
 \begin{array}{rcl}
     \text{Types} & \quad & \tau ::= b \sep \tau \multimap \tau' \sep !_n \tau \sep
     \tau \times \tau \sep \tforallN{i}{\tau} \sep \query \\[2mm]

     \text{Term} & \quad & t ::= c \sep \fix{t} \sep \app{t}{t} \sep !t \sep (t_1,t_2) \sep  \letx{!x}{t_1}{t_2} \sep \Lambda.t \sep t[] \sep \abs{x}{t} \sep  M(t) \sep x \sep q \sep\\
     && \quad   \tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b}  \sep \letx{(x_1,x_2)}{t_1}{t_2} \\[2mm]
      
     \text{Normal Form} &\quad & v ::=  c \sep \fix{t} \sep !t \sep (v_1, v_2) \sep \Lambda. t \sep \abs{x}{t}  \sep x \sep q \sep \tcaseof{v}\ \{c_i \Rightarrow v_i\}_{c_i \in b_i} \sep\\
     && \enil \sep \econs(v_1,v_2)  \\[2mm]

     \text{Mechanisms} &\quad & M ::=  {\tt gauss} \sep {\tt thdt} \\[2mm]


	\text{Tree} &\quad& T_b :: = c \sep M(T_{query}) \sep \tcaseof{T_b}\ \{ c_i \Rightarrow T_{b_i}\}_{c_i \in b} \\

	\text{} &\quad& T_{query} :: = q \sep \tcaseof{T_b}\ \{ c_i \Rightarrow T_{query_i}\}_{c_i \in b} \\[2mm]
     \text{Depth} &\quad&   \depth(c) = 0 \\
       &\quad& \depth(!t) = \depth(t) \\
           &\quad&      \depth( \app{t_1}{t_2} ) = \max(\depth(t_1), \depth(t_2)) \\
            &\quad&  \depth(M(t)) = 1 + \depth(t) \\
             &\quad&  \depth(\abs{x}{t}) = \depth(t) \\
              &\quad& \depth(x) = 0 \\
              & \quad & \depth(q) = 0 \\
              & \quad & \depth((t_1, t_2)) = \max(\depth(t_1), \depth(t_2))\\
              & \quad & \depth(\letx{(x_1, x_2)}{t}{t'}) = \max(\depth(t), \depth(t'))\\
              & \quad & \depth(\letx{!x}{t}{t'}) = \max(\depth(t), \depth(t'))\\
              & \quad & \depth(\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b}) = \max(\depth(t), \depth(t_i))\\
            & \quad & \depth(\Lambda.t) = \depth(t)\\
              & \quad & \depth(t\, []) = \depth(t)\\
\end{array}
$$
\caption{syntax}
\end{figure}

\clearpage
\begin{figure}
    Abstract example
$$
{\tt gauss}({\tt {\tt count}(\phi)})
$$
Concrete example
$$
{\tt gauss}({\tt {\tt count}(\lambda r. \pi_1 r \leq 5)})
$$
$$
{\tt gauss}({\tt {\tt count}(\lambda r. \pi_1 r \leq 0.134)}) +
{\tt gauss}({\tt {\tt count}(\lambda r. \pi_2 r = "hiv")})
$$

Depth 2\\
Abstract
  $$  \tcaseof{ {\tt gauss}({\tt {\tt count}(\phi)})  }\ \{c_i \Rightarrow {{\tt gauss}({\tt {\tt count}(\phi_i)})} \}_{c_i \in b} $$
Concrete
 $$ \phi =  \lambda r. \pi_1 r \leq 5 ; c_1 = 0, \phi_1 =  \lambda r. \pi_1 r \leq 5 ;  c_2 = 0.1,  \phi_2 =  \lambda r. \pi_1 r \leq 3; \cdots $$
 
 Depth 3: \\
    \begin{tabbing}
    $\tcaseof{ {\tt gauss}({\tt {\tt count}(\phi)})  }$ \\ $\{c_i \Rightarrow \tcaseof{ {\tt gauss}({\tt {\tt count}(\phi')})  }$ \\ $\{c_i' \Rightarrow {{\tt gauss}({\tt {\tt count}(\phi_i')})} \}_{c_i' \in b} \}_{c_i \in b}$
\end{tabbing}    

    \caption{simple examples}
    \label{fig:my_label}
\end{figure}

\begin{figure}
%%

Two-rounds:

\[
\begin{array}{l}
 \mathsf{let}\, !\mathsf{g} = ! \big( \mathsf{fix} \, f(j). \lambda k.  \\
 \hspace{.2cm} \mathsf{if}\, (j < k) \, \mathsf{then} \\
  \hspace{.8cm} \mathsf{let} \, a = M \, ( \lambda x. (x \,j)\cdot (x \,k) )  \, \mathsf{in} \\
  \hspace{1.2cm} (a, j) :: (f  \,(j+1) \, k) \\
 \hspace{1.2cm} \mathsf{else} \, [] \big) \\
  \hspace{.2cm} \mathsf{in} \\
  \mathsf{let}\, !l = !\mathsf{g} \, 0\, K \, \mathsf{in} \\
  \mathsf{let} \, ! q = ! \lambda x. \mathsf{sign} \, (\mathsf{foldl} \, (\lambda acc. \lambda (a,i). \big(acc\,+ (x \, i) *lg(\frac{1+a}{1-a})  \big) \, 0 \, l )) \, \mathsf{in} \\
  M ( q )
\end{array}
\]
% \begin{tabbing}
%     $\mathsf{let}\, !g = ! \big( \mathsf{fix} \, f(j). \lambda k.$ \\
%     $\hspace{0.4cm} \mathsf{if}\, (j < k) \, \mathsf{then}$ \\
%     $\hspace{0.8cm} \mathsf{let} \, a = M \, ( \lambda x. (x \,j)\cdot (x \,k) )  \, \mathsf{in}$\\
%     $\hspace{1.2cm} (a, j) :: (f  \,(j+1) \, k) $\\
%     $\hspace{0.4cm} \mathsf{else} \, [] \big)  $\\
%     $\mathsf{in} $\\
%     $  \mathsf{let}\, !l = !g \, 0\, K $\\
%     $\mathsf{in}$\\
%     $\mathsf{let} \, ! q = ! \lambda x. \mathsf{sign} \, (\mathsf{foldl} \, (\lambda acc. \lambda (a,i). \big(acc\,+ (x \, i) *lg(\frac{1+a}{1-a})  \big) \, 0 \, l )) $ \\
%     $\mathsf{in}$\\
%     $ M ( q ) $
% \end{tabbing}  

\begin{tabbing}
    $ x: \tint \to  \tint   $ \\
    $ \cdot: \tint * \tint \to \tint $   \\
    $ g: \tint \to \tint \to \tlists{b * \tint} $\\
    $ q: \tquery $\\
    $ M: \tquery \to b $\\
\end{tabbing}
Type derivation:\\

Let $A = \big( \tint \to \tint \to \tlists{b * \tint} \big) $, $\Gamma = f: A, M : \tquery \to b, j: \tint, k: \tint\ $, $\Gamma_0 = M : \tquery \to b$, $[\Delta]_i = g: [A]_i, l:[\tlists{b*\tint}]_i, q:[\tquery]_i$.\\
\[
  \inferrule*[ right = LET-B ]
   {\Pi_L {\vartriangleright M : \tquery \to b \jtype{2}{}{! \mathsf{fix} \, f \cdots}{!_1 A}}
   \and
   \Pi_R {\vartriangleright M : \tquery \to b, g: [A]_1 \jtype{2}{}{\letx{!l}{! g \, 0\, K}{\letx{!q}{\cdots}{\cdots}}}{b}}
   }
   { M: \tquery \to b \jtype{2}{}{\letx{ !g}{! \mathsf{fix} \, f \cdots}{ \letx{!l}{\cdots}{\cdots}}}{b}}
\]

Derivation $\Pi_L$ and $\Pi_R$ are shown as follows:\\
$\Pi_L$:
\begin{mathpar}
  \inferrule*[ right = PR ]
    {
    \inferrule*[ right = FIX ]
    {
    \inferrule*[right = ABS]
    {
    \inferrule*[right = IF]
    {
    \inferrule*[right = BOOL]
    {
    \empty
    }
    {
    \Gamma \jtype{0}{}{j<k}{\tbool}
    }\and
    \inferrule*[right = LET]
    {
    \dots
    }
    {
    \Gamma \jtype{1}{}{\letx{a}{M \, ( \cdots )}{(a, j) :: \cdots}}{\tlists{b*\tint}}
    }\and
    \inferrule*[right = NIL]
    {
    \empty
    }
    {
    \Gamma \jtype{0}{}{[]}{\tlists{b*\tint}}
    }
    }
    {
    f: A, M : \tquery \to b, j: \tint, k: \tint\ \jtype{1}{}{\mathsf{if} \cdots}{ \tlists{b*\tint}}
    }
    }
    {
    f: A, M : \tquery \to b\ \jtype{1}{}{\lambda\, j. \lambda\, k. \mathsf{if} \cdots}{\tint \to \tint \to \tlists{b*\tint}}
    }
    }
    {M: \tquery \to b \jtype{1}{}{\mathsf{fix} \, f \cdots}{ A} }}
    {M: \tquery \to b \jtype{2}{}{! \mathsf{fix} \, f \cdots}{!_1 A}}
    
    
    \inferrule*[right = LET]
    {
    \inferrule*[right = MT]
        {
         \inferrule*[right = QUERY]
            {
                \empty
            }
            {
                \Gamma \jtype{0}{}{ \lambda x. (x \,j)\cdot (x \,k)}{\tquery}
            }
        }
        {
            \Gamma \jtype{1}{}{M\, ( \lambda x. (x \,j)\cdot (x \,k))}{b}
        }
    \and 
    \inferrule*[right = CONS]
        {
        \inferrule*[right = VAR]
            {
                \empty
            }
            {
                \Gamma, a: b \jtype{0}{}{(a, j) }{b*\tint}
            } \quad
        \inferrule*[right = APP]
            {
                \dots
            }
            {
                \Gamma, a: b \jtype{0}{}{(f \, j+1 \, k) }{\tlists{b*\tint}}
            }
        }
        {
            \Gamma, a: b \jtype{0}{}{(a, j) ::(f \, j+1 \, k) }{\tlists{b*\tint}}
        }
    }
    {
    \Gamma \jtype{1}{}{\letx{a}{M\, ( \lambda x. (x \,j)\cdot (x \,k))}{(a, j) ::(f \, j+1 \, k) }}{\tlists{b*\tint}}
    }
    \end{mathpar}

$\Pi_R$:
\begin{mathpar}
\inferrule*[right = LET-B]
    {
    \inferrule*[right = PR]
    {
    \inferrule*[right = DER]
    {
    \inferrule*[right = APP]
    {
    \dots
    }
    {
        g: A \jtype{0}{}{g \, 0\, K}{\tlists{b*\tint}}
    }
    }
    {
        g: [A]_0 \jtype{0}{}{g \, 0\, K}{\tlists{b*\tint}}
    }
    }
    {
        g: [A]_1 \jtype{1}{}{!g \, 0\, K}{!_1 \tlists{b*\tint}}
    }
    \quad
    \inferrule*[right = LET-B]
        {
        \inferrule*[right = PR]
            {
            \inferrule*[right = ABS]
                {
                \inferrule*[lab = VAR]
                    {
                    }
                    {
                        x:row \jtype{0}{}{sign \dots}{ b}
                    }
                }
                {
                    \jtype{0}{}{\lambda x. \dots}{row \to b}
                }
            }
            {
                \jtype{1}{}{!\lambda x. \dots}{!_1 row \to b}
            }
        \inferrule*[right = MT]
          {
          \inferrule*[right = QUERY]
              {
                  \empty
              }
              {
                  \Gamma_0, \Delta_0 \jtype{0}{}{q}{\tquery}
              }
          }
          {
                  \Gamma_0, [\Delta]_1 \jtype{1}{}{M(q)}{b}
          }
        }
        {
            \Gamma_0, g: [A]_1, l:[\tlists{b*\tint}]_1  \jtype{1}{}{\letx{!q}{\cdots}{\cdots}}{ b}
        }
    }
    {
        \Gamma_0, g: [A]_1 \jtype{1}{}{\letx{! l}{! g \, 0\, K}{\letx{! q}{ \dots }{ \dots }}}{b}
    }
\end{mathpar}
\caption{examples: two rounds}
\end{figure}


\begin{figure}
Evaluation:

\begin{mathpar}
\inferrule*[right = E-let-bang]
{
    \inferrule*[right = E-bang]
    {\empty}
    {
    \eval{!\mathsf{fix} \, f \cdots}{ ! \mathsf{fix} \, f \cdots}{0}
    }
\and 
    \inferrule*[right = E-fix]
    {\empty}
    {\eval{\mathsf{fix} \, f \cdots}{ \mathsf{fix} \, f \cdots}{0}
    }
\and
    \inferrule*[right = E-let-bang]
    {\dots}
    {\eval{\letx{!l}{!(\mathsf{fix} \dots 0 K)}{\cdots}}{c}{2}
    }
}
{\eval{\letx{!g}{! \mathsf{fix} \, f \cdots}{ \letx{!l}{\cdots}{\cdots}}}{c}{2}}

\inferrule*[right = E-let-bang]
{
    \inferrule*[right = E-bang]
    {\empty}
    {
    \eval{!(\mathsf{fix} \dots 0 K)}{ !(\mathsf{fix} \dots 0 K)}{0}
    }
\and
    \inferrule*[right = E-app]
    {\Pi_1}
    {
    \eval{\mathsf{fix} \dots 0 K}{c_1}{1}
    }
\and
    \inferrule*[right = E-let-bang]
    {\Pi_2}
    {
    \eval{\letx{!q}{!(! \lambda x. (\dots 0 c_1))}{M(q)}}{c}{1}
    }
}
{\eval{\letx{!l}{!(\mathsf{fix} \dots 0 K)}{\cdots}}{c}{2}
}

\Pi_1: \quad
\inferrule*[right = E-app]
{
    \inferrule*[right = E-fix]
    {\empty}
    {
    \eval{\mathsf{fix} \dots}{\lambda j. \lambda k. \dots}{0}
    }
\and 
    \inferrule*[right = E-values]
    {\empty}
    {
    \eval{0\, K }{0}{0\, K}
    }
\and 
    \inferrule*[right = E-if]
    {\Pi_{1-1}}
    {
    \eval{\mathsf{if} \dots \letx{a}{M(\dots)}{\dots}}{c_1}{1}
    }
}
{
\eval{\mathsf{fix} \dots 0\, K}{c_1}{1}
}

\Pi_{1-1}: \quad
\inferrule*[right = E-if]
{
    \inferrule*[right = E-let]
    {
        \inferrule*[right = E-mt]
        {\empty}
        {
        \eval{M(\dots)}{c_1'}{1}
        }
    \and
        \inferrule*[right = E-cons]
        {\empty}
        {
        \eval{(c_1', j)::(f (j + 1) K)}{c_1}{0}
        }
    }
    {
    \eval{\letx{a}{M(\dots)}{\dots}}{c_1}{1}
    }
\and
    \inferrule*[right = E-nil]
    {\empty}
    {
    \eval{[]}{[]}{0}
    }
}
{
\eval{\mathsf{if} \dots \letx{a}{M(\dots)}{\dots}}{c_1}{1}
}

\Pi_2: \quad
\inferrule*[lab = E-let-bang]
{
    \inferrule*[right = E-bang]
    {\empty}
    {
    \eval{!( \lambda x. (\dots 0\, c_1))}{ !( \lambda x. (\dots 0\, c_1))}{0}
    }
\and
    \inferrule*[right = E-query]
    {\empty}
    {
    \eval{\lambda x. (\dots 0\, c_1)}{q}{0}
    }
\and
    \inferrule*[right = E-mt]
    {\empty}
    {
    \eval{M(q)}{c}{1}
    }
}
{
\eval{\letx{!q}{!( \lambda x. (\dots 0\, c_1))}{M(q)}}{c}{1}
}


\end{mathpar}

\caption{examples: two rounds - evaluation}
\end{figure}




\begin{algorithm}
\caption{A two-round analyst strategy for random data (Algorithm 4 in ...)}
\label{alg:BitGOF}
\begin{algorithmic}
\REQUIRE Mechanism $\mathcal{M}$ with a hidden state $X\in \{-1,+1\}^{n\times (k+1)}$.
\STATE  {\bf for}\ $j\in [k]$\ {\bf do}.  
\STATE \qquad {\bf define} $q_j(x)=x(j)\cdot x(k)$ where $x\in \{-1,+1\}^{k+1}$.
\STATE \qquad {\bf let} $a_j=\mathcal{M}(q_j)$ 
\STATE \qquad \COMMENT{In the line above, $\mathcal{M}$ computes approx. the exp. value  of $q_j$ over $X$. So, $a_j\in [-1,+1]$.}
\STATE {\bf define} $q_{k+1}(x)=\mathrm{sign}\big (\sum_{i\in [k]} x(i)\times\ln\frac{1+a_i}{1-a_i} \big )$ where $x\in \{-1,+1\}^{k+1}$.
\STATE\COMMENT{In the line above,  $\mathrm{sign}(y)=\left \{ \begin{array}{lr} +1 & \mathrm{if}\ y\geq 0\\ -1 &\mathrm{otherwise} \end{array} \right . $.}
\STATE {\bf let} $a_{k+1}=\mathcal{M}(q_{k+1})$
\STATE\COMMENT{In the line above,  $\mathcal{M}$ computes approx. the exp. value  of $q_{k+1}$ over $X$. So, $a_{k+1}\in [-1,+1]$.}
\RETURN $a_{k+1}$.
\ENSURE $a_{k+1}\in [-1,+1]$
\end{algorithmic}
\end{algorithm}


\clearpage

\begin{figure}
    \centering
   Multi-rounds:

\[
\begin{array}{l}
 \mathsf{let}\, \mathsf{multi\_round} =   \mathsf{fix} \, f(j). \lambda k. \lambda D. \lambda I. \lambda S. \lambda SC.  \\
 \hspace{.2cm} \mathsf{if}\, (j < k) \, \mathsf{then} \\
  \hspace{.8cm} \mathsf{let} \, P_j =  \mathsf{uniform}(0,1) \, \mathsf{in} \\
  \hspace{1.2cm} \mathsf{let} q_j = \lambda x. \mathsf{if} (\mathsf{uniform}(0,1) < p_j ) \, \mathsf{then} \, 1 \, \mathsf{else} \, 0 \, \mathsf{in} \\
  \hspace{1.2cm} \mathsf{let} q_{j,c} = \lambda x. \mathsf{if} (\mathsf{uniform}(0,1) < p_j ) \, \mathsf{then} \, 1 \, \mathsf{else} \, 0 \, \mathsf{in} \\
  \hspace{1.6cm} \mathsf{let} q_{jd} =    \mathsf{in}\\
 \hspace{1.2cm} \mathsf{let} \, a_j = M (q_j) \, \mathsf{in} \\
 \hspace{1.4cm} \mathsf{let} \, S_{j,i} = \mathsf{updt1} \, S_{j,c} \, a_j \,  p_j \, q_j \mathsf{in}   \\
 \hspace{1.4cm}  \mathsf{let} \,  S_{j,c} = \mathsf{updt2} \, S_{j,c} \, a_j \, p_j \, q_{j,c} \, \mathsf{in}\\
 \hspace{1.6cm} \mathsf{let} \, I_j =  \mathsf{updt3} \, S \, SC \, \mathsf{in} \\
   f (j+1) \, k , (D \setminus I_j) \, I_j \, S_{j,i} \, S_{j,c}
\end{array}
\]
    \caption{Caption}
    \label{fig:my_label}
\end{figure}



\clearpage
\begin{figure}
   $$
 \begin{array}{rcl}
     \text{Types} & \quad & \tau ::= \tau_1 + \tau_2 \sep \tlists{\tau}   \\[2mm]

     \text{Term} & \quad & t ::= \einl \, t \sep \einr \, t \sep \enil \sep \econs (t_1,t_2) \sep \letx{x}{t_1}{t_2} \sep \ecase (t, x.t_1, y.t_2)
     
 \end{array}
     $$
     
     \boxed{  \Gamma \jtype{n,m}{}{t}{\tau}    }\\
     
     \begin{mathpar}
  \inferrule*[right = fix]
   { \Gamma, f : \tau_1 \multimap \tau_2, x: \tau_1 \jtype{n}{}{t}{\tau_2} }
   {\Gamma \jtype{n}{}{\fix{t} }{\tau_1 \multimap \tau_2}  }
   
  \inferrule*[ right = let ]
   {\Gamma_1 \jtype{n_1}{}{t}{\tau} \\ \Gamma_2, x:\tau \jtype{n_2}{}{t'}{\tau'}}
   { \max(\Gamma_1, \Gamma_2)  \jtype{\max(n_1,n_2)}{}{\letx{x}{t}{t'}}{\tau'}  }
   
    \inferrule*[ right = inl ]
   {\Gamma \jtype{n_1}{}{t}{\tau_1} }
   { \Gamma  \jtype{n_1}{}{ \einl \, t }{ \tau_1 + \tau_2 }  }
   
    \inferrule*[ right = inr ]
   {\Gamma \jtype{n_2}{}{t}{\tau_2} }
   { \Gamma  \jtype{n_2}{}{ \einr \, t }{ \tau_1 + \tau_2 }  }
   
   \inferrule*[ right = case ]
   {\Gamma_1 \jtype{n_1}{}{t}{\tau_1 + \tau_2} \\ \Gamma_2, x:\tau_1 \jtype{n_2}{}{t_1}{\tau}
   \\ \Gamma_3, y :\tau_2 
   \jtype{n_3}{}{t_2}{\tau}}
   { \max(\Gamma_1, \Gamma_2,\Gamma_3)  \jtype{\max(n_1,n_2,n_3)}{}{ \ecase (t, x.t_1, y.t_2)}{\tau}  }
   
   \inferrule*[right = nil]
   {   \wfty{\tau}   }
   {\Gamma \jtype{0}{}{\enil }{\tlists{\tau} }  }
   
     \inferrule*[ right = cons ]
   {\Gamma_1 \jtype{n_1}{}{t_1}{\tau} \\
    \Gamma_2 \jtype{n_2}{}{t_2}{\tlists{\tau} }}
   { \max(\Gamma_1,\Gamma_2)  \jtype{\max(n_1,n_2)}{}{ \econs \, (t_1,t_2) }{ \tlists{\tau} }  }
   
   \end{mathpar}
    \boxed{  \tau \subseteq \tau  }\\
   \begin{mathpar}
     \inferrule*[right= S-pair]
  {  }
  { ( !_i \tau_1 , !_j \tau_2) \subseteq !_{\max(i,j)} (\tau_1,\tau_2)  }
  
     \inferrule*[right= S-list]
  {  }
  {  \tlists{!_i \tau_1}  \subseteq !_i \tlists{\tau_1}  }
   \end{mathpar}
     
    \caption{New added components}
    \label{fig:my_label}
\end{figure}

\clearpage
\begin{figure}
\boxed{  \Gamma \jtype{n,m}{}{t}{\tau}    }\\
\boxed{  \Gamma :: = \emptyset \sep \Gamma, x : \tau \sep \Gamma, x : [\tau]_p   }

\begin{mathpar}
  \inferrule*[right = const]
   {\empty}
   {\Gamma \jtype{n,m}{}{c}{b}  }
   
   \and
    \inferrule*[right = abs]
   {\Gamma, x: \tau_1 \jtype{n}{}{t}{\tau_2}}
   { \Gamma \jtype{n,m}{}{\abs{x}{t}}{\tau_1 \multimap \tau_2}  }
   
   \and
   \inferrule*[right = pr]
   {[\Gamma] \jtype{n}{}{t}{\tau}}
   {\Delta, p + [\Gamma] \jtype{n+p}{}{!t}{!_p \tau}  }
%   \boxed{
%   \inferrule*[right = pr]
%   {[\Gamma] \jtype{n}{}{t}{\tau}}
%   {p + [\Gamma]\textbf{} \jtype{n}{}{!t}{!_p \tau}  }}
   
   \and
    \inferrule*[ right = var]
   {\empty}
   {\Gamma, x:\tau \jtype{n}{}{x}{\tau}  } 
   
   \and
   \inferrule*[ right = MT ]
   {[\Gamma] \jtype{n}{}{t}{query}}
   {\Delta, 1 + [\Gamma] \jtype{n+1}{}{M(t)}{b}  }
   
   \and
    \inferrule*[right = query]
   {\empty}
   {\Gamma \jtype{n}{}{q}{query}  }
   
   \and
%     \inferrule*[ right = app ]
%   {\Gamma_1 \jtype{n_1}{}{t_1}{\tau_1 \rightarrow \tau_2} \\ \Gamma \jtype{n_2}{}{t_2}{\tau_1}}
%   { \Gamma_2 \jtype{\max(n_1,n_2)}{}{\app{t_1}{t_2}}{\tau_2}  }
  \inferrule*[ right = app ]
   {\Gamma_1 \jtype{n_1}{}{t_1}{\tau_1 \multimap \tau_2} \\ \Gamma_2 \jtype{n_2}{}{t_2}{\tau_1}}
   { \max(\Gamma_1, \Gamma_2) \jtype{\max(n_1,n_2)}{}{\app{t_1}{t_2}}{\tau_2}  }
   
   \and 
   
%   \inferrule*[ right = der ]
%   {\Gamma, x: \tau \jtype{n}{}{t}{ \tau }  }
%   { \Gamma , x: [\tau]_p \jtype{n }{}{t }{\tau }  }
   \boxed{
   \inferrule*[ right = der ]
   {\Gamma, x: \tau \jtype{n}{}{t}{ \tau }  }
   { \Gamma , x: [\tau]_0 \jtype{n }{}{t }{\tau }  }
 }
   
   \and 
   
   \inferrule*[ right = let-b ]
   {\Gamma_1 \jtype{n_1}{}{t}{!_p \tau} \\ \Gamma_2, x: [\tau]_p \jtype{n_2}{}{t'}{\tau'}}
   { \max(\Gamma_1, \Gamma_2)  \jtype{\max(n_1,n_2)}{}{\letx{!x}{t}{t'}}{\tau'}  }
   
   \and 
   \inferrule*[ right = let-p ]
   {\Gamma_1 \jtype{n_1}{}{t}{\tau_1 \times \tau_2 } \\ \Gamma_2, x_1: \tau_1, x_2 : \tau_2 \jtype{n_2}{}{t'}{\tau'}}
   { \max(\Gamma_1, \Gamma_2)  \jtype{\max(n_1,n_2)}{}{ \letx{(x_1,x_2)}{t}{t'} }{\tau'}  }
   
   \and
     \inferrule*[right = pair]
   {\Gamma_1 \jtype{n_1}{}{t_1}{\tau_1} \\ \Gamma_2 \jtype{n_2}{}{t_2}{\tau_2}}
   { \max(\Gamma_1, \Gamma_2)  \jtype{\max(n_1,n_2)}{}{(t_1, t_2)}{\tau_1 \times \tau_2}  }
 
   \and
    \inferrule*[ right = case-const ]
   {\Gamma_1 \jtype{n_1}{}{t}{b} \\ \Gamma_2 \jtype{n_2}{}{t_i}{b} }
   {\max(n_2 + \Gamma_1, \Gamma_2)  \jtype{ (n_1+n_2)}{}{\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b} } {b} }
   
   \and
    \inferrule*[ right = case-query]
   {\Gamma_1 \jtype{n_1}{}{t}{b} \\ \Gamma_2 \jtype{n_2}{}{t_i}{query} }
   {\max(\Gamma_1, \Gamma_2) \jtype{ (n_1+n_2)}{}{\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b} } {query} }
   
   \inferrule*[right = iabs]
  { 
    \inferrule*[]
    {}
    {i::\mathbb{N};\Gamma \jtype{n}{}{t}{ \tau } }
    \and
    \inferrule*[]
    {}
    { i \notin \fiv{\Gamma }  } 
  }
  { \Gamma \jtype{n}{ }{  \Lambda.t  }{ \tforallN{i}{\tau}  } }
  
   \inferrule*[ right =  iapp]
  { 
    \inferrule*[]
    {}
    { \Gamma  \jtype{n}{}{t}{ \tforallN{i}{\tau}   } }
    \and
    \inferrule*[]
    {}
    { \jiterm{I}{ \mathbb{N} } } 
  }
  {\Gamma \jtype{n }{ }{t\, [] }{ \tau \{ I/i \}  } }

  \inferrule*[right = sub]
  { 
   { \Gamma \jtype{n}{}{t}{\tau} } \\
   {  \Gamma' \subseteq \Gamma } \\
   { \vDash n \leq n' } \\
   { \tau \subseteq \tau' }
  }
  { \Gamma' \jtype{n'}{}{t}{\tau'} }
\end{mathpar}
\caption{Typing judgment}
\end{figure}

\clearpage

\begin{figure}
 \begin{mathpar}
  
  \inferrule*[right= S-ID]
  { }
  { \tau <: \tau  }
  \and
  \inferrule*[right = S-B]
  { 
   {A <: B}
   \\
   { q \leq p }
  }
  { !_p A <: !_q B  }
  \and
  \inferrule*[right =  S-ARROW]
  { {A' <: A}
    \\
    {B <: B'}
  }
  { A \multimap B <: A' \multimap B' }
  \and
  \inferrule*[right = S-D ]
  {
    { A \subseteq B }\\
    { q \leq p }
  }
  { [A]_p \subseteq [B]_q }
  
  \and
  \inferrule*[right = S-IDC]
  { }
  { \Gamma \subseteq \Gamma }
  
   \and
  \inferrule*[right = S-empty]
  { }
  { \Gamma \subseteq \emptyset }
  
  \and
  \inferrule*[right = S-Ctx]
  {
  {A \subseteq B}\\
  { \Gamma \subseteq \Delta }
  }
  { \Gamma, x: A \subseteq \Delta, x: B }
  
  \and
  \inferrule*[right = S-xctx1]
  {
  { \Delta \subseteq \Gamma }
  }
  { x : \tau, \Delta \subseteq \Gamma }
  
  \and
  \inferrule*[right = S-xctx2]
  {
  { \Delta \subseteq \Gamma }
  }
  { x : [\tau]_p, \Delta \subseteq \Gamma }
  
 \end{mathpar}
 \caption{sub typing}
\end{figure}



% \begin{figure}
% \boxed{  \Gamma \jtype{n,m}{}{t}{\tau}    }
% \boxed{  \Gamma :: = \emptyset \sep \Gamma, [\tau]_p   } \\
% \boxed{ \max \big( (x:[\tau]_{p_1},\Gamma_1 ),(x:[\tau]_{p_2},\Gamma_2) \big ) \triangleq x:[\tau]_{\max(p_1,p_2)}, \max(\Gamma_1,\Gamma_2) \qquad
% \max(\emptyset, \Gamma_2) \triangleq \Gamma_2  \qquad \max(\Gamma_1, \emptyset) \triangleq \Gamma_1 
% }

% \begin{mathpar}
%   \inferrule*[right = const]
%   {\empty}
%   {\Gamma \jtype{0}{}{c}{b}  }
   
%   \and
%     \inferrule*[right = abs]
%   {\Gamma, x: [\tau_1]_{0} \jtype{n}{}{t}{\tau_2}}
%   { \Gamma \jtype{n}{}{\abs{x}{t}}{\tau_1 \multimap \tau_2}  }
   
%   \and
%   \inferrule*[right = pr]
%   {\Gamma \jtype{n}{}{t}{\tau}}
%   {p + \Gamma \jtype{n}{}{!t}{!_p \tau}  }
   
%   \and
%     \inferrule*[ right = var]
%   {\empty}
%   {\Gamma, x:[\tau]_p \jtype{0}{}{x}{\tau}  } 
   
%   \and
%   \inferrule*[ right = MT ]
%   {\Gamma \jtype{n}{}{t}{query}}
%   {1 + \Gamma \jtype{n+1}{}{M(t)}{b}  }
   
%   \and
%     \inferrule*[right = query]
%   {\empty}
%   {\Gamma \jtype{0}{}{q}{query}  }
   
%   \and
%     \inferrule*[ right = app ]
%   {\Gamma_1 \jtype{n_1}{}{t_1}{\tau_1 \rightarrow \tau_2} \\ \Gamma_2 \jtype{n_2}{}{t_2}{\tau_1}}
%   { \max(\Gamma_1,\Gamma_2) \jtype{\max(n_1,n_2)}{}{\app{t_1}{t_2}}{\tau_2}  }
   
%   \and 
   
% %   \inferrule*[ right = der ]
% %   {\Gamma, x: \tau \jtype{n}{}{t}{ \tau }  }
% %   { \Gamma , x: [\tau]_p \jtype{n }{}{t }{\tau }  }
   
% %   \and 
   
%   \inferrule*[ right = let ]
%   {\Gamma_1 \jtype{n_1}{}{t}{!_p \tau} \\ \Gamma_2, x: [\tau]_p \jtype{n_2}{}{t'}{\tau'}}
%   { \max(\Gamma_1,\Gamma_2) \jtype{\max(n_1,n_2)}{}{\letx{!x}{t}{t'}}{\tau'}  }
   
%   \and 
%   \inferrule*[ right = let-p ]
%   {\Gamma_1 \jtype{n_1}{}{t}{\tau_1 \times \tau_2 } \\ \Gamma_2, x_1: \tau_1, x_2 : \tau_2 \jtype{n_2}{}{t'}{\tau'}}
%   { \max(\Gamma_1,\Gamma_2)  \jtype{\max(n_1,n_2)}{}{ \letx{(x_1,x_2)}{t}{t'} }{\tau'}  }
   
%   \and
%      \inferrule*[right = pair]
%   {\Gamma_1 \jtype{n_1}{}{t_1}{\tau_1} \\ \Gamma_2 \jtype{n_2}{}{t_2}{\tau_2}}
%   { \max(\Gamma_1,\Gamma_2)  \jtype{\max(n_1,n_2)}{}{(t_1, t_2)}{\tau_1 \times \tau_2}  }
 
%   \and
%     \inferrule*[ right = case-const ]
%   {\Gamma_1 \jtype{n_1}{}{t}{b} \\ \Gamma_2 \jtype{n_2}{}{t_i}{b} }
%   {\max(\Gamma_1,\Gamma_2) \jtype{\max(n_1,n_2)}{}{\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b} } {b} }
   
%   \and
%     \inferrule*[ right = case-query]
%   {\Gamma_1 \jtype{n_1}{}{t}{b} \\ \Gamma_2 \jtype{n_2}{}{t_i}{query} }
%   {\max(\Gamma_1,\Gamma_2) \jtype{\max(n_1,n_2)}{}{\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b} } {query} }
   
%   \inferrule*[right = iabs]
%   { 
%     \inferrule*[]
%     {}
%     {i::\mathbb{N};\Gamma \jtype{n}{}{t}{ \tau } }
%     \and
%     \inferrule*[]
%     {}
%     { i \notin FV(\Gamma )  } 
%   }
%   { \Gamma \jtype{n}{ }{  \Lambda.t  }{ \tforallN{i}{\tau}  } }
  
%   \inferrule*[ right =  iapp]
%   { 
%     \inferrule*[]
%     {}
%     { \Gamma  \jtype{n}{}{t}{ \tforallN{i}{\tau}   } }
%     \and
%     \inferrule*[]
%     {}
%     { \jiterm{I}{ \mathbb{N} } } 
%   }
%   {\Gamma \jtype{n }{ }{t\, [] }{ \tau \{ I/i \}  } }
% \end{mathpar}
% \caption{Typing judgment (with only discharged variables in the context) }
% \end{figure}

\clearpage



\begin{figure}
\boxed{\eval{t }{v }{m}}
\begin{mathpar}
%  \inferrule*[ right=E-values]
%   { }
%   { \eval{ F   }{ F  }{0}}   
%   \and
 \inferrule*[ right=E-const]
  { }
  { \eval{ c   }{ c  }{0}}   
  
  \and

 \inferrule*[ right=E-query]
  { }
  { \eval{  q  }{ q  }{0}}   
  
  \and

 \inferrule*[ right=E-ABS]
  { }
  { \eval{ \abs{x}{t}   }{ \abs{x}{t}  }{0}}   
  
  \and
  
  \inferrule*[ right=E-bang]
  { }
  { \eval{ ! t   }{ ! t  }{0}}   
  
  \and
  
   \inferrule*[ right=E-pair]
  {   
    { \eval{ t_1  }{ v_1  }{m_1} }
    \\
    { \eval{ t_2  }{ v_2  }{m_2} } 
  }
  { \eval{  (t_1,t_2)  }{ (v_1,v_2)  }{ \max(m_1, m_2) %m_1+m_2
  } }  
  
  \and

   \inferrule*[ right=E-app]
  {   
    { \eval{ t_1  }{ \abs{x}{t}  }{m_1} }
    \\
    { \eval{ t_2  }{ v  }{m_2} } 
    \\
    { \eval{t[v/x] }{ v'}{m_3 } }
  }
  { \eval{ \app{t_1}{t_2}  }{ v'  }{ \max(m_1, m_2 ) + m_3  } }  
 
 \boxed{ 
   \inferrule*[ right=E-let-bang]
  {   
    { \eval{ t_1  }{ !t_3  }{m_1} } 
    \\
    {\eval{t_3}{v'}{m_2}}
    \\
    { \eval{t_2[v'/x] }{v}{m_3 } }
  }
  { \eval{  \letx{!x}{t_1}{t_2}  }{ v  }{ \max(m_1+ m_2, m_3)  } }  
}

%  \inferrule*[ right=E-let-bang]
%   {   
%     { \eval{ t_1  }{ !t_3  }{m_1} } 
%     \\
%     { \eval{t_2[!t_3 /x] }{ F}{m_3 } }
%   }
%   { \eval{  \letx{!x}{t_1}{t_2}  }{ F  }{ m_1+m_3  } } 
  
  \inferrule*[ right=E-let-p]
  {   
    { \eval{ t  }{ (v_1,v_2)  }{m_1} } 
    \\
    { \eval{t'[v_1/x_1][v_2/x_2] }{v}{m2 } }
  }
  { \eval{  \letx{(x_1,x_2)}{t}{t'}  }{ v  }{ \max(m_1,m_2)  } } 
  
 

  \inferrule*[ right=E-case]
  { 
    \inferrule*[]
    {}
    {\eval{  t  }{ v }{m }  }
    \\
    \inferrule*[]
    {}
    { \eval{ t_i  }{ v_i   }{ m_i }  }
  }
  { \eval{ \tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b}  }{ \tcaseof{v}\ \{c_i \Rightarrow v_i\}_{c_i \in b}  }{  m + \max(m_i) } }
  
    \inferrule*[ right=E-fix]
  { 
  }
  { \eval{  \fix{t}  }{ \fix{t}  }{ 0 } }
  
      \inferrule*[ right=E-x]
  { 
  \empty
  }
  { \eval{  x  }{ x  }{ 0 } }
  
      \inferrule*[ right=E-ILAM]
  { 
    \empty
  }
  { \eval{  \Lambda. t  }{  \Lambda. t }{ 0 } }
  
      \inferrule*[ right=E-iapp]
  { 
    \inferrule*[]
    {}
    {\eval{  t  }{ \Lambda. t' }{m }  }
  }
  { \eval{  t[]  }{  t' }{  m } }
  
      \inferrule*[ right=E-mech]
  { 
    \inferrule*[]
    {}
    {\eval{  t  }{ v }{m }
    \and 
    \eval{M(v)}{v'}{1}
    }
  }
  { \eval{  M(t)  }{ v'  }{  m + 1 } }
  
\end{mathpar}
 \caption{Evaluation Rules}
\end{figure}

\begin{figure}
\begin{mathpar}

\inferrule*[right = E-if-true]
{
 \eval{b}{true}{0}
 \and 
 \eval{t_1}{v_1}{m} 
}
{
\eval{\tif{b}{t_1}{t_2}}{v_1}{m}
}

\inferrule*[right = E-if-false]
{
 \eval{b}{false}{0}
 \and 
 \eval{t_2}{v_2}{m} 
}
{
\eval{\tif{b}{t_1}{t_2}}{v_2}{m}
}

\inferrule*[right = E-nil]
{
 \empty
}
{
\eval{\enil}{\enil}{0}
}

\inferrule*[right = E-cons]
{
\eval{t_1}{v_1}{m_1}
\and 
\eval{t_2}{v_2}{m_2}
}
{
\eval{\econs(t_1,t_2)}{\econs(v_1,v_2)}{\max(m_1,m_2)}
}


\inferrule*[right = E-let]
{
\eval{t_2}{v_2}{m_2}
\and
\eval{t[v_2/x]}{v}{m}
}
{
\eval{\letx{x}{t_2}{t}}{v}{\max(m_2,m)}
}

\end{mathpar}
 \caption{New Added Evaluation Rules}
\end{figure}


\begin{figure*}
$$
\begin{array}{rcl}
      \llu{\tau}{\epsilon}  &\quad &  = \{ \, e \, | \, \exists v. e \Downarrow v \land v \in   \llu{\tau}{v} \,  \}  \\[2mm]
      \llu{b}{v} &\quad &  = \{ \,  v  \, | \, v = T_b \}  \\[2mm]
      \llu{query}{v} &\quad &  = \{ \,  v \, |  \, v = T_{query} \}  \\[2mm]
      \llu{\tau_1 \rightarrow \tau_2}{v} & \quad & = \{\, \abs{x}{t} \, | \, \forall v \in\llu{\tau}{v}. t[v/x] \in \llu{\tau_2}{\epsilon} \, \} \\[2mm]
      \llu{ \ !_n \tau}{v} & \quad & = \{\, !t \, | \, t \in \llu{\tau}{\epsilon} \, \} \\[2mm]
      \llu{\tforallN{i}{\tau}}{v}  & \quad & = \{  \Lambda. t \, | \, \forall I. \vdash i :: \mathbb{N}. t[I/i] \in \llu{\tau}{\epsilon}   \}  \\[2mm]
      \llu{\tau_1 * \tau_2}{v}  & \quad & = \{  (v_1, v_2) \, | \, v_1 \in \llu{\tau_1}{v} \land v_2 \in \llu{\tau_2}{v}     \} \\[2mm]
      \llu{\cdot}{} &\quad & = \{ \emptyset \} \\[2mm]
      \llu{\Gamma, x : [\tau]_p}{} & \quad & = \{ \gamma[x \rightarrow v] | v \in \llu{\tau}{v} \land \gamma \in \llu{\Gamma}{}   \}  \\ [2mm]
      \boxed{\llu{\Gamma, x : [\tau]_p}{}}  & \quad & = \{ \gamma[x \rightarrow v] | v \in \llu{!_p \tau}{v}  \land \gamma \in \llu{\Gamma}{}   \}  \\ [2mm]
      \llu{\Gamma, x : \tau}{} & \quad & = \{ \gamma[x \rightarrow v] | v \in \llu{\tau}{v} \land \gamma \in \llu{\Gamma}{}   \}  \\ [2mm]
      \gamma \vDash \Gamma &\quad & \triangleq dom(\gamma) = dom(\Gamma) \land \forall x \in dom(\Gamma). \gamma(x) \in \llu{\Gamma(x)}{v}
\end{array}
$$
\caption{denotations}
\end{figure*}

\clearpage


\begin{lemma} $ $
	\label{lem:1}
    \begin{enumerate}
\item If $\jtype{n,m}{}{v}{b} $ then $ \exists T_{b} : v = T_{b}$.\\
\item If $\jtype{n,m}{}{v}{query} $ then $ \exists T_{query} : v = T_{query}$
\end{enumerate}
	
	
\end{lemma}

\clearpage
\begin{lemma}[Depth Definition] 
	\label{lem:2}
	If $\Gamma \jtype{n,m}{}{t}{\tau} $ then $\depth(t) \leq n$\\
\end{lemma}
\begin{proof}
 It is proved by the induction on the structure of the typing derivation.\\
 \noindent \textbf{Case} 
 \[
 \inferrule*[right = pr]
   {\Gamma \jtype{n}{}{t}{\tau} ~(\star) } 
   {p + \Gamma \jtype{n}{}{!t}{!_p \tau}  }
 \]
 TS: $\depth(!t) \leq n $.\\
 By IH on $(\star)$, we get $\depth(t) \leq n $ \\
 This case is proved because $\depth(!t)= \depth(t)$.
 
 \noindent \textbf{Case} 
 \[
  \inferrule*[right = const]
   {\empty}
   {\Gamma \jtype{0}{}{c}{b}  }
 \]
 TS: $\depth(c) \leq 0$ \\
 It is already proved by the definition of $\depth(c)$.
 
  \noindent \textbf{Case} 
  \[
   \inferrule*[right = abs]
   {\Gamma, x: [\tau_1]_{0} \jtype{n}{}{t}{\tau_2} ~(\star)}
   { \Gamma \jtype{n}{}{\abs{x}{t}}{\tau_1 \multimap \tau_2}  }
  \]
  TS: $\depth(\abs{x}{t}) \leq n $. \\
  By IH on ~($\star$) instantiating the context with $\Gamma, x: [\tau]_0 $, we get : $\depth(t) \leq n $. \\
    This case is proved by the definition of $\depth(\abs{x}{t})$.
  
   \noindent \textbf{Case} 
  \[
   \inferrule*[ right = MT ]
   {\Gamma \jtype{n}{}{t}{query} ~ (\star) }
   {1 + \Gamma \jtype{n+1}{}{M(t)}{b}  }
  \]
   TS: $\depth( M(t) ) \leq n+1 $. \\
   By IH on ($\star$), we get $\depth(t) \leq n $. \\
   It is proved by the definition of $\depth(M(t)) = \depth(t) + 1 $.
   
   \noindent \textbf{Case} 
   \[
    \inferrule*[ right = var]
   {\empty}
   {\Gamma, x:[\tau]_p \jtype{0}{}{x}{\tau}  } 
   \]
   TS: $\depth(x) \leq 0$. \\
   It is proved by the definition of $\depth(x)$. \\
   
    \noindent \textbf{Case} 
    \[
     \inferrule*[ right = app ]
   {\Gamma_1 \jtype{n_1}{}{t_1}{\tau_1 \rightarrow \tau_2} ~ (\star) \\ \Gamma_2 \jtype{n_2}{}{t_2}{\tau_1}~(\diamond)}
   { \max(\Gamma_1,\Gamma_2) \jtype{\max(n_1,n_2)}{}{\app{t_1}{t_2}}{\tau_2}  }
    \]
    TS: $\depth(\app{t_1}{t_2}) \leq \max(n_1,n_2) $. \\
    By IH on ($\star$) and ($\diamond$), we get: $\depth(t_1) \leq n_1~(\star\star) $ and $\depth(t_2) \leq n_2 (\diamond\diamond)$. \\
    Unfold the definition of $\depth(\app{t_1}{t_2}) = \max(\depth(t_1), \depth(t_2))$.\\
    This case is proved by the ($\star\star$) and ($\diamond\diamond$).
    
    \noindent \textbf{Case}
 \[
 \inferrule*[right = query]
   {\empty}
   {\Gamma \jtype{0}{}{q}{query}  }
   \]
TS: $\depth(q) \leq 0$.\\
This is proved by the definition of $\depth(q)$.

 \noindent \textbf{Case} 
   \[
   \inferrule*[ right = let ]
   {\Gamma_1 \jtype{n_1}{}{t}{!_p \tau} ~ (\star) \\ \Gamma_2, x: [\tau]_p \jtype{n_2}{}{t'}{\tau'}  ~ (\diamond)}
   { \max(\Gamma_1,\Gamma_2) \jtype{\max(n_1,n_2)}{}{\letx{!x}{t}{t'}}{\tau'}  }
   \]
   To show: $\depth(\letx{!x}{t}{t'}) \leq \max(n_1,n_2)$.\\
     By induction Hypothesis on ($\star$) and ($\diamond$), we get:
   $\depth(t) \leq n_1~(\star\star)$ and $\depth(t') \leq n_2 ~ (\diamond\diamond)$.\\
   Unfolding the definition of $\depth(\letx{!x}{t}{t'}) = \max(\depth(t), \depth(t'))$.\\
   This case is proved by the ($\star\star$) and ($\diamond\diamond$).
   
 \noindent \textbf{Case} 
   \[   
   \inferrule*[ right = let-p ]
   {\Gamma_1 \jtype{n_1}{}{t}{\tau_1 \times \tau_2 } ~ (\star)  \\ \Gamma_2, x_1: \tau_1, x_2 : \tau_2 \jtype{n_2}{}{t'}{\tau'}  ~ (\diamond)}
   { \max(\Gamma_1,\Gamma_2)  \jtype{\max(n_1,n_2)}{}{ \letx{(x_1,x_2)}{t}{t'} }{\tau'}  }
    \]
     To show: $\depth(\letx{(x_1, x_2)}{t}{t'}) \leq \max(n_1,n_2)$.\\
     By induction Hypothesis on ($\star$) and ($\diamond$), we get:
   $\depth(t) \leq n_1~(\star\star)$ and $\depth(t') \leq n_2 ~ (\diamond\diamond)$.\\
   Unfolding the definition of $\depth(\letx{(x_1, x_2)}{t}{t'}) = \max(\depth(t), \depth(t'))$.\\
   This case is proved by the ($\star\star$) and ($\diamond\diamond$).
 
 \noindent \textbf{Case} 
   \[
     \inferrule*[right = pair]
   {\Gamma_1 \jtype{n_1}{}{t_1}{\tau_1} ~ (\star)  \\ \Gamma_2 \jtype{n_2}{}{t_2}{\tau_2} ~ (\diamond)}
   { \max(\Gamma_1,\Gamma_2)  \jtype{\max(n_1,n_2)}{}{(t_1, t_2)}{\tau_1 \times \tau_2}  }
    \]
    To show: $\depth((t_1, t_2)) \leq \max(n_1,n_2)$.\\
    By induction Hypothesis on ($\star$) and ($\diamond$), we get:
    $\depth(t_1) \leq n_1~(\star\star)$ and $\depth(t_2) \leq n_2 ~ (\diamond\diamond)$.\\
    Unfolding the definition of $\depth((t_1, t_2)) = \max(\depth(t_1), \depth(t_2))$.\\
    This case is proved by the ($\star\star$) and ($\diamond\diamond$).
 
 \noindent \textbf{Case} 
   \[
    \inferrule*[ right = case-const ]
   {\Gamma_1 \jtype{n_1}{}{t}{b} ~ (\star) \\ \Gamma_2 \jtype{n_2}{}{t_i}{b} ~ (\diamond) }
   {\max(\Gamma_1,\Gamma_2) \jtype{\max(n_1,n_2)}{}{\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b} } {b} }
   \]
    To show: $\depth( \tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b} ) \leq \max(n_1,n_2)$.\\
    By induction Hypothesis on ($\star$) and ($\diamond$), we get:
    $\depth(t) \leq n_1~(\star\star)$ and $\depth(t_i) \leq n_2 ~ (\diamond\diamond)$.\\
    Unfolding the definition of $\depth(\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b}) = \max(\depth(t), \depth(t_i))$.\\
    This case is proved by the ($\star\star$) and ($\diamond\diamond$).
   
 \noindent \textbf{Case} 
   \[   
    \inferrule*[ right = case-query]
   {\Gamma_1 \jtype{n_1}{}{t}{b} ~ (\star)  \\ \Gamma_2 \jtype{n_2}{}{t_i}{query}~ (\diamond)  }
   {\max(\Gamma_1,\Gamma_2) \jtype{\max(n_1,n_2)}{}{\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b} } {query} }
   \]
    To show: $\depth( \tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b} ) \leq \max(n_1,n_2)$.\\
    By induction Hypothesis on ($\star$) and ($\diamond$), we get:
    $\depth(t) \leq n_1~(\star\star)$ and $\depth(t_i) \leq n_2 ~ (\diamond\diamond)$.\\
    Unfolding the definition of $\depth(\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b}) = \max(\depth(t), \depth(t_i))$.\\
    This case is proved by the ($\star\star$) and ($\diamond\diamond$).
  
 \noindent \textbf{Case} 
   \[
   \inferrule*[right = iabs]
  { 
    \inferrule*[]
    {}
    {i::\mathbb{N};\Gamma \jtype{n}{}{t}{ \tau } ~ (\diamond)  }
    \and
    \inferrule*[]
    {}
    { i \notin FV(\Gamma )  } 
  }
  { \Gamma \jtype{n}{ }{  \Lambda.t  }{ \tforallN{i}{\tau}  } }
    \]
    To show: $\depth( \Lambda.t ) \leq n$.\\
    By induction Hypothesis on ($\diamond$), we get:
    $\depth(t) \leq n ~ (\diamond\diamond)$.\\
    Unfolding the definition of $\depth( \Lambda.t ) = \depth(t)$.\\
    This case is proved by the ($\diamond\diamond$).
    
 \noindent \textbf{Case} 
   \[ 
   \inferrule*[ right =  iapp]
  { 
    \inferrule*[]
    {}
    { \Gamma  \jtype{n}{}{t}{ \tforallN{i}{\tau}   } ~ (\diamond) }
    \and
    \inferrule*[]
    {}
    { \jiterm{I}{ \mathbb{N} } } 
  }
  {\Gamma \jtype{n }{ }{t\, [] }{ \tau \{ I/i \}  } }
\]
    To show: $\depth(t\, []) \leq n$.\\
    By induction Hypothesis on ($\diamond$), we get:
    $\depth(t) \leq n ~ (\diamond\diamond)$.\\
    Unfolding the definition of $\depth(t\, []) = \depth(t)$.\\
    This case is proved by the ($\diamond\diamond$).
  
\end{proof}

\begin{lemma}[Depth Weakening1] 
	\label{lem:deweaken1}
	$\Gamma \jtype{n_1,m}{}{t}{\tau} \land n_1 \leq n_2 \implies \Gamma \jtype{n_2,m}{}{t}{\tau}$\\
\end{lemma}
\begin{proof}
  By induction on $\Gamma \jtype{n_1}{}{t}{\tau}  $.
\end{proof}

\begin{lemma}[Depth Weakening2] 
	\label{lem:deweaken2}
	$\Gamma, x:[\tau]_{p_1} \jtype{n}{}{t}{\tau} \land p_1 \leq p_2 \implies \exists m. n \leq m$ s.t. $\Gamma, x:[\tau]_{p_2} \jtype{n}{}{t}{\tau} $\\
% 	$\Gamma, x:[\tau]_{p_1} \jtype{n}{}{e}{\tau} \land p_1 \leq p_2 \land \Gamma \subseteq \Gamma' \land n \leq n' \implies \Gamma', x:[\tau]_{p_2} \jtype{n'}{}{e}{\tau} $\\
\end{lemma}
\begin{proof}
  By induction on $\Gamma, x:[\tau]_{p_1} \jtype{n}{}{t}{\tau}  $.\\
\noindent \textbf{Case} 
\[
   \inferrule*[ right = let-b ]
   {\Gamma_1 \jtype{n_1}{}{t_1}{!_p \tau_1} \\ \Gamma_2, y: [\tau_1]_p \jtype{n_2}{}{t_2}{\tau_2}}
   { \max(\Gamma_1, \Gamma_2)  \jtype{\max(n_1,n_2)}{}{\letx{!y}{t_1}{t_2}}{\tau_2}  }
\]
where $\tau = \tau_2$, $t = \letx{!y}{t_1}{t_2}$.

\textbf{Subcase 1: x $\not \in \fcv{\Delta_2}$ }
\[
   \inferrule*[ right = let-b ]
   {\Gamma_1', x:[\tau]_{p1} \jtype{n_1}{}{t_1}{!_p \tau_1}~(\star) \\
   \Gamma_2, y: [\tau_1]_p \jtype{n_2}{}{t_2}{\tau_2}~(\diamond)}
   { \max(\Gamma_1', x:[\tau]_{p1} , \Gamma_2)  \jtype{\max(n_1,n_2)}{}{\letx{!y}{t_1}{t_2}}{\tau_2}  }
\]
To show:$\max(\Gamma_1', x:[\tau]_{p2} , \Gamma_2)  \jtype{\max(n_1,n_2)}{}{\letx{!y}{t_1}{t_2}}{\tau_2}$\\
By ih on $(\star)$, we get: $\Gamma_1', x:[\tau]_{p2} \jtype{n_1}{}{t_1}{!_p \tau_1}~(\star\star)$.\\
Applying the rule $\rname{LET-B}$ on $(\star\star)$ and $(\diamond)$, this case is proved.

\textbf{Subcase 2: x $\not \in \fcv{\Delta_1}$ }
\[
   \inferrule*[ right = let-b ]
   {
   \Gamma_1 \jtype{n_1}{}{t_1}{!_p \tau_1}~(\star) \\
   \Gamma_2', x:[\tau]_{p1}, y: [\tau_1]_p \jtype{n_2}{}{t_2}{\tau_2}~(\diamond)
   }
   { 
   \max(\Gamma_1 , \Gamma_2', x:[\tau]_{p1})  \jtype{\max(n_1,n_2)}{}{\letx{!y}{t_1}{t_2}}{\tau_2}  
   }
\]
To show:$\max(\Gamma_1', x:[\tau]_{p2} , \Gamma_2)  \jtype{\max(n_1,n_2)}{}{\letx{!y}{t_1}{t_2}}{\tau_2}$\\
By ih on $(\diamond)$, we get: $\Gamma_2', x:[\tau]_{p2}, y: [\tau_1]_p \jtype{n_2}{}{t_2}{\tau_2}~(\diamond\diamond)$.\\
Applying the rule $\rname{LET-B}$ on $(\star)$ and $(\diamond\diamond)$, this case is proved.


\textbf{Subcase 3}
\[
   \inferrule*[ right = let-b ]
   {\Gamma_1', x:[\tau]_{p1} \jtype{n_1}{}{t_1}{!_p \tau_1} \\ \Gamma_2, x:[\tau]_{p1}, y: [\tau_1]_p \jtype{n_2}{}{t_2}{\tau_2}}
   { \max(\Gamma_1', \Gamma_2, x:[\tau]_{p1})  \jtype{\max(n_1,n_2)}{}{\letx{!y}{t_1}{t_2}}{\tau_2}  }
\]
To show:$\max(\Gamma_1', x:[\tau]_{p2} , \Gamma_2)  \jtype{\max(n_1,n_2)}{}{\letx{!y}{t_1}{t_2}}{\tau_2}$\\
By ih on $(\diamond)$, we get: $\Gamma_2', x:[\tau]_{p2}, y: [\tau_1]_p \jtype{n_2}{}{t_2}{\tau_2}~(\diamond\diamond)$.\\
Applying the rule $\rname{LET-B}$ on $(\star)$ and $(\diamond\diamond)$, this case is proved.


\noindent \textbf{Case} 
\[
   \inferrule*[right = pr]
   {[\Gamma] \jtype{n}{}{t}{\tau}}
   {\Delta, p + [\Gamma] \jtype{n+p}{}{!t}{!_p \tau}  }
\]

\end{proof}

\begin{lemma}[Context weakening - 1]
    \label{lem:coweaken1}
    $\Gamma \jtype{n,m}{}{t}{\tau}  \implies \Gamma, x:\tau \jtype{n,m}{}{t}{\tau} $\\
\end{lemma}
\begin{proof}
  By induction on $\Gamma \jtype{n}{}{t}{\tau}  $ and using ih.
\end{proof}

\begin{lemma}[Context weakening - 2]
    \label{lem:coweaken2}
    $\Gamma \jtype{n,m}{}{t}{\tau}  \implies \Gamma, x:[\tau]_p \jtype{n,m}{}{t}{\tau} $\\
\end{lemma}
\begin{proof}
  By induction on $\Gamma \jtype{n}{}{t}{\tau} $, using ih.
\end{proof}


\begin{lemma}[Context exchange]
    \label{lem:coex}
    $\Gamma, x : \tau_1, \Delta, y : \tau_2 \jtype{n,m}{}{t}{\tau}  \implies \Gamma, y : \tau_2, \Delta, x : \tau_1 \jtype{n,m}{}{t}{\tau} $\\
\end{lemma}

\begin{lemma}
	\label{lem:sub}
	If $\Gamma \jtype{n}{}{t}{\tau}$ and $\gamma \vDash \Gamma$, then $ \cdot \jtype{n}{}{\gamma(t)}{\tau} $\\
\end{lemma}

\begin{lemma}
	\label{lem:subext}
	If $\Gamma \subseteq \Gamma'$,  and $\Gamma' \jtype{n}{}{t}{\tau}$, then $\exists m. n \leq m$ s.t.  $\Gamma  \jtype{m}{}{t}{\tau} $. \\
\end{lemma}
\begin{proof}
  Induction on $\Gamma \subseteq \Gamma'$.\\
    \noindent \textbf{Case} 
    \[
    \inferrule*[right = S-IDC]
  { }
  { \Gamma \subseteq \Gamma }
    \]
   $ \Gamma' = \Gamma $.\\
   This case is proved.\\
   
    \noindent \textbf{Case} 
    \[
     \inferrule*[right = S-xctx1]
  {
  {\Delta \subseteq \Gamma }
  }
  {x:\tau', \Delta \subseteq \Gamma }
    \]
    We have $\Gamma \jtype{n}{}{t}{\tau}$. \\
    TS: $ x:\tau', \Delta \jtype{n}{}{t}{\tau}$.
    \\ 
    By ih, we get :  $ \exists m. m \geq n.$ s.t. $\Delta \jtype{m}{}{t}{\tau}$, this case is proved by Lemma~\ref{lem:coweaken1}.
   
    \noindent \textbf{Case} 
    \[
     \inferrule*[right = S-xctx2]
  {
  {\Delta \subseteq \Gamma }
  }
  {x:[\tau']_p, \Delta \subseteq \Gamma }
    \]
    We have $\Gamma \jtype{n}{}{t}{\tau}$. \\
    TS: $ x:\tau', \Delta \jtype{n}{}{t}{\tau}$.
    \\ 
    By ih, we get :  $ \exists m. m \geq n.$ s.t. $\Delta \jtype{m}{}{t}{\tau}$, this case is proved by Lemma~\ref{lem:coweaken2}.
   
   
    \noindent \textbf{Case}  
    \[
    \inferrule*[right = S-empty]
  { }
  { \Gamma \subseteq \emptyset}
    \]
   It is proved by Lemma~\ref{lem:coweaken1} and Lemma~\ref{lem:coweaken2} several times for every variables in $\Gamma$. \\
   
    \noindent \textbf{Case}  
    \[
  \inferrule*[right = S-Ctx]
  {
  {A \subseteq B  }\\
  {\Gamma \subseteq \Delta}
  }
  {\Gamma, x: A \subseteq \Delta, x: B }
    \]
    
 We have: $\Delta, x:B \jtype{n}{}{t}{\tau}$.\\
 TS: $\exists m. m \geq n $ s.t. $ \Gamma, x : A \jtype{m}{}{t}{\tau}  $    \\
Induction on $A \subseteq B$.
    
    \textbf{SubCase}  
    \[
  \inferrule*[right = S-ID]
  {
  \empty
  }
  {\tau \subseteq \tau }
    \]
   
    \textbf{SubCase}  
    \[
  \inferrule*[right = S-B]
  {
  A \subseteq B
  \and 
  q \leq p
  }
  {!_p A \subseteq !_q B }
    \]

   \textbf{SubCase}  
    \[
  \inferrule*[right = S-ARROW]
  {
  A' \subseteq A
  \and 
  B \subseteq B'
  }
    {A \multimap B \subseteq A' \multimap B' }
   \]

     \textbf{SubCase}  
    \[
    \inferrule*[right = S-D ]
  {
    { A \subseteq B }\\
    { q \leq p }
  }
  { [A]_p \subseteq [B]_q } 
    \]
 
    
\end{proof}


\clearpage
\begin{theorem}[Type Safety]
	If $\cdot \jtype{n,m}{}{t}{\tau} $ then $ \exists F. t \Downarrow F \land \jtype{n,m}{}{F}{\tau}$
\end{theorem}
  \begin{proof}
   We prove this theorem by prove Normalization and Preservation.
  \end{proof}

\begin{corollary}
\label{corollary}
	If $ \cdot\jtype{n,m}{}{t}{b} $ then $ \exists T_b. t \Downarrow T_b \land \depth(T_b) \leq n$
\end{corollary}
  

\clearpage

\begin{theorem}[Normalization] 
	If $\cdot\jtype{n,m}{}{t}{\tau} $ then $ \exists F: t \Downarrow F$
\end{theorem}
We prove two theorems instead.

\begin{theorem}
If $\gamma(t) \in \llu{\tau}{\epsilon} $, then $\exists F.\eval{ \gamma(t)  }{ F}{}$.
\end{theorem}
\begin{proof}
  It is proved by unfolding the definition of $\llu{\tau}{\epsilon}$.
\end{proof}
 
\begin{theorem}
 If $\Gamma \jtype{n}{}{t}{\tau}$ and $\gamma \vDash{\Gamma}$, then $\gamma(t) \in \llu{\tau}{\epsilon} $.
\end{theorem} 



 \begin{proof}  Proof by induction on  $\Gamma \jtype{n}{}{t}{\tau} $\\
 We have $ \gamma \vDash \Gamma ~(\spadesuit) $. \\
   \noindent \textbf{Case} 
 \[
 \inferrule*[right = abs]
   {\Gamma, x: \tau_1 \jtype{n}{}{t_1}{\tau_2}~(\star)}
   { \Gamma \jtype{n,m}{}{\abs{x}{t_1}}{\tau_1 \multimap \tau_2}  }
 \]
 TS : $ \gamma(\abs{x}{t}) \in \llu{\tau_1 \multimap \tau_2}{\epsilon} $ \\
 Because $\gamma(\abs{x}{t_1}) =\abs{x}{\gamma(t_1)} $ is value, unfold the definition of $\llu{\tau_1 \multimap \tau_2}{\epsilon}$, STS: $ \gamma(\abs{x}{t_1}) \in \llu{\tau_1 \multimap \tau_2}{v} $\\
 Unfold the definition of $\llu{\tau_1 \multimap \tau_2}{v}$, STS: $\forall v. v \in \llu{\tau_1}{v}. \gamma(t_1)[v/x] \in \llu{\tau_2}{\epsilon}  $.\\
 Pick $v$ s.t $ v \in \llu{\tau_1}{v}$. STS: $\gamma(t_1)[v/x] \in \llu{\tau_2}{\epsilon} $.\\
 We have $\gamma[x \rightarrow v] \vDash \Gamma, x: \tau_1 \ \ (\diamond) $ because $\gamma \vDash \Gamma$ and $ v \in \llu{\tau_1}{v} $(the assumption). \\
 By IH on $(\star)$ and $(\diamond)$, we have : \\
   $$ \gamma[v/x](t_1) \in \llu{\tau_2}{\epsilon}  $$
 Because $\gamma[v/x] (t_1) =  \gamma(t_1[v/x])$, this case is proved.\\
 
 \noindent \textbf{Case} 
 \[
 \inferrule*[right = pr]
   {[\Gamma] \jtype{n}{}{t_1}{\tau_1}}
   {\Delta, p + [\Gamma] \jtype{n+p}{}{!t_1}{!_p \tau_1}  }
 \]
 We assume $ \gamma \vDash \Delta, p+[\Gamma] ~(\spadesuit) $. \\
 TS : $ \gamma(!t_1) \in \llu{!_p \tau_1}{\epsilon} $ \\
 Because $\gamma ( !t_1)= ! \gamma(t_1) $ is value, unfold the definition of $\llu{!_p \tau_1}{\epsilon}$, STS: $ ! \gamma(t_1) \in \llu{!_p \tau_1}{v} $\\
 Unfold the definition of $\llu{!_p \tau_1}{v} $, STS: $\gamma (t_1) \in \llu{\tau_1}{\epsilon}$. \\
 We extend the context of the premise to $\Delta, p+[\Gamma] $ by Lemma~\ref{lem:coweaken1} and Lemma~\ref{lem:coweaken2}. By ih, we get  : $\gamma (t_1) \in \llu{\tau_1}{\epsilon} ~(\star) $.\\
%  By Lemma ~\ref{lem:subext} on $(\star)$ and we know $ [\Gamma] \subseteq \Delta,p+[\Gamma] $, This case is proved.\\
 
 
  \noindent \textbf{Case} 
  \[
    \inferrule*[ right = let ]
   {\Gamma_1 \jtype{n_1}{}{t_1}{!_p \tau_1}~(\star) \\ \Gamma_2, x: [\tau_1]_p \jtype{n_2}{}{t_2}{\tau'}~(\diamond)}
   { \max(\Gamma_1,\Gamma_2) \jtype{\max(n_1,n_2)}{}{\letx{!x}{t_1}{t_2}}{\tau'}  }
  \]
  We assume $\gamma \vDash \max(\Gamma_1,\Gamma_2 ) ~(\spadesuit) $.
  TS: $ \gamma ( \letx{!x}{t_1}{t_2} ) \in \llu{ \tau'}{\epsilon} $. \\
  Unfold $ \llu{ \tau'}{\epsilon} $, STS: $\exists F. \eval{\gamma ( \letx{!x}{t_1}{t_2} )}{F}{} \land F \in \llu{ \tau'}{v} $.
  
  Extend the context of $(\star)$ to $\max(\Gamma_1,\Gamma_2)$ using Lemma~\ref{lem:coweaken1} and Lemma~\ref{lem:coweaken2} or the rule (\rname{SUB}). By ih on $(\star)$ we get : $ \gamma(t_1) \in \llu{!_p \tau_1 }{\epsilon} ~(1) $\\
  Unfold (1), we get: $\exists F. \eval{\gamma(t_1)}{F}{} \land F \in \llu{ !_p \tau_1}{v}~(2)  $.\\
  Unfold (2), we know: $ \exists !t_3. \eval{\gamma(t_1)}{!t_3}{} \land t_3 \in \llu{  \tau_1}{\epsilon}~(3)$. \\
 Unfold (3), we know: $ \exists !t_3. \eval{\gamma(t_1)}{!t_3}{} \land \exists F'. \eval{t_3}{F'}{} \land F' \in \llu{  \tau_1}{v}~(4)$. \\
  Pick $F' $ in $(4)$. Extend the context of $(\diamond)$ to $\max(\Gamma_1,\Gamma_2), x:[\tau_1]_p$ s.t. $\gamma [F'/x] \vDash{\max(\Gamma_1,\Gamma_2), x:[\tau_1]_p} $. By ih on $(\diamond)$ we get : $ \gamma[F'/x](t_2) \in \llu{ \tau' }{\epsilon} ~(5)$. \\
  Unfold $(5)$, we know $\exists F. \eval{\gamma[F'/x](t_1')}{F}{}\land F \in \llu{\tau'}{v} ~(6) $.\\
  
  This case is proved using the following evaluation rule \rname{E-LET-BANG} and $(6)$.
   \[
   \inferrule*[ right=E-let-bang]
  {   
    { \eval{ \gamma(t_1)  }{ !t_3  }{m_1} } 
    \\
    {\eval{t_3}{F'}{m_2}}
    \\
    { \eval{\gamma(t_2[F'/x]) }{ F}{m_3 } }
  }
  { \eval{  \letx{!x}{\gamma (t_1)}{\gamma(t_2)}  }{ F  }{ m_1+m_2+m_3  } }  
   \]
  
  \noindent \textbf{Case} 
  \[
    \inferrule*[ right = let ]
   {\Gamma_1 \jtype{n_1}{}{t_1}{!_p \tau_1}~(\star) \\ \Gamma_2, x: [\tau_1]_p \jtype{n_2}{}{t_1'}{\tau'}~(\diamond)}
   { \max(\Gamma_1,\Gamma_2) \jtype{\max(n_1,n_2)}{}{\letx{!x}{t_1}{t_1'}}{\tau'}  }
  \]
  We assume $\gamma \vDash \max(\Gamma_1,\Gamma_2 ) ~(\spadesuit) $.
  TS: $ \gamma ( \letx{!x}{t_1}{t_1'} ) \in \llu{ \tau'}{\epsilon} $. \\
  Unfold $ \llu{ \tau'}{\epsilon} $, STS: $\exists F. \eval{\gamma ( \letx{!x}{t}{t'} )}{F}{} \land F \in \llu{ \tau'}{v} $.
  
  Pick $\gamma_1$ s.t. $\gamma_1 \vDash \Gamma_1 $. By ih on $(\star)$ we get : $ \gamma_1(t_1) \in \llu{!_p \tau_1 }{\epsilon}$. \\
  By Lemma~\ref{lem:subext} and $\Gamma_1 \subseteq \max(\Gamma_1,\Gamma_2)$, we know: $ \gamma(t_1) \in \llu{!_p \tau_1 }{\epsilon}~(1) $\\
  Unfold (1), we get: $\exists F. \eval{\gamma(t_1)}{F}{} \land F \in \llu{ !_p \tau_1}{v}~(2)  $.  
 
  Pick $\gamma_2$ s.t. $\gamma_2 \vDash \Gamma_2 \implies \gamma_2[F/x] \vDash \Gamma_2, x:[\tau_1]_p $. By ih on $(\diamond)$ we get : $ \gamma_2[F/x](t_1') \in \llu{ \tau' }{\epsilon} ~(3)$. \\
  By Lemma~\ref{lem:subext} and $\Gamma_2, x:[\tau_1]_p \subseteq \max(\Gamma_1,\Gamma_2), x:[\tau_1]_p$, we know: $ \gamma[F/x](t_1') \in \llu{ \tau' }{\epsilon}~(4) $\\
  

    It is proved by unfolding (2),(4) and the following evaluation rule \rname{E-LET-BANG}.
   \[
   \inferrule*[ right=E-let-bang]
  {   
    { \eval{ \gamma(t_1) }{ !t_2  }{m_1} } 
    \\
    { \eval{\gamma[!t_2/x](t_1') }{ F'}{m_3 } }
  }
  { \eval{  \letx{!x}{\gamma(t_1)}{\gamma(t_1')}  }{ F'  }{ m_1+m_2+m_3  } }  
   \]
  
  
  
   \noindent \textbf{Case} 
   \[
      \inferrule*[ right = MT ]
   {[\Gamma] \jtype{n}{}{t}{query}}
   {\Delta, 1 + [\Gamma] \jtype{n+1}{}{M(t)}{b}  }
   \]
   Assume $\gamma \vDash{\Delta,1+[\Gamma]}~(\spadesuit)$.\\
   TS: $\gamma(M(t)) \in \llu{b}{\epsilon}$.\\
   STS: $\exists F. \eval{M(\gamma(t))}{F}{} \land F \in \llu{b}{v} \implies \exists T_{b}. \eval{M(\gamma(t))}{T_{b}}{}$.\\
   We assume $\gamma' \vDash{[\Gamma]} $,
   by ih we get : $ \gamma'(t) \in \llu{query}{\epsilon}~(1)$.\\
   By Lemma ~\ref{lem:subext} and $[\Gamma] \subseteq \Delta, 1+[\Gamma] $, we get $ \gamma(t) \in \llu{query}{\epsilon}~(2)$\\
   Unfold (2), we know: $\exists F. \eval{\gamma(t)}{F}{} \land F \in \llu{query}{v} \implies F = T_{query} ~(3) $. 
   
   It is proved by \rname{E-MECH} and (3), $T_b =M( T_{query})$.
   \[
     \inferrule*[ right=E-mech]
  { 
    \inferrule*[]
    {}
    {\eval{  \gamma(t)  }{ T_{query} }{m }  }
  }
  { \eval{  M(t)  }{ M(T_{query})  }{  m } }
   \]
  
    
     \noindent \textbf{Case} 
     \[
       \inferrule*[ right = var]
   {\empty}
   {\Gamma, x:\tau \jtype{n}{}{x}{\tau}  } 
     \]
    Assume $\gamma \vDash \Gamma, x: \tau $.\\
    TS: $\gamma(x) \in \llu{\tau}{\epsilon} $.\\
    Unfold the definition of $\gamma \vDash{\Gamma, x: \tau}$, we know : $ \gamma(x) \in \llu{\tau}{v} $. \\
    STS: $ F \in \llu{\tau}{\epsilon} $.\\
    
   It is proved by the assumption and the evaluation rule \rname{E-Value}.
 
 \noindent \textbf{Case}
  \[
   \inferrule*[ right = case-const ]
   {\Gamma_1 \jtype{n_1}{}{t}{b} ~(\star) \\ \Gamma_2 \jtype{n_2}{}{t_i}{b}~(\diamond) }
   {\max(\Gamma_1, \Gamma_2) \jtype{\max(n_1,n_2)}{}{\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b} } {b} }
  \]
  We assume $ \gamma \vDash \max(\Gamma_1,\Gamma_2)$.\\
  TS: $\gamma( \tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b}  )  \in \llu{b}{\epsilon} \implies \tcaseof{\gamma(t)}\ \{c_i \Rightarrow \gamma(t_i)\}_{c_i \in b} \in \llu{b}{\epsilon}$.\\
  We assume $\gamma_1 \vDash \Gamma_1$ and $\gamma_2 \vDash \Gamma_2 $.\\
  By ih on $(\star)$, we get : $ \gamma_1(t) \in \llu{b}{\epsilon}$.\\
  By ih on $(\diamond)$, we get : $ \gamma_2(t_i) \in \llu{b}{\epsilon}$.\\
  By Lemma ~\ref{lem:subext} and $\Gamma_1 \subseteq \max(\Gamma_1,\Gamma_2) $ and $ \Gamma_2 \subseteq \max(\Gamma_1,\Gamma_2) $, we get: $\gamma(t) \in \llu{b}{\epsilon}~(1) $ and $ \gamma(t_i) \in \llu{b}{\epsilon}~(2)$.\\
  It is proved by unfolding (1) and (2) and using the evaluation rule \rname{E-CASE} and the definition of $T_b$.\\ 
  
  \noindent \textbf{Case}
  \[
   \inferrule*[ right = case-query]
   {\Gamma_1 \jtype{n_1}{}{t}{b}(\star) \\ \Gamma_2 \jtype{n_2}{}{t_i}{query}~(\diamond) }
   {\max(\Gamma_1, \Gamma_2) \jtype{\max(n_1,n_2)}{}{\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b} } {query} }
  \]
  We assume $\gamma \vDash \max(\Gamma_1, \Gamma_2) $.\\
  TS: $\gamma(\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b}) \in \llu{query}{\epsilon} \implies \tcaseof{\gamma(t)}\ \{c_i \Rightarrow \gamma(t_i)\}_{c_i \in b} \in \llu{query}{\epsilon} $.\\
  We assume $\gamma_1 \vDash \Gamma_1$ and $\gamma_2 \vDash \Gamma_2 $.\\
  By ih on $(\star)$, we get : $ \gamma_1(t) \in \llu{b}{\epsilon}$.\\
  By ih on $(\diamond)$, we get : $ \gamma_2(t_i) \in \llu{query}{\epsilon}$.\\
  By Lemma ~\ref{lem:subext} and $\Gamma_1 \subseteq \max(\Gamma_1,\Gamma_2) $ and $ \Gamma_2 \subseteq \max(\Gamma_1,\Gamma_2) $, we get: $\gamma(t) \in \llu{b}{\epsilon}~(1) $ and $ \gamma(t_i) \in \llu{query}{\epsilon}~(2)$.\\
   It is proved by unfolding (1) and (2) and using the evaluation rule \rname{E-CASE} and the definition of $T_{query}$.\\ 
  
  \noindent \textbf{Case}
\[
  \inferrule*[right = sub]
  { 
  { \Gamma \jtype{n}{}{t}{\tau} ~(\star) } \\
  {  \Gamma' \subseteq \Gamma } \\
  { \vDash n \leq n' } \\
  { \tau \subseteq \tau' }
  }
  { \Gamma' \jtype{n'}{}{t}{\tau'} }
 \]
We assume $\gamma \vDash \Gamma'$.\\
To show $\gamma(t)\in \llu{\tau'}{\epsilon}$. \\
We assume $\gamma' \vDash \Gamma$. By ih on $(\star)$, we get:  $\gamma'(t) \in \llu{\tau}{\epsilon}$.\\
By $\Gamma ' \subseteq \Gamma $ and $\tau \subseteq \tau'$, we get: $\gamma(t)  \in \llu{\tau'}{\epsilon}$, this case is proved.

 
 \end{proof}

\clearpage

\begin{theorem}[Preservation]
	If $\cdot\jtype{n}{}{t}{\tau} \land t \Downarrow F$ then $ \jtype{n}{}{F}{\tau} $
\end{theorem}
\begin{proof}
  By induction on typing derivation of $\cdot \jtype{n}{}{t}{\tau} $.\\
  
  \noindent \textbf{Case}
  \[
   \inferrule*[right = const]
   {\empty}
   {\cdot \jtype{n}{}{c}{b}  }
  \]
  $t$ is $c$, From \rname{E-CONST}, we know $F$ is $c$, It is proved.\\
 
 For the cases \rname{ABS},\rname{QUERY},\rname{ILAM},\rname{VAR},\rname{PR}, the proof are similar as the one for \rname{CONST} because $t$ in these cases are values.\\
 
 \noindent \textbf{Case}
 \[
  \inferrule*[ right = MT ]
   {\cdot \jtype{n_1}{}{t_1}{query}~(\star)}
   {\cdot \jtype{n_1+1}{}{M(t_1)}{b}  }
 \]
  $t$ is $M(t_1)$, from the rule \rname{E-MECH}, we get: 
  \[
      \inferrule*[ right=E-mech]
  { 
    \inferrule*[]
    {}
    {\eval{  t_1  }{ F }{m }~(\diamond)  }
  }
  { \eval{  M(t_1)  }{ M(F)  }{  m } }
  \]
  
  By ih on ($\star$) and ($\diamond$), we get : 
  $ \cdot \jtype{n_1}{}{F}{query} $. \\
  Using the rule \rname{MT}, we conclude $\cdot \jtype{n_1+1}{}{M(F)}{b} $. This case is proved.\\
  
  \noindent \textbf{Case}
  \[
  \inferrule*[right = pair]
   {\cdot \jtype{n_1}{}{t_1}{\tau_1}~(\star) \\ \cdot \jtype{n_2}{}{t_2}{\tau_2}~(\diamond) }
   { \cdot \jtype{\max(n_1,n_2)}{}{(t_1, t_2)}{\tau_1 \times \tau_2}  }
  \]
  $t$ is $(t_1,t_2)$, from the evaluation rule \rname{E-PAIR}, we know:
  
  \[
   \inferrule*[ right=E-pair]
  {   
    { \eval{ t_1  }{ F_1  }{m_1}~(\star\star) }
    \\
    { \eval{ t_2  }{ F_2  }{m_2}~(\diamond\diamond) } 
  }
  { \eval{  (t_1,t_2)  }{ (F_1,F_2)  }{ m_1+m_2  } } 
  \]
  By ih on ($\star$) and ($\star\star$), we get: $ \cdot \jtype{n_1}{}{F_1}{\tau_1} $.\\
  By ih on ($\diamond$) and ($\diamond\diamond$), we get: $ \cdot \jtype{n_2}{}{F_2}{\tau_2} $.\\
  This case is proved by using the rule \rname{PAIR}.\\
  
   \noindent \textbf{Case}
   \[
   \inferrule*[ right = app ]
   {\cdot \jtype{n_1}{}{t_1}{\tau_1 \multimap \tau_2}~(\star) \\ \cdot \jtype{n_2}{}{t_2}{\tau_1}~(\diamond)}
   { \cdot \jtype{\max(n_1,n_2)}{}{\app{t_1}{t_2}}{\tau_2}  }
   \]
   $t$ is $\app{t_1}{t_2}$, from the evaluation rule \rname{E-APP}, we know:
   \[
    \inferrule*[ right=E-app]
  {   
    { \eval{ t_1  }{ \abs{x}{t'}  }{m_1} ~(\star\star) }
    \\
    { \eval{ t_2  }{ F  }{m_2}~(\diamond\diamond) } 
    \\
    { \eval{t'[F/x] }{ F'}{m_3 }~(\heartsuit) }
  }
  { \eval{ \app{t_1}{t_2}  }{ F'  }{ m_1+m_2+m_3  } }
   \]
   By ih on ($\star$) and ($\star\star$), we get: $ \cdot \jtype{n_1}{}{\abs{x}{t'}}{\tau_1 \multimap \tau_2}~(\spadesuit) $.\\
   By inversion on ($\spadesuit$), we get: $x:\tau_1 \jtype{n_1}{}{t'}{\tau_2}(\spadesuit\spadesuit)$.\\
  By ih on ($\diamond$) and ($\diamond\diamond$), we get: $ \cdot \jtype{n_2}{}{F}{\tau_1} ~(\clubsuit)$.\\
  From Theorem Substitution with ($\spadesuit\spadesuit$) and ($\clubsuit$), we get: $\cdot \jtype{\max(n_1,n_2)}{}{t'[F/x]}{\tau_2}~(\heartsuit\heartsuit) $.\\
  By ih on ($\heartsuit$) and ($\heartsuit\heartsuit$), we conclude: $ \cdot \jtype{\max(n_1,n_2)}{}{F'}{\tau_2}$.\\
  It proves this case.\\
  
   \noindent \textbf{Case}
   \[
   \inferrule*[ right = let ]
   {\cdot \jtype{n_1}{}{t_1}{!_p \tau}~(\star) \\ \cdot, x: [\tau]_p \jtype{n_2}{}{t_2}{\tau'}~(\diamond) }
   { \cdot \jtype{\max(n_1,n_2)}{}{\letx{!x}{t_1}{t_2}}{\tau'}  }
   \]
   In this case, $t$ is $\letx{!x}{t_1}{t_2} $. From the evaluation rule, we know:\\
   \[
   \inferrule*[ right=E-let-bang]
  {   
    { \eval{ t_1  }{ !t_3  }{m_1} ~(\star\star)} 
    \\
    {\eval{t_3}{F'}{m_2}~(\diamond\diamond) }
    \\
    { \eval{t_2[F'/x] }{ F}{m_3 } }
  }
  { \eval{  \letx{!x}{t_1}{t_2}  }{ F  }{ m_1+m_2+m_3  } }  
   \]
    By ih on ($\star$) and ($\star\star$), we get: $ \cdot \jtype{n_1}{}{!t_3 }{!_p \tau}~(\spadesuit) $.\\
     By inversion on ($\spadesuit$), we get: $\cdot \jtype{n_1}{}{t_3}{\tau}(\spadesuit\spadesuit)$.\\
   By ih on ($\spadesuit\spadesuit $) and ($\diamond\diamond$), we get: $ \cdot \jtype{n_2}{}{F'}{\tau} ~(\clubsuit)$.\\

\noindent \textbf{Case}
\[
 \inferrule*[ right = case-const ]
   {\cdot \jtype{n_1}{}{t'}{b}~(\star) \\ \cdot \jtype{n_2}{}{t_i}{b}~(\diamond) }
   {\cdot \jtype{\max(n_1,n_2)}{}{\tcaseof{t'}\ \{c_i \Rightarrow t_i\}_{c_i \in b} } {b} }
\]
In this case, $t$ is $ \tcaseof{t'} \{c_i \Rightarrow t_i\}_{c_i \in b} $.\\
From the evaluation rule, we get:

\[
\inferrule*[ right=E-case]
  { 
    \inferrule*[]
    {}
    {\eval{  t'  }{ F' }{m } ~(\star\star) }
    \\
    \inferrule*[]
    {}
    { \eval{ t_i  }{ F_i   }{ m_i } ~(\diamond\diamond)  }
  }
  { \eval{ \tcaseof{t'}\ \{c_i \Rightarrow t_i\}_{c_i \in b}  }{ \tcaseof{F'}\ \{c_i \Rightarrow F_i\}_{c_i \in b}  }{  m + m_i } }
 \] 
  By ih on ($\star$) and ($\star\star$), we get: $ \cdot \jtype{n_1}{}{F' }{b}~(\spadesuit) $.\\
  By ih on ($\diamond$) and ($\diamond\diamond$), we get: $ \cdot \jtype{n_2}{}{F_i}{b} ~(\clubsuit)$.\\
 By the rule \rname{CASE-CONST}, we conclude :$ \cdot  \jtype{\max(n_1,n_2)}{}{ \tcaseof{F'}\ \{c_i \Rightarrow F_i\}_{c_i \in b} }{b}$.\\
 This case is proved.\\
 
 \noindent \textbf{Case}
 \[
    \inferrule*[ right = case-query]
   {\cdot \jtype{n_1}{}{t'}{b}~(\star) \\ \cdot \jtype{n_2}{}{t_i}{query}~(\diamond) }
   {\cdot \jtype{\max(n_1,n_2)}{}{\tcaseof{t'}\ \{c_i \Rightarrow t_i\}_{c_i \in b} } {query} }
 \]
 In this case, $t$ is $ \tcaseof{t'} \{c_i \Rightarrow t_i\}_{c_i \in b} $.\\
From the evaluation rule, we get:

\[
\inferrule*[ right=E-case]
  { 
    \inferrule*[]
    {}
    {\eval{  t'  }{ F' }{m } ~(\star\star) }
    \\
    \inferrule*[]
    {}
    { \eval{ t_i  }{ F_i   }{ m_i } ~(\diamond\diamond)  }
  }
  { \eval{ \tcaseof{t'}\ \{c_i \Rightarrow t_i\}_{c_i \in b}  }{ \tcaseof{F'}\ \{c_i \Rightarrow F_i\}_{c_i \in b}  }{  m + m_i } }
 \] 
  By ih on ($\star$) and ($\star\star$), we get: $ \cdot \jtype{n_1}{}{F' }{b}~(\spadesuit) $.\\
  By ih on ($\diamond$) and ($\diamond\diamond$), we get: $ \cdot \jtype{n_2}{}{F_i}{query} ~(\clubsuit)$.\\
 By the rule \rname{CASE-QUERY}, we conclude :$ \cdot  \jtype{\max(n_1,n_2)}{}{ \tcaseof{F'}\ \{c_i \Rightarrow F_i\}_{c_i \in b} }{query}$.\\
 This case is proved.\\
 
 \noindent \textbf{Case}
 \[
 \inferrule*[ right = let-p ]
   {\cdot \jtype{n_1}{}{t_1}{\tau_1 \times \tau_2 }~(\star) \\  x_1: \tau_1, x_2 : \tau_2 \jtype{n_2}{}{t_1'}{\tau'}~(\diamond) }
   { \cdot  \jtype{\max(n_1,n_2)}{}{ \letx{(x_1,x_2)}{t_1}{t_1'} }{\tau'}  }
 \]
 In this case, $t$ is $ \letx{(x_1,x_2)}{t_1}{t_1'} $.
 From the evalutation rule, we get:
 \[
 \inferrule*[ right=E-LET-P]
  {   
    { \eval{ t_1  }{ (F_1,F_2)  }{m_1}~(\star\star) } 
    \\
    { \eval{t_1'[F_1/x_1][F_2/x_2] }{ F}{m_3 }~(\heartsuit) }
  }
  { \eval{  \letx{(x_1,x_2)}{t_1}{t_1'}  }{ F  }{ m_1+m_2+m_3  } }
  \]
 By ih on ($\star$) and ($\star\star$), we know: $ \cdot \jtype{n_1}{}{(F_1,F_2)}{\tau_1 \times \tau_2}~(\spadesuit) $. \\
 By inversion on ($\spadesuit$), we get : $\cdot \jtype{n_1'}{}{F_1}{\tau_1} ~(\clubsuit)$ and $\cdot \jtype{n_2'}{}{F_2}{\tau_2} ~(\clubsuit\clubsuit)$ where $\max(n_1',n_2') = n_1$.\\
 By Theorem Substitution twice with ($\clubsuit$) and ($\clubsuit\clubsuit$) on ($\diamond$), we get $\cdot \jtype{\max(n_1',\max(n_2',n_2))}{}{t_1'[F_1/x_1][F_2/x_2]}{\tau'} ~(\heartsuit\heartsuit)$.\\
 It is proved by ih on $(\heartsuit\heartsuit)$ and ($\heartsuit$).\\
 
 \noindent \textbf{Case}
 \[
     \inferrule*[right = pair]
   {\cdot \jtype{n_1}{}{t_1}{\tau_1} \\ \cdot \jtype{n_2}{}{t_2}{\tau_2}}
   { \cdot  \jtype{\max(n_1,n_2)}{}{(t_1, t_2)}{\tau_1 \times \tau_2}  }\]
   In this case, $t$ is $(t_1,t_2)$. From the evaluation rule we get :
   
   \[  
   \inferrule*[ right=E-pair]
  {   
    { \eval{ t_1  }{ F_1  }{m_1} }
    \\
    { \eval{ t_2  }{ F_2  }{m_2} } 
  }
  { \eval{  (t_1,t_2)  }{ (F_1,F_2)  }{ m_1+m_2  } } 
  \]
  By ih, we know : $ \cdot \jtype{n_1}{}{F_1}{\tau_1}$ and $ \cdot \jtype{n_2}{}{F_2}{\tau_2}$. \\
  This case is proved by using the rule \rname{PAIR}.\\
 
  \noindent \textbf{Case}
\[
  \inferrule*[right = sub]
  { 
   { \Gamma \jtype{n}{}{t}{\tau} ~(\star) } \\
   {  \Gamma' \subseteq \Gamma } \\
   { \vDash n \leq n' } \\
   { \tau \subseteq \tau' }
  }
  { \Gamma' \jtype{n'}{}{t}{\tau'} }
 \]
 by ih on $(\star)$, we get:
 $\Gamma \jtype{n}{}{F}{\tau}$.\\
 This case is proved by using the rule $\rname{SUB}$.
 
\end{proof}



\clearpage
\begin{theorem} [Substitution]
	If $\Gamma \jtype{n_1}{}{t_1}{\tau_1}$  and   $\Delta, x: [\tau_1]_p \jtype{n_2}{}{t_2}{\tau_2}$ then $\max( \Gamma,\Delta) \jtype{\max{(p + n_1, n_2)}}{}{t_2[t_1/x]}{\tau_2} $
\end{theorem}
\begin{proof}
  The theorem is proved by induction on the typing derivation of the second premise  $\Gamma, x: [\tau_1]_p \jtype{n_2}{}{t_2}{\tau_2}$. \\
   
  \noindent \textbf{Case}
  \[
   \inferrule*[ right = var]
   {\empty}
   {\Gamma, x:[\tau_1]_p \jtype{0}{}{x}{\tau_1}  } 
  \]
  where $t_2 = x$ and $\tau_2 = \tau_1$.\\
  Assume we know: $\Gamma \jtype{n_1}{}{t_1}{\tau_1} \ \ (\star) $ \\
  TS: $\Gamma \jtype{\max(p+n_1,0 )}{}{t_2[t_1/x]}{\tau_1}$ \\
  STS: $\Gamma \jtype{\max(p+n_1,0)}{}{x[t_1/x]}{\tau_1} \Rightarrow \Gamma \jtype{\max(p+n_1,0)}{}{t_1}{\tau_1}$ \\
  It is proved by using Lemma ~\ref{lem:weaken} on $(\star)$ because $n_1 \leq \max(p+n_1, 0)$.\\
  
  \noindent \textbf{Case}
  \[
   \inferrule*[ right = var]
   {\empty}
   {\Gamma, y:[\tau_2]_{p'} , x:[\tau_1]_p \jtype{0}{}{y}{\tau_2}  }
  \]
 
  Assume we know: $\Gamma, y: [\tau_2]_{p'} \jtype{n_1}{}{t_1}{\tau_1} \ \ (\star) $ \\
  TS: $\Gamma, y: [\tau_2]_{p'} \jtype{\max(p+n_1,0 )}{}{y[t_1/x]}{\tau_2}$ \\
  STS: $\Gamma, y: [\tau_2]_{p'} \jtype{\max(p+n_1,0)}{}{y}{\tau_2} $ \\
  From \rname{VAR}, we get : $ \Gamma, y: [\tau_2]_{p'} \jtype{0}{}{y}{\tau_2} ~(\diamond) $.
  It is proved by using Lemma ~\ref{lem:weaken} on $(\diamond)$.\\
  
    \noindent \textbf{Case}
     \[
   \inferrule*[ right = MT ]
   {\Gamma, x: [\tau_1]_{p} \jtype{n}{}{t}{query} \ \ (\star\star)}
   {1 + \Gamma, x: [\tau_1]_{p+1} \jtype{n+1}{}{M(t)}{b}  }
  \]
  Assume we know: $1+\Gamma \jtype{n_1}{}{t_1}{\tau_1} \ \ (\star) $ \\
   We know that $\Gamma \jtype{n_1}{}{t_1}{\tau_1 } $ by Lemma ~\ref{lem:weaken2} on the assumption $(\star)$.\\
   We also know that $n+1=n_2$.\\
   TS:  $1+\Gamma \jtype{\max(p+n_1+1,n_2)}{}{ (M(t)) [t_1/x]}{b}$ \\
   By IH on $(\star\star)$, we know: $ \Gamma \jtype{\max(n_1+p, n) }{}{t[t_1/x] }{query} \ \ (\diamond) $\\
   By rule MT, we know that : 
     \[
   \inferrule*[ right = MT ]
   {\Gamma \jtype{\max(n_1+p, n) }{}{t[t_1/x] }{query} }
   {1 + \Gamma \jtype{  1+ \max(n_1+p, n) }{}{M(t[t_1/x])}{b}  }
  \]
  
   We obtain: $ 1 + \Gamma \jtype{  \max(n_1+p+1, n+1) }{}{M(t[t_1/x])}{b} \Rightarrow 
     1 + \Gamma \jtype{  \max(n_1+p+1, n_2) }{}{\big ( M(t) \big )[t_1/x]}{b} $\\
     This case is proved.\\
     
   \noindent \textbf{Case}
   
   \[
   \inferrule*[right = pr]
   {\Gamma, x:[\tau_1]_{p} \jtype{n_2}{}{t}{\tau} \ \ (\star\star)}
   {p' + \Gamma, x:[\tau_1]_{p+p'} \jtype{n_2}{}{!t}{!_{p'} \tau}  }
   \]
   We assume $p'+ \Gamma \jtype{n_1}{}{t_1}{\tau_1}$.
   by Lemma \ref{lem:weaken2}, we know $  \Gamma \jtype{n_1}{}{t_1}{\tau_1}$ $(\star)$.\\
   TS: $ p'+ \Gamma \jtype{\max(n_1+p+p', n_2)}{}{!t[t_1/x]}{!_{p'} \tau } $\\
   
   By IH on $(\star\star)$ along with $(\star)$, we know:
   $ \Gamma \jtype{\max(n_1+p,n_2)}{}{t[t_1/x]}{\tau} \ \ (\diamond)$\\
   By rule \rname{PR}, we know: 
     \[
   \inferrule*[right = pr]
   {\Gamma \jtype{\max(n_1+p,n_2)}{}{t[t_1/x]}{\tau} }
   {p' + \Gamma \jtype{ \max(n_1+p,n_2) }{}{!t[t_1/x]}{!_{p'} \tau} \ \ (\diamond \diamond)  }
   \]
   This case is proved by Lemma \ref{lem:weaken} on $(\diamond\diamond)$. \\
  
  \noindent \textbf{Case}
   \[
     \inferrule*[right = query]
   {\empty}
   {\Gamma, x: [\tau_1]_p \jtype{0}{}{q}{query}  }
   \]   
   TS: $\Gamma \jtype{\max(p+n_1, n_2)}{}{q[t_1/x]}{query} \Rightarrow \Gamma \jtype{\max(p+n_1, n_2)}{}{q }{query} $.\\
   Using rule \rname{QUERY}, we get $\Gamma \jtype{0}{}{q}{QUERY}$,
   This case is proved by Lemma \ref{lem:weaken} on it.\\
   
  \noindent \textbf{Case} 
   \[
    \inferrule*[ right = let ]
   {\Gamma_1, y : [\tau_1]_{p} \jtype{n}{}{t}{!_{p_1} \tau} \ \ (\diamond) \\ \Gamma_2, y : [\tau_1]_{p}, x: [\tau]_{p_1} \jtype{n'}{}{t'}{\tau'} \ \ (\diamond \diamond) }
   { \max(\Gamma_1,\Gamma_2 ), y : [\tau_1]_{p} \jtype{\max(n,n')}{}{\letx{!x}{t}{t'}}{\tau'}  }
   \]
   We assume $ \max(\Gamma_1,\Gamma_2) \jtype{n_1}{}{t_1}{\tau}~(\star)$.\\
   
   TS: $ \max(\Gamma_1,\Gamma_2) \jtype{ \max( n_1 + p, \max(n,n') ) }{}{ (\letx{!x}{t}{t'} ) [t_1/y] }{ \tau' } $\\
   By Lemma~\ref{lem:weaken2}, Lemma~\ref{lem:weaken3}, we can extend the context of $(\diamond)$, to $\max(\Gamma_1,\Gamma_2)$:\\
   $\max(\Gamma_1,\Gamma_2), y : [\tau_1]_{p} \jtype{n}{}{t}{!_{p_1} \tau}$$(\diamond')$.\\
   Similarly, from ($\diamond\diamond$)we get: $ \max(\Gamma_1,\Gamma_2), y : [\tau_1]_{p}, x: [\tau]_{p_1} \jtype{n'}{}{t'}{\tau'} ~(\diamond\diamond') $. \\
   By IH on $(\diamond')$, we get:
   $ \max(\Gamma_1,\Gamma_2) \jtype{\max(n_1+p, n)}{}{t[t_1/y]}{!_{p_1} \tau} \ \ (\spadesuit) $\\
    By IH on $(\diamond\diamond')$, we get:
   $ \max(\Gamma_1,\Gamma_2),x:[\tau]_{p_1} \jtype{\max(n_1+p, n')}{}{t'[t_1/y]}{ \tau'} \ \  (\clubsuit ) $\\
   By rule \rname{let}, we get:
    \[
    \inferrule*[ right = let ]
   {\max(\Gamma_1,\Gamma_2) \jtype{\max(n_1+p, n)}{}{t[t_1/y]}{!_{p_1} \tau} \ \ (\spadesuit) \\ \max(\Gamma_1,\Gamma_2),x:[\tau]_{p_1} \jtype{\max(n_1+p, n')}{}{t'[t_1/y]}{ \tau'} \ \  (\clubsuit ) }
   { \Gamma \jtype{\max( \max(n_1+p, n)  ,\max(n_1+p, n'))}{}{\letx{!x}{t[t_1/y]}{t'[t_1/y]}}{\tau'}  }
   \]
   Because $\max( \max(n_1+p, n)  ,\max(n_1+p, n')) = \max( n_1 + p, \max(n,n') ) $, this case is proved.\\
   
    \noindent \textbf{Case} 
   \[
      \inferrule*[right = abs]
   {\Gamma, y:[\tau]_p, x: [\tau_1]_{0} \jtype{n}{}{t}{\tau_2} (\diamond)}
   { \Gamma, y: [\tau]_p \jtype{n}{}{\abs{x}{t}}{\tau_1 \multimap \tau_2}  }
   \]
   We assume $ \Gamma \jtype{n_1}{}{t_1}{\tau}~(\star) $.\\
   By Lemma ~\ref{lem:weaken3}, we get: $ \Gamma, x:[\tau_1]_0  \jtype{n_1}{}{t_1}{\tau_1}$.\\
   TS: $ \Gamma \jtype{\max(n_1+p , n)}{}{\abs{x}{t[t_1/y]}}{\tau_1 \multimap \tau_2 } $.\\
   By IH on ($\diamond$), we get: $ \Gamma, x:[\tau_1]_0 \jtype{\max(n_1+p,n )}{}{t[t_1/y]}{\tau_2}~(\spadesuit) $.\\ 
   It is proved by the rule \rname{ABS} and $(\spadesuit)$.
   
   \noindent \textbf{Case} 
   \[
    \inferrule*[ right = app ]
   {\Gamma_1, x:[\tau]_p \jtype{n_1}{}{t_1}{\tau_1 \rightarrow \tau_2}~(\diamond) \\ \Gamma_2, x:[\tau]_p \jtype{n_2}{}{t_2}{\tau_1}~(\diamond\diamond) }
   { \max(\Gamma_1,\Gamma_2),x : [\tau]_p \jtype{\max(n_1,n_2)}{}{\app{t_1}{t_2}}{\tau_2}  }
   \]
   We assume $ \max(\Gamma_1,\Gamma_2) \jtype{n}{}{t}{\tau} $.\\
   By Lemma \ref{lem:weaken2}, Lemma \ref{lem:weaken3}, we extend the 
   
   
   \noindent \textbf{Case} 
   \[
      \inferrule*[ right = let-p ]
   {\Gamma_1 \jtype{n_1}{}{t}{\tau_1 \times \tau_2 } \\ \Gamma_2, x_1: \tau_1, x_2 : \tau_2 \jtype{n_2}{}{t'}{\tau'}}
   { \max(\Gamma_1,\Gamma_2)  \jtype{\max(n_1,n_2)}{}{ \letx{(x_1,x_2)}{t}{t'} }{\tau'}  }
   \]
   
   
\end{proof}


\clearpage

% \begin{theorem}[Progress] 
% 	If $ \jtype{n}{}{t}{\tau}$, then $\exists F.\eval{ t  }{ F}{}$.
% \end{theorem}
% We prove two theorems instead.
 
% \begin{theorem}
%  If $\Gamma \jtype{n}{}{t}{\tau}$ and $\gamma \vDash{\Gamma}$, then $\gamma(t) \in \llu{\tau}{\epsilon} $.
% \end{theorem} 

% \begin{theorem}
% If $\gamma(t) \in \llu{\tau}{\epsilon} $, then $\exists F.\eval{ \gamma(t)  }{ F}{}$.
% \end{theorem}


% \begin{proof}
% Proof by induction on $t$.\\
% \noindent \textbf{Case} 
%  $$
%  c \sep \fix{t} \sep !t \sep (F_1, F_2) \sep \Lambda. t \sep \abs{x}{t} \sep M(F) \sep x \sep q \sep \tcaseof{F}\ \{c_i \Rightarrow F_i\}_{c_i \in b_i} 
% $$
% these cases are proved directly by applying the Normal form definition.\\ 
% \noindent \textbf{Case} 
% $$
% \app{t_1}{t_2} 
% $$

% We know there is a typing derivation for $\Gamma \jtype{n}{}{t_1 \, t_2}{\tau}$.
% \[
%   \inferrule*[ right = app ]
%   {\Gamma_1 \jtype{n_1}{}{t_1}{\tau_1 \rightarrow \tau_2} ~(\star) \\ \Gamma_2 \jtype{n_2}{}{t_2}{\tau_1} ~(\diamond)}
%   { \max(\Gamma_1,\Gamma_2) \jtype{\max(n_1,n_2)}{}{\app{t_1}{t_2}}{\tau_2}  }
% \]

% By IH on ($\star$),($\diamond$), we get :
%   $\exists F_1. \eval{ t_1  }{ F_1}{} $ and $\exists F_2. \eval{ t_2  }{ F_2}{} $. 
  
%   We have the evaluation rule \rname{E-APP}
%   \[
%   \inferrule*[ right=E-app]
%   {   
%     { \eval{ t_1  }{ \abs{x}{t}  }{m_1} }
%     \\
%     { \eval{ t_2  }{ F  }{m_2} } 
%     \\
%     { \eval{t[F/x] }{ F'}{m_3 } }
%   }
%   { \eval{ \app{t_1}{t_2}  }{ F'  }{ m_1+m_2+m_3  } }
%   \]
 
%  Since $F_1$ is a value with an arrow type according to the preservation lemma, it must be an abstraction. Say $F_1$ = $\abs{x}{t}$.\\
% We know $ \app{ \abs{x}{t}}{F_2} \rightarrow^* t[F_2/x] $ by $\beta$ reduction, and $\eval{t[F/x]}{F'}{} $ by $\delta$ reduction.\\
% By applying the \rname{E-APP} rule, we get: $\eval{\app{t_1}{t_2}}{F'}{}$.\\ This case is proved.




% \noindent \textbf{Case} 
% $$
% (t_1,t_2) 
% $$
% By induction hypothesis, we have: $\eval{t_1}{F_1}{}$ and $\eval{t_2}{F_2}{}$.\\
% By applying the \rname{E-PAIR} rule, we get: $\eval{(t_1,t_2)}{(F_1, F_2)}{}$.\\
% This case is proved.

% \noindent \textbf{Case} 
% $$
% \letx{!x}{t_1}{t_2} 
% $$
% By induction hypothesis, we have: $\eval{t_1}{!t_3}{m_1}$ and $\eval{t_2[t3/x]}{F}{m_2}$.\\
% By applying the \rname{E-LET-BANG} rule, we get: $\eval{\letx{!x}{t_1}{t_2} 
% }{F}{m_1 + m_2}$.\\
% This case is proved.

% \noindent \textbf{Case} 
% $$
% \letx{(x_1,x_2)}{t}{t}
% $$
% \noindent \textbf{Case} 
% $$
% t[]
% $$
% By induction hypothesis, we have $\eval{t}{\Lambda.t'}{m}$.\\
% By applying the \rname{E-IAPP} rule, we get: $\eval{t[]}{t'}{m}$.\\
% This case is proved.


% \noindent \textbf{Case} 
% $$
% M(t)
% $$
% By induction hypothesis, we have $\eval{t}{F}{m}$.\\
% By applying the \rname{E-MECH} rule, we get: $\eval{M(t)}{M(F)}{m}$, this case is proved.

% \noindent \textbf{Case} 
% $$ 
% \tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b}  
% $$
% By induction hypothesis, we have $\eval{t}{F}{m}$ and $\eval{t_i}{F_i}{m_i}$.\\
% By applying the \rname{E-CASE} rule, we get:\\
% $\eval{\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b}}{\tcaseof{F}\ \{c_i \Rightarrow F_i\}_{c_i \in b}}{m + m_i}$.\\
% This case is proved.

% \end{proof}
\newpage
\begin{theorem} [Substitution] $ $
\label{thm:sub}
\begin{enumerate}
    \item If $\Gamma \jtype{n_1}{}{t_1}{\tau_1}$  and   $\Delta, x: \tau_1 \jtype{n_2}{}{t_2}{\tau_2}$ then $max(\Gamma, \Delta) \jtype{\max{(n_1, n_2)}}{}{t_2[t_1/x]}{\tau_2} $
    \item If $\Gamma \jtype{n_1}{}{ t_1}{!_p \tau_1}$  and   $\Delta, x: [\tau_1]_p \jtype{n_2}{}{t_2}{\tau_2}$ then $max(\Gamma, \Delta) \jtype{\max{(n_1 + p, n_2)}}{}{t_2[t_1/x]}{\tau_2} $
\end{enumerate}
\end{theorem}
   \[
   \begin{array}{ccc}
     c [t_1/x]    & ::=& c  \\
     M(t) [t_1/x] &   & M(t[t_1/x]) \\
     x [t_1/x] && t_1 \\
     y [t_1/x] && y \\
     (\app{t}{t'}) [t_1/x] && \app{t[t_1/x]}{t'[t_1/x]}\\
     (\abs{y}{t}) [t_1/x] && \abs{y}{t[t_1/y]} \\
     (\letx{y}{t}{t'})[t_1/x] && \letx{y}{t[t_1/x]}{t'[t_1/x]}\\
   \end{array}
\]

\begin{proof} of \ref{thm:sub}.1 \\
  The theorem is proved by induction on the typing derivation of the second premise $\Delta, x: \tau_1 \jtype{n_2}{}{t_2}{\tau_2} $. Assume we know $\Gamma \jtype{n_1}{}{t_1}{\tau_1} ~ (\diamond)$.

\noindent \textbf{Case} 
$$
   \inferrule*[right = const]
   {\empty}
   {\Delta, x: \tau_1 \jtype{n}{}{c}{b} ~(\star) }
$$
where $t_2 = c$, $\tau_2 = b$ and $n_2 = n$.\\
To show: $\max(\Gamma, \Delta) \jtype{\max{(n_1, n)}}{}{c[t_1/x]}{b} $.\\
Because $c[t_1/x] = c$, it suffices to show $\max(\Gamma, \Delta) \jtype{\max{(n_1, n)}}{}{c}{b} $.\\
This case is proved by applying the $\rname{CONST}$ rule. 

\noindent \textbf{Case} 
$$
    \inferrule*[right = query]
   {\empty}
   {\Delta, x: \tau_1 \jtype{n}{}{q}{query} ~ (\star) }
$$
where $t_2 = q$, $\tau_2 = query$ and $n_2 = n$.\\
To show: $\max{\Gamma, \Delta} \jtype{\max{(n_1, n)}}{}{q[t_1/x]}{query} $.\\
Because $q[t_1/x] = q$, it suffices to show: $max(\Gamma, \Delta) \jtype{\max{(n_1, n)}}{}{q}{query} $.\\
This case is proved by applying the $\rname{QUERY}$ rule. 


\noindent \textbf{Case} 

\noindent \textbf{SubCase 1} 
$$
    \inferrule*[ right = var]
   {\empty}
   {\Delta, x:\tau_1 \jtype{n}{}{x}{\tau_1}  } 
$$
where $t_2 = x$, $\tau_2 = \tau_1$ and $n_2 = n$.\\
To show $\max{(\Gamma, \Delta)} \jtype{\max{(n_1, n)}}{}{x[t_1/x]}{\tau_1} $.\\
it suffices to show $\max{(\Gamma, \Delta)} \jtype{\max{(n_1, n_2)}}{}{t_1}{\tau_1}$.\\
This case is proved by applying Lemma \ref{lem:coweaken1} and \ref{lem:coweaken2} on $(\diamond)$.

\noindent \textbf{SubCase 2} 
$$
    \inferrule*[ right = var]
   {\empty}
   {\Delta, x:\tau_1, y : \tau_2 \jtype{n}{}{y}{\tau_2}} 
$$
where $t_2 = y$ and $n_2 = n$.\\ 
To show $\max{(\Gamma, \Delta, y : \tau_2)} \jtype{\max{(n_1, n)}}{}{y[t_1/x]}{\tau_2} $.\\
it suffices to show $\max{(\Gamma, \Delta, y : \tau_2)} \jtype{n}{}{y}{\tau_2}$.\\
This case is proved by applying the rule \rname{VAR}.

\noindent \textbf{Case} 
$$
    \inferrule*[right = abs]
   {\Delta, x: \tau_1, y: \tau_1' \jtype{n}{}{t}{\tau_2'}~(\star)}
   { \Delta, x: \tau_1 \jtype{n}{}{\abs{y}{t}}{\tau_1' \multimap \tau_2'}  }
$$
where $t_2 = \abs{y}{t}$, $\tau_2 = \tau_1' \multimap \tau_2'$ and $n_2 = n$.\\
To show $\max{(\Gamma, \Delta)} \jtype{\max{(n_1, n)}}{}{\abs{y}{t}[t_1/x]}{\tau_1' \multimap \tau_2'}$.\\
By applying Lemma \ref{lem:coex}  and induction hypothesis on $(\star)$, we get:\\ $\max{(\Gamma, \Delta,  y: \tau_1')} \jtype{\max{(n_1, n_2)}}{}{{t}[t_1/x]}{ \tau_2'}$ $(\star \star)$.\\
By applying the $\rname{ABS}$ rule on $(\star \star)$, we get: $\max{(\Gamma, \Delta)} \jtype{\max{(n_1, n_2)}}{}{\abs{y}{({t}[t_1/x])}}{\tau_1' \multimap \tau_2'}$, this case is proved.\\

\noindent \textbf{Case} 

$$
   \inferrule*[ right = MT ]
   {[\Delta_2] \jtype{n}{}{t}{query} ~ (\star)}
   {\Delta_1, 1 + [\Delta_2], x: \tau_1 \jtype{n+1}{}{M(t)}{b}  }
$$
Where $\Delta = \Delta_1, 1 + [\Delta_2] $, $t_2 = M(t)$, $\tau_2 = b$  and $n_2 = n + 1$.\\
To show $\max(\Gamma, \Delta_1, 1 + [\Delta_2]) \jtype{\max{(n_1, n + 1)}}{}{M(t)[t_1/x]}{b} $.\\
We know $x \not \in \fcv{[\Delta_2]} \land [\Delta_2] \jtype{n}{}{t}{query}  \implies x \not \in \fv{t} $. \\
So we know $t = t[t_1/x] \implies [\Delta_2] \jtype{n}{}{t[t_1/x]}{query}(\star\star)$ \\
By applying the $\rname{MT}$ rule on $(\star \star)$ we get:\\
$\max(\Delta_1, 1 + [\Delta_2]) \jtype{1 + n}{}{M(t)[t_1/x]}{b}~(\clubsuit)$\\
This case is proved using Lemma~\ref{lem:coex}, Lemma~\ref{lem:deweaken1} on ($\clubsuit$).\\


\noindent \textbf{Case} 
$$
  \inferrule*[ right = app ]
   {\Gamma_1 \jtype{n_1}{}{t_1}{\tau_1 \rightarrow \tau_2} \\ \Gamma_2 \jtype{n_2}{}{t_2}{\tau_1}}
   { \max(\Gamma_1, \Gamma_2) \jtype{\max(n_1',n_2')}{}{\app{t_1'}{t_2'}}{\tau_2}  }
$$
There are three sub cases depending on whether $x \in \fcv{\Gamma_1}$ and $\fcv{\Gamma_2}$.\\

 \textbf{SubCase 1} 
$$
  \inferrule*[ right = app ]
   {\Delta_1, x: \tau_1 \jtype{n_1'}{}{t_1'}{\tau_1 \rightarrow \tau_2} ~(\star) \\ \Delta_2 \jtype{n_2'}{}{t_2'}{\tau_1} ~ (\clubsuit)}
   { \max(\Delta_1, x: \tau_1, \Delta_2) \jtype{\max(n_1',n_2')}{}{\app{t_1'}{t_2'}}{\tau_2} }
$$
where $x \not \in \fcv{\Delta_2}$. \\
$\Delta = \max(\Delta_1, \Delta_2)$, $t_2 = \app{t_1'}{t_2'}$ and $n_2 = \max(n_1',n_2')$.\\
To show $\max(\Gamma,\max(\Delta_1, \Delta_2))\jtype{\max(n_1, \max(n_1',n_2'))}{}{\app{t_1'}{t_2'}[t_1/x]}{\tau_2} $.\\
it suffices to show $\max(\Gamma,\Delta_1, \Delta_2)\jtype{\max(n_1, n_1',n_2')}{}{\app{t_1'}{t_2'}[t_1/x]}{\tau_2} $.\\
By induction hypothesis on $(\star)$, we get: 
$\max(\Gamma,\Delta_1)\jtype{\max(n_1, n_1')}{}{t_1'[t_1/x]}{\tau_1 \rightarrow \tau_2}~(\star \star) $.\\
Because $x \not \in \fcv{\Delta_2} \implies t_2'[t_1/x] = t_2'$.\\
By applying $\rname{APP}$ on $(\star \star)$ and $(\clubsuit)$, we get:
$\max(\max(\Gamma,\Delta_1), \Delta_2)\jtype{\max(\max(n_1, n_1'),n_2')}{}{(\app{t_1'}{t_2'})[t_1/x]}{\tau_2} $.\\
This case is proved.\\

 \textbf{SubCase 2} 
$$
  \inferrule*[ right = app ]
   {\Delta_1 \jtype{n_1'}{}{t_1'}{\tau_1 \rightarrow \tau_2} ~(\star) \\ \Delta_2, x: \tau_1 \jtype{n_2'}{}{t_2'}{\tau_1} ~ (\clubsuit)}
   { \max(\Delta_1 \Delta_2, x: \tau_1) \jtype{\max(n_1',n_2')}{}{\app{t_1'}{t_2'}}{\tau_2} }
$$
where $x \not \in \fcv{\Delta_1}$ .\\
This case is proved by induction hypothesis on $(\clubsuit)$ and applying $\rname{APP}$ rule.\\

 \textbf{SubCase 3} 
$$
  \inferrule*[ right = app ]
   {\Delta_1, x: \tau_1 \jtype{n_1'}{}{t_1'}{\tau_1 \rightarrow \tau_2}~(\star) \\ \Delta_2, x: \tau_1 \jtype{n_2'}{}{t_2'}{\tau_1}~(\clubsuit)}
   { \max(\Delta_1, \Delta_2, x: \tau_1) \jtype{\max(n_1',n_2')}{}{\app{t_1'}{t_2'}}{\tau_2}  }
$$
TS: $\max(\Gamma, \max( \Delta_1, \Delta_2) ) \jtype{\max(n_1, \max(n_1',n_2'))}{}{\app{t_1'}{t_2'}}{\tau_2} $. \\
This case is proved by induction hypothesis on both $(\clubsuit)$ and $(\star)$ and then applying $\rname{APP}$ rule.\\

\noindent \textbf{Case} 
$$
   \inferrule*[ right = der ]
   {\Delta', x:\tau_1, y: \tau \jtype{n}{}{t_2}{ \tau_2 }~ (\star)}
   { \Delta' ,  x:\tau_1, y: [\tau]_p \jtype{n}{}{t_2}{\tau_2}  }
$$
where $\Delta = \Delta', y: [\tau]_p$, $n_2 = n$.\\
To show $\max(\Gamma, \Delta', y: [\tau]_p) \jtype{\max(n_1, n)}{}{t_2[t_1/x]}{\tau_2}$.\\
By induction hypothesis on $(\star)$, we get:
$\max(\Gamma, \Delta', y: \tau) \jtype{\max(n_1, n)}{}{t_2[t_1/x]}{\tau_2} (\star \star)$.\\
By applying the $\rname{DER}$ rule on $(\star \star)$, we get:
$\max(\Gamma, \Delta', y: [\tau]_p) \jtype{\max(n_1, n)}{}{t_2[t_1/x]}{\tau_2}$.\\
This case is proved.\\


\noindent \textbf{Case} 
\[
   \inferrule*[ right = let ]
   {\Gamma_1 \jtype{n_1}{}{t}{!_p \tau} \\ \Gamma_2, y: [\tau]_p \jtype{n_2}{}{t'}{\tau'}}
   { \max(\Gamma_1, \Gamma_2) \jtype{\max(n_1,n_2)}{}{\letx{!y}{t}{t'}}{\tau'}  }
\]
There are three sub cases.

\textbf{Subcase 1: x $\not \in \fcv{\Delta_2}$ }
\[
   \inferrule*[ right = let ]
   {\Delta_1, x: \tau_1 \jtype{n_1'}{}{t}{!_p \tau}~(\star) \\ \Delta_2, y: [\tau]_p \jtype{n_2'}{}{t'}{\tau'}~(\clubsuit)}
   {  \max(\Delta_1, x: \tau_1, \Delta_2) \jtype{\max(n_1',n_2')}{}{\letx{!y}{t}{t'}}{\tau'}  }
\]
 TS: $ \max(\Gamma, \max(\Delta_1,\Delta_2) ) \jtype{\max(n_1,\max(n_1',n_2') )}{}{  (\letx{!y}{t}{t'})[t_1/x] }{\tau'}  $. \\
 By IH on ($\star$), we get $\max(\Gamma, \Delta_1) \jtype{\max(n_1,n_1') }{}{t[t_1/x]}{!_p \tau}~(\star\star) $. \\
 $x \not \in \fcv{\Delta_2} \implies t'[t_1/x] =  t'$.\\
 It is proved by the rule \rname{LET} using ($\star\star$) and ($\clubsuit$). \\

\textbf{Subcase 2: x $\not \in \fcv{\Delta_1}$ }
\[
   \inferrule*[ right = let ]
   {\Delta_1 \jtype{n_1'}{}{t}{!_p \tau}~(\star) \\ \Delta_2, x: \tau_1, y: [\tau]_p \jtype{n_2'}{}{t'}{\tau'}~(\clubsuit)}
   {  \max(\Delta_1, x: \tau_1, \Delta_2) \jtype{\max(n_1',n_2')}{}{\letx{!y}{t}{t'}}{\tau'}  }
\]
 TS: $ \max(\Gamma, \max(\Delta_1,\Delta_2) ) \jtype{\max(n_1,\max(n_1',n_2') )}{}{  (\letx{!y}{t}{t'})[t_1/x] }{\tau'}  $. \\
By IH on ($\clubsuit$), we get $\max(\Gamma, \Delta_2),y:[\tau]_p \jtype{\max(n_1,n_2') }{}{t'[t_1/x]}{\tau'}~(\clubsuit\clubsuit) $. \\
 $x \not \in \fcv{\Delta_1} \implies t[t_1/x] = t $.\\
It is proved by the rule \rname{LET} using ($\star$) and ($\clubsuit\clubsuit$). \\

\textbf{Subcase 3 }
\[
   \inferrule*[ right = let ]
   {\Delta_1, x:\tau_1 \jtype{n_1'}{}{t}{!_p \tau}~(\star) \\ \Delta_2, x: \tau_1, y: [\tau]_p \jtype{n_2'}{}{t'}{\tau'}~(\clubsuit)}
   {  \max(\Delta_1, x: \tau_1, \Delta_2) \jtype{\max(n_1',n_2')}{}{\letx{!y}{t}{t'}}{\tau'}  }
\]
TS: $ \max(\Gamma, \max(\Delta_1,\Delta_2) ) \jtype{\max(n_1,\max(n_1',n_2') )}{}{  (\letx{!y}{t}{t'})[t_1/x] }{\tau'}  $. \\
By IH on ($\star$), we get $\max(\Gamma, \Delta_1) \jtype{\max(n_1,n_1') }{}{t[t_1/x]}{!_p \tau}~(\star\star) $. \\
By IH on ($\clubsuit$), we get $\max(\Gamma, \Delta_2),y:[\tau]_p \jtype{\max(n_1,n_2') }{}{t'[t_1/x]}{\tau'}~(\clubsuit\clubsuit) $. \\
It is proved by the rule \rname{LET} using ($\star\star$) and ($\clubsuit\clubsuit$).\\

\noindent \textbf{Case} 
\[
   \inferrule*[ right = let-p ]
   {\Gamma_1 \jtype{n_1'}{}{t}{\tau_1' \times \tau_2' } \\ \Gamma_2, x_1: \tau_1', x_2 : \tau_2' \jtype{n_2'}{}{t'}{\tau'}}
   { \max(\Gamma_1, \Gamma_2)  \jtype{\max(n_1',n_2')}{}{ \letx{(x_1,x_2)}{t}{t'} }{\tau'}  }
\]
There are three sub cases.\\
\textbf{Subcase 1: x $\not \in \fcv{\Delta_2}$ }
\[
   \inferrule*[ right = let-p ]
   {\Delta_1, x: \tau_1 \jtype{n_1'}{}{t}{\tau_1' \times \tau_2'}~(\star) \\ \Delta_2, x_1:\tau_1', x_2: \tau_2' \jtype{n_2'}{}{t'}{\tau'}~(\clubsuit)}
   {  \max(\Delta_1, x: \tau_1, \Delta_2) \jtype{\max(n_1',n_2')}{}{\letx{(x_1,x_2)}{t}{t'}}{\tau'}  }
\]
 TS: $ \max(\Gamma, \max(\Delta_1,\Delta_2) ) \jtype{\max(n_1,\max(n_1',n_2') )}{}{  (\letx{(x_1,x_2)}{t}{t'})[t_1/x] }{\tau'}  $. \\
 By IH on ($\star$), we get $\max(\Gamma, \Delta_1) \jtype{\max(n_1,n_1') }{}{t[t_1/x]}{\tau_1' \times \tau_2'}~(\star\star) $. \\
 $x \not \in \fcv{\Delta_2} \implies t'[t_1/x] =  t'$.\\
 It is proved by the rule \rname{LET-P} using ($\star\star$) and ($\clubsuit$). \\

\textbf{Subcase 2: x $\not \in \fcv{\Delta_1}$ }
\[
   \inferrule*[ right = let-p ]
   {\Delta_1 \jtype{n_1'}{}{t}{\tau_1' \times \tau_2'}~(\star) \\ \Delta_2, x_1:\tau_1', x_2: \tau_2' , x: \tau_1 \jtype{n_2'}{}{t'}{\tau'}~(\clubsuit)}
   {  \max(\Delta_1, x: \tau_1, \Delta_2) \jtype{\max(n_1',n_2')}{}{\letx{(x_1,x_2)}{t}{t'}}{\tau'}  }
\]
 TS: $ \max(\Gamma, \max(\Delta_1,\Delta_2) ) \jtype{\max(n_1,\max(n_1',n_2') )}{}{  (\letx{(x_1,x_2)}{t}{t'})[t_1/x] }{\tau'}  $. \\
By IH on ($\clubsuit$), we get $\max(\Gamma, \Delta_2), x_1:\tau_1', x_2: \tau_2'  \jtype{\max(n_1,n_2') }{}{t'[t_1/x]}{\tau'}~(\clubsuit\clubsuit) $. \\
 $x \not \in \fcv{\Delta_1} \implies t[t_1/x] = t $.\\
It is proved by the rule \rname{LET-P} using ($\star$) and ($\clubsuit\clubsuit$). \\

\textbf{Subcase 3 }
\[
    \inferrule*[ right = let-p ]
   {\Delta_1 , x: \tau_1 \jtype{n_1'}{}{t}{\tau_1' \times \tau_2'}~(\star) \\ \Delta_2, x_1:\tau_1', x_2: \tau_2' , x: \tau_1 \jtype{n_2'}{}{t'}{\tau'}~(\clubsuit)}
   {  \max(\Delta_1, x: \tau_1, \Delta_2) \jtype{\max(n_1',n_2')}{}{\letx{(x_1,x_2)}{t}{t'}}{\tau'}  }
\]
TS: $ \max(\Gamma, \max(\Delta_1,\Delta_2) ) \jtype{\max(n_1,\max(n_1',n_2') )}{}{  (\letx{(x_1,x_2)}{t}{t'} )[t_1/x] }{\tau'}  $. \\
By IH on ($\star$), we get $\max(\Gamma, \Delta_1) \jtype{\max(n_1,n_1') }{}{t[t_1/x]}{\tau_1' \times \tau_2'}~(\star\star) $. \\
By IH on ($\clubsuit$), we get $\max(\Gamma, \Delta_2),x_1: \tau_1', x_2:\tau_2' \jtype{\max(n_1,n_2') }{}{t'[t_1/x]}{\tau'}~(\clubsuit\clubsuit) $. \\
It is proved by the rule \rname{LET-P} using ($\star\star$) and ($\clubsuit\clubsuit$).\\


\noindent \textbf{Case} 
\[
     \inferrule*[right = pair]
   {\Gamma_1 \jtype{n_1'}{}{t_1}{\tau_1} \\ \Gamma_2 \jtype{n_2'}{}{t_2}{\tau_2}}
   { \max(\Gamma_1, \Gamma_2)  \jtype{\max(n_1',n_2')}{}{(t_1, t_2)}{\tau_1 \times \tau_2}  }
\]
There are three sub cases,$x$ only in $\Gamma_1$,  $x$ only in $\Gamma_2$ and $x$  appears in both $\Gamma_1$ and $\Gamma_2$. When $x$ only in $\Gamma_1$, it is proved by ih on the first premise and then using the rule \rname{PAIR}. When $x$ only in $\Gamma_2$, it is proved by ih on the second premise and then using the rule \rname{PAIR}. When $x$  appears in both $\Gamma_1$ and $\Gamma_2$, it is proved by ih on both premises and then using rule \rname{PAIR}.\\

\noindent \textbf{Case} 
\[
    \inferrule*[ right = case-const ]
   {\Gamma_1 \jtype{n_1'}{}{t}{b} \\ \Gamma_2 \jtype{n_2'}{}{t_i}{b} }
   {\max(\Gamma_1, \Gamma_2) \jtype{\max(n_1',n_2')}{}{\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b} } {b} }
\]
There are three sub cases.\\

\textbf{Subcase 1: x $\not \in \fcv{\Delta_2}$ }
\[
   \inferrule*[ right = case-const ]
   {\Delta_1, x: \tau_1 \jtype{n_1'}{}{t}{b}~(\star) \\ \Delta_2 \jtype{n_2'}{}{t_i}{b}~(\clubsuit) }
   {\max(\Delta_1, \Delta_2) \jtype{\max(n_1',n_2')}{}{\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b} } {b} }
\]
 TS: $ \max(\Gamma, \max(\Delta_1,\Delta_2) ) \jtype{\max(n_1,\max(n_1',n_2') )}{}{  (\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b})[t_1/x] }{b}  $. \\
 By IH on ($\star$), we get $\max(\Gamma, \Delta_1) \jtype{\max(n_1,n_1') }{}{t[t_1/x]}{b}~(\star\star) $. \\
 $x \not \in \fcv{\Delta_2} \implies t_i[t_1/x] =  t_i$.\\
 It is proved by the rule \rname{CASE-CONST} using ($\star\star$) and ($\clubsuit$). \\

\textbf{Subcase 2: x $\not \in \fcv{\Delta_1}$ }
\[
     \inferrule*[ right = case-const ]
   {\Delta_1 \jtype{n_1'}{}{t}{b}~(\star) \\ \Delta_2, x: \tau_1 \jtype{n_2'}{}{t_i}{b}~(\clubsuit) }
   {\max(\Delta_1, \Delta_2) \jtype{\max(n_1',n_2')}{}{\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b} } {b} }
\]
 TS: $ \max(\Gamma, \max(\Delta_1,\Delta_2) ) \jtype{\max(n_1,\max(n_1',n_2') )}{}{  (\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b})[t_1/x] }{b}  $. \\
By IH on ($\clubsuit$), we get $\max(\Gamma, \Delta_2) \jtype{\max(n_1,n_2') }{}{t_i[t_1/x]}{b}~(\clubsuit\clubsuit) $. \\
 $x \not \in \fcv{\Delta_1} \implies t[t_1/x] = t $.\\
It is proved by the rule \rname{CASE-CONST} using ($\star$) and ($\clubsuit\clubsuit$). \\

\textbf{Subcase 3 }
\[
    \inferrule*[ right = case-const ]
   {\Delta_1 , x: \tau_1 \jtype{n_1'}{}{t}{b}~(\star) \\ \Delta_2, x: \tau_1 \jtype{n_2'}{}{t_i}{b}~(\clubsuit) }
   {\max(\Delta_1, \Delta_2) \jtype{\max(n_1',n_2')}{}{\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b} } {b} }
\]
 TS: $ \max(\Gamma, \max(\Delta_1,\Delta_2) ) \jtype{\max(n_1,\max(n_1',n_2') )}{}{  (\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b})[t_1/x] }{b}  $. \\
By IH on ($\star$), we get $\max(\Gamma, \Delta_1) \jtype{\max(n_1,n_1') }{}{t[t_1/x]}{b}~(\star\star) $. \\
By IH on ($\clubsuit$), we get $\max(\Gamma, \Delta_2) \jtype{\max(n_1,n_2') }{}{t_i[t_1/x]}{b}~(\clubsuit\clubsuit) $.. \\
It is proved by the rule \rname{CASE-CONST} using ($\star\star$) and ($\clubsuit\clubsuit$).\\



\noindent \textbf{Case} 
\[
    \inferrule*[ right = case-query]
   {\Gamma_1 \jtype{n_1'}{}{t}{b} \\ \Gamma_2 \jtype{n_2'}{}{t_i}{query} }
   {\max(\Gamma_1, \Gamma_2) \jtype{\max(n_1',n_2')}{}{\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b} } {query} }
\]
There are three sub cases. Thre proof are quite similar as the one of \emph{CASE-CONST}.\\

\noindent \textbf{Case} 
\[
   \inferrule*[right = iabs]
  { 
    \inferrule*[]
    {}
    {i::\mathbb{N};\Delta,x:\tau_1 \jtype{n}{}{t}{ \tau } ~(\star)}
    \and
    \inferrule*[]
    {}
    { i \notin \fiv{\Delta,x:\tau_1}  } 
  }
  { \Delta, x:\tau_1 \jtype{n}{ }{  \Lambda.t  }{ \tforallN{i}{\tau}  } }
 \]
 TS: $\max(\Gamma, \Delta) \jtype{\max(n_1,n)}{}{\Lambda.t[t_1/x] }{\tforallN{i}{\tau}} $.\\
 By ih on ($\star$), we get : $ i :: \mathbb{N};\max(\Gamma, \Delta) \jtype{\max(n_1,n)}{}{t[t_1/x]}{\tau}(\star\star)$.\\
 There are two cases.\\
 \textbf{Sub case 1: $i \not \in \fiv{\Gamma}$}
  It is proved by using rule \rname{IABS} with $(\star\star)$.\\
  \textbf{Sub case 2: $i \in \fiv{\Gamma}$}
  We choose $j \not \in \fiv{\max(\Gamma,\Delta)}$. We rename all the $i$ to $j$ in $(\star\star)$ and use rule \rname{IABS} to get:
  $ \max(\Gamma, \Delta) \jtype{\max(n_1,n)}{}{\Lambda.t[t_1/x] }{\tforallN{j}{\tau}}$. It is just a renaming version of the goal.
 

\noindent \textbf{Case} 
\[ 
   \inferrule*[ right =  iapp]
  { 
    \inferrule*[]
    {}
    { \Delta, x:\tau_1  \jtype{n}{}{t}{ \tforallN{i}{\tau}   } (\star) }
    \and
    \inferrule*[]
    {}
    { \jiterm{I}{ \mathbb{N} } } 
  }
  {\Delta, x:\tau_1 \jtype{n }{ }{t\, [] }{ \tau \{ I/i \}  } }
\]
TS: $ \max(\Gamma, \Delta) \jtype{\max(n_1,n)}{}{t[t_1/x] \, []}{ \tau \{ I/i \} } $.\\
By ih on $(\star)$, we get: $ \max(\Gamma,\Delta)  \jtype{\max(n_1,n)}{}{t}{ \tforallN{i}{\tau} } ~ (\star\star) $.\\
It is proved by the rule \rname{IAPP} with $(\star\star)$.\\

\noindent \textbf{Case} 
$$
  \inferrule*[right = sub]
  { 
   { \Delta, x:\tau_1 \jtype{n}{}{t}{\tau} ~(\star) } \\
   { \Delta', x:\tau_1 \subseteq \Delta,x:\tau_1 ~ (\clubsuit) }  \\
   { \vDash n \leq n' } ~(\spadesuit) \\
   { \tau \subseteq \tau' }
  }
  { \Delta',x:\tau_1 \jtype{n'}{}{t}{\tau'} }
$$
TS: $ \max(\Gamma, \Delta') \jtype{\max(n',n_1)}{}{t}{\tau'}$.\\
By ih on ($\star$), we get : $\max(\Gamma, \Delta) \jtype{\max(n,n_1)}{}{t}{\tau} $.\\
$(\clubsuit) \implies \max(\Gamma,\Delta') \subseteq \max(\Gamma,\Delta)~(\clubsuit\clubsuit) $.\\
$ (\spadesuit) \implies  \vDash \max(n_1,n) \leq \max(n_1,n') $.\\
It is proved by the rule \rname{SUB}.\\


\noindent \textbf{Case}
\[
\inferrule*[right = pr]
   {[\Delta_2] \jtype{n}{}{t}{\tau}}
   {\Delta_1, p + [\Delta_2], x:\tau_1 \jtype{n + p}{}{!t}{!_p \tau}  }
\]
TS: $\max(\Gamma,(\Delta_1, p+[\Delta_2]) ) \jtype{\max(n_1, n + p)}{}{!t[t_1/x]}{!_p \tau}$.\\
$x \not \in [\Delta_2] \implies [\Delta_2] \jtype{n}{}{t[t_1/x]}{\tau}(\star)$.\\
By rule \rname{PR} with $(\star)$, we get: $\Delta_1, p+[\Delta_2] \jtype{ n + p}{}{!t[t_1/x]}{!_p \tau} $.
It is proved by the Lemma \ref{lem:coex} and Lemma~\ref{lem:deweaken1} from the conclusion.

\end{proof}



\newpage
\begin{proof} of \ref{thm:sub}.2 \\
  The theorem is proved by induction on the typing derivation of the second premise $\Delta, x: [\tau_1]_p \jtype{n_2}{}{t_2}{\tau_2}$. Assume we know $\Gamma \jtype{n_1}{}{t_1}{!_p \tau_1}~(\diamond)$.


$$
   \inferrule*[right = const]
   {\empty}
   {\Delta, x: [\tau_1]_p \jtype{n}{}{c}{b} ~(\star) }
$$
where $t_2 = c$, $\tau_2 = b$ and $n_2 = n$.\\
To show: $\max(\Gamma, \Delta) \jtype{\max{(n_1 + p, n)}}{}{c[t_1/x]}{b} $.\\
Because $c[t_1/x] = c$, it suffices to show $\max(\Gamma, \Delta) \jtype{\max{(n_1 + p, n)}}{}{c}{b} $.\\
This case is proved by applying the $\rname{CONST}$ rule. 


\noindent \textbf{Case} 
$$
    \inferrule*[right = query]
   {\empty}
   {\Delta, x: [\tau_1]_p  \jtype{n}{}{q}{query} ~ (\star) }
$$
where $t_2 = q$, $\tau_2 = query$ and $n_2 = n$.\\
To show: $\max{\Gamma, \Delta} \jtype{\max{(n_1 + p, n)}}{}{q[t_1/x]}{query} $.\\
Because $q[t_1/x] = q$, it suffices to show: $max(\Gamma, \Delta) \jtype{\max{(n_1, n)}}{}{q}{query} $.\\
This case is proved by applying the $\rname{QUERY}$ rule. 


\noindent \textbf{Case} 

$$
    \inferrule*[ right = var]
   {\empty}
   {\Delta, x:[\tau_1]_p, y : \tau_2 \jtype{n}{}{y}{\tau_2}} 
$$
where $t_2 = y$ and $n_2 = n$.\\ 
To show $\max{(\Gamma, \Delta, y : \tau_2)} \jtype{\max{(n_1 + p, n)}}{}{y[t_1/x]}{\tau_2} $.\\
it suffices to show $\max{(\Gamma, \Delta, y : \tau_2)} \jtype{n}{}{y}{\tau_2}$.\\
This case is proved by applying the rule \rname{VAR}.

\noindent \textbf{Case} 
$$
    \inferrule*[right = abs]
   {\Delta, x: [\tau_1]_p, y: \tau_1' \jtype{n}{}{t}{\tau_2'}~(\star)}
   { \Delta, x: [\tau_1]_p \jtype{n}{}{\abs{y}{t}}{\tau_1' \multimap \tau_2'}  }
$$
where $t_2 = \abs{y}{t}$, $\tau_2 = \tau_1' \multimap \tau_2'$ and $n_2 = n$.\\
To show $\max{(\Gamma, \Delta)} \jtype{\max{(n_1 + p, n)}}{}{\abs{y}{t}[t_1/x]}{\tau_1' \multimap \tau_2'}$.\\
By applying Lemma \ref{lem:coex}  and induction hypothesis on $(\star)$, we get:\\ $\max{(\Gamma, \Delta,  y: \tau_1')} \jtype{\max{(n_1 + p, n_2)}}{}{{t}[t_1/x]}{ \tau_2'}$ $(\star \star)$.\\
By applying the $\rname{ABS}$ rule on $(\star \star)$, we get: $\max{(\Gamma, \Delta)} \jtype{\max{(n_1 + p, n_2)}}{}{\abs{y}{({t}[t_1/x])}}{\tau_1' \multimap \tau_2'}$, this case is proved.\\


\noindent \textbf{Case} 
$$
   \inferrule*[ right = MT ]
   {[\Delta_2], x: [\tau_1]_{p-1} \jtype{n}{}{t}{query} ~ (\star)}
   {\Delta_1, 1 + [\Delta_2], x: [\tau_1]_{p} \jtype{n+1}{}{M(t)}{b}  }
$$
Where $\Delta = \Delta_1, 1 + [\Delta_2] $, $t_2 = M(t)$, $\tau_2 = b$ and $n_2 = n + 1$.\\
To show $max(\Gamma, \Delta_1, 1 + [\Delta_2]) \jtype{\max{(n_1 + p, n + 1)}}{}{M(t)[t_1/x]}{b} $.\\
By induction hypothesis on $ (\star)$, we get:
$max(\Gamma, [\Delta_2]) \jtype{\max{(n_1 + p - 1, n)}}{}{t[t_1/x]}{query}~ (\star \star)$.\\
By applying the $\rname{MT}$ rule on $~ (\star \star)$, we get: 
$\Delta_1, max(\Gamma, 1 + [\Delta_2]) \jtype{1 + \max{(n_1 + p - 1, n)}}{}{M(t[t_1/x])}{b}$.\\
Because $\Delta_1$ and $\Delta_2$ are disjoint and $1 + \max{(n_1 + p - 1, n)} = \max{(n_1 + p, n + 1)}$, we get: \\
$\max(\Gamma,(\Delta_1, 1 + [\Delta_2])) \jtype{\max{(n_1 + p, n + 1)}}{}{M(t)[t_1/x]}{b}$.\\
This case is proved.


\noindent \textbf{Case} 
$$
  \inferrule*[ right = app ]
   {\Gamma_1 \jtype{n_1}{}{t_1}{\tau_1 \rightarrow \tau_2} \\ \Gamma_2 \jtype{n_2}{}{t_2}{\tau_1}}
   { \max(\Gamma_1, \Gamma_2) \jtype{\max(n_1,n_2)}{}{\app{t_1}{t_2}}{\tau_2}  }
$$
There are three sub cases depending on whether $x \in \fcv{\Gamma_1}$ and $\fcv{\Gamma_2}$.\\

 \textbf{Subcase 1 x $\not \in \fcv{\Delta_2}$ } 
$$
  \inferrule*[ right = app ]
   {\Delta_1, x: [\tau_1]_p \jtype{n_1'}{}{t_1'}{\tau_1 \rightarrow \tau_2} ~(\star) \\ \Delta_2 \jtype{n_2'}{}{t_2'}{\tau_1} ~ (\clubsuit)}
   { \max(\Delta_1, x: [\tau_1]_p, \Delta_2) \jtype{\max(n_1',n_2')}{}{\app{t_1'}{t_2'}}{\tau_2} }
$$
where $\Delta = \max(\Delta_1, \Delta_2)$, $t_2 = \app{t_1'}{t_2'}$ and $n_2 = \max(n_1',n_2')$.\\
To show $\max(\Gamma,\max(\Delta_1, \Delta_2))\jtype{\max(n_1 + p, \max(n_1',n_2'))}{}{\app{t_1'}{t_2'}[t_1/x]}{\tau_2} $.\\
it suffices to show $\max(\Gamma,\Delta_1, \Delta_2)\jtype{\max(n_1 + p, n_1',n_2')}{}{\app{t_1'}{t_2'}[t_1/x]}{\tau_2} $.\\
By induction hypothesis on $(\star)$, we get: 
$\max(\Gamma,\Delta_1)\jtype{\max(n_1 + p, n_1')}{}{t_1'[t_1/x]}{\tau_1 \rightarrow \tau_2} ~ (\star \star)$.\\
Because $x \not \in \fcv{\Delta_2} \implies t_2'[t_1/x] = t_2'$.\\
By applying $\rname{APP}$ on $(\star \star)$ and $(\clubsuit)$, we get:
$\max(\max(\Gamma,\Delta_1), \Delta_2)\jtype{\max(\max(n_1 + p, n_1'),n_2')}{}{(\app{t_1'}{t_2'})[t_1/x]}{\tau_2} $.\\
This case is proved.\\

\textbf{Subcase 2 x $\not \in \fcv{\Delta_1}$ } 
$$
  \inferrule*[ right = app ]
   {\Delta_1 \jtype{n_1'}{}{t_1'}{\tau_1 \rightarrow \tau_2} ~(\star) \\ \Delta_2, x: [\tau_1]_p \jtype{n_2'}{}{t_2'}{\tau_1} ~ (\clubsuit)}
   { \max(\Delta_1 \Delta_2, x: [\tau_1]_p) \jtype{\max(n_1',n_2')}{}{\app{t_1'}{t_2'}}{\tau_2} }
$$
This case is proved by induction hypothesis on $(\clubsuit)$ and applying $\rname{APP}$ rule.\\

 \textbf{Subcase 3} 
$$
  \inferrule*[ right = app ]
   {\Delta_1, x: [\tau_1]_p \jtype{n_1'}{}{t_1'}{\tau_1 \rightarrow \tau_2}~(\star) \\ \Delta_2, x: [\tau_1]_p \jtype{n_2'}{}{t_2'}{\tau_1}~(\clubsuit)}
   { \max(\Delta_1, \Delta_2, x: [\tau_1]_p) \jtype{\max(n_1',n_2')}{}{\app{t_1'}{t_2'}}{\tau_2}  }
$$
To show: $\max(\Gamma, \max( \Delta_1, \Delta_2) ) \jtype{\max(n_1 + p, \max(n_1',n_2'))}{}{\app{t_1'}{t_2'}}{\tau_2} $. \\
This case is proved by induction hypothesis on both $(\clubsuit)$ and $(\star)$ and then applying $\rname{APP}$ rule.\\


\noindent \textbf{Case} 
$$
   \inferrule*[ right = der ]
   {\Delta, x: \tau \jtype{n}{}{t_2}{ \tau_2 }  }
   { \Delta , x: [\tau]_p \jtype{n }{}{t_2 }{\tau_2 }  }
$$

\textbf{Subcase 1} 
$$
   \inferrule*[ right = der ]
   {\Delta, x: \tau \jtype{n}{}{t_2}{ \tau_2 }  }
   { \Delta , x: [\tau]_p \jtype{n}{}{t_2}{ \tau_2 }  }
$$
where  $n_2 = n$.\\
To show $\max(\Gamma, \Delta) \jtype{\max(n_1 + p, n)}{}{t_2[t_1/x]}{\tau_2}$\\
By induction hypothesis on $(\star)$, this case is proved.

\textbf{Subcase 2} 
$$
   \inferrule*[ right = der ]
   {\Delta', y: \tau, x : [\tau]_p \jtype{n}{}{t_2}{ \tau_2 } ~ (\star) }
   {\Delta' , y: [\tau]_{p'}, x : [\tau]_p \jtype{n }{}{t_2 }{\tau_2 } }
$$
where $\Delta =\Delta', y: [\tau]_{p'} $ and $n_2 = n$.\\
To show $\max(\Gamma, \Delta', y: [\tau]_{p'}) \jtype{\max(n_1 + p, n_2)}{}{t_2[t_1/x]}{\tau_2}$.\\
By induction hypothesis on $(\star)$, we get: 
$ \max(\Gamma, \Delta', y: \tau) \jtype{\max(n_1 + p, n)}{}{t_2[t_1/x]}{\tau_2} (\star \star)$.\\
By applying $\rname{DER}$ rule on $(\star \star)$, we get:
$ \max(\Gamma, \Delta', y: [\tau]_p') \jtype{\max(n_1 + p, n)}{}{t_2[t_1/x]}{\tau_2}$.\\
This case is proved.


\noindent \textbf{Case} 
$$
   \inferrule*[ right = let ]
   {\Gamma_1 \jtype{n_1}{}{t}{!_p \tau} \\ \Gamma_2, x: [\tau]_p \jtype{n_2}{}{t'}{\tau'}}
   { \max(\Gamma_1, \Gamma_2)  \jtype{\max(n_1,n_2)}{}{\letx{!x}{t}{t'}}{\tau'}  }
$$
There are three sub cases.

\textbf{Subcase 1: x $\not \in \fcv{\Delta_2}$ }
\[
   \inferrule*[ right = let ]
   {\Delta_1, x: [\tau_1]_p \jtype{n_1'}{}{t}{!_p \tau}~(\star) \\ \Delta_2, y: [\tau]_p \jtype{n_2'}{}{t'}{\tau'}~(\clubsuit)}
   {  \max(\Delta_1, x: [\tau_1]_p, \Delta_2) \jtype{\max(n_1',n_2')}{}{\letx{!y}{t}{t'}}{\tau'}  }
\]
where $\Delta = \max(\Delta_1, \Delta_2)$, $t_2 =\letx{!y}{t}{t'}$, $\tau_2 = \tau'$ and $n_2 = \max(n_1', n_2')$.\\
To show $ \max(\Gamma, \max(\Delta_1,\Delta_2) ) \jtype{\max(n_1 + p,\max(n_1',n_2') )}{}{(\letx{!y}{t}{t'})[t_1/x] }{\tau'}  $. \\
 By induction hypothesis on ($\star$), we get $\max(\Gamma, \Delta_1) \jtype{\max(n_1 + p,n_1') }{}{t[t_1/x]}{!_p \tau}~(\star\star) $. \\
 $x \not \in \fcv{\Delta_2} \implies t'[t_1/x] =  t'$.\\
 It is proved by the rule \rname{LET} using ($\star\star$) and ($\clubsuit$). \\

\textbf{Subcase 2: x $\not \in \fcv{\Delta_1}$ }
\[
   \inferrule*[ right = let ]
   {\Delta_1 \jtype{n_1'}{}{t}{!_p \tau}~(\star) \\ \Delta_2, x: [\tau_1]_p, y: [\tau]_p \jtype{n_2'}{}{t'}{\tau'}~(\clubsuit)}
   {  \max(\Delta_1, x: [\tau_1]_p, \Delta_2) \jtype{\max(n_1',n_2')}{}{\letx{!y}{t}{t'}}{\tau'}  }
\]
where $\Delta = \max(\Delta_1, \Delta_2)$, $t_2 =\letx{!y}{t}{t'}$, $\tau_2 = \tau'$ and $n_2 = \max(n_1', n_2')$.\\
To show $ \max(\Gamma, \max(\Delta_1,\Delta_2) ) \jtype{\max(n_1 + p,\max(n_1',n_2') )}{}{  (\letx{!y}{t}{t'})[t_1/x] }{\tau'}$. \\
By induction hypothesis on ($\clubsuit$), we get $\max(\Gamma, \Delta_2),y:[\tau]_p \jtype{\max(n_1 + p,n_2') }{}{t'[t_1/x]}{\tau'}~(\clubsuit\clubsuit) $. \\
 $x \not \in \fcv{\Delta_1} \implies t[t_1/x] = t $.\\
It is proved by the rule \rname{LET} using ($\star$) and ($\clubsuit\clubsuit$). \\

\textbf{Subcase 3 }
\[
   \inferrule*[ right = let ]
   {\Delta_1, x:[\tau_1]_p \jtype{n_1'}{}{t}{!_p \tau}~(\star) \\ \Delta_2, x: [\tau_1], y: [\tau]_p \jtype{n_2'}{}{t'}{\tau'}~(\clubsuit)}
   {  \max(\Delta_1, x: [\tau_1]_p, \Delta_2) \jtype{\max(n_1',n_2')}{}{\letx{!y}{t}{t'}}{\tau'}  }
\]
where $\Delta = \max(\Delta_1, \Delta_2)$, $t_2 =\letx{!y}{t}{t'}$, $\tau_2 = \tau'$ and $n_2 = \max(n_1', n_2')$.\\
To show $ \max(\Gamma, \max(\Delta_1,\Delta_2) ) \jtype{\max(n_1 + p,\max(n_1',n_2') )}{}{  (\letx{!y}{t}{t'})[t_1/x] }{\tau'}  $. \\
By induction hypothesis on ($\star$), we get $\max(\Gamma, \Delta_1) \jtype{\max(n_1 + p,n_1') }{}{t[t_1/x]}{!_p \tau}~(\star\star) $. \\
By induction hypothesis on ($\clubsuit$), we get $\max(\Gamma, \Delta_2),y:[\tau]_p \jtype{\max(n_1 + p,n_2') }{}{t'[t_1/x]}{\tau'}~(\clubsuit\clubsuit) $. \\
It is proved by the rule \rname{LET} using ($\star\star$) and ($\clubsuit\clubsuit$).\\

\noindent \textbf{Case} 
$$
   \inferrule*[ right = let-p ]
   {\Gamma_1 \jtype{n_1}{}{t}{\tau_1 \times \tau_2 } \\ \Gamma_2, x_1: \tau_1, x_2 : \tau_2 \jtype{n_2}{}{t'}{\tau'}}
   { \max(\Gamma_1, \Gamma_2)  \jtype{\max(n_1,n_2)}{}{ \letx{(x_1,x_2)}{t}{t'} }{\tau'}  }
$$

\textbf{Subcase 1: x $\not \in \fcv{\Delta_2}$ }
\[
   \inferrule*[ right = let-p ]
   {\Delta_1, x: [\tau_1]_p \jtype{n_1'}{}{t}{\tau_1' \times \tau_2'}~(\star) \\ \Delta_2, x_1:\tau_1', x_2: \tau_2' \jtype{n_2'}{}{t'}{\tau'}~(\clubsuit)}
   {  \max(\Delta_1, x: [\tau_1]_p, \Delta_2) \jtype{\max(n_1',n_2')}{}{\letx{(x_1,x_2)}{t}{t'}}{\tau'}  }
\]
where $\Delta = \max(\Delta_1,\Delta_2)$, $t_2 = \letx{(x_1,x_2)}{t}{t'}$, $\tau_2 = \tau'$ and $n_2 =\max(n_1',n_2')$. \\
To show $ \max(\Gamma, \max(\Delta_1,\Delta_2) ) \jtype{\max(n_1 + p,\max(n_1',n_2') )}{}{  (\letx{(x_1,x_2)}{t}{t'})[t_1/x] }{\tau'}  $. \\
By induction hypothesis on ($\star$), we get $\max(\Gamma, \Delta_1) \jtype{\max(n_1 + p, n_1') }{}{t[t_1/x]}{\tau_1' \times \tau_2'}~(\star\star) $. \\
 $x \not \in \fcv{\Delta_2} \implies t'[t_1/x] =  t'$.\\
 It is proved by the rule \rname{LET-P} using ($\star\star$) and ($\clubsuit$).\\

\textbf{Subcase 2: x $\not \in \fcv{\Delta_1}$ }
\[
   \inferrule*[ right = let-p ]
   {\Delta_1 \jtype{n_1'}{}{t}{\tau_1' \times \tau_2'}~(\star) \\ \Delta_2, x_1:\tau_1', x_2: \tau_2' , x: [\tau_1]_p \jtype{n_2'}{}{t'}{\tau'}~(\clubsuit)}
   {  \max(\Delta_1, x: [\tau_1]_p, \Delta_2) \jtype{\max(n_1',n_2')}{}{\letx{(x_1,x_2)}{t}{t'}}{\tau'}  }
\]
where $\Delta = \max(\Delta_1,\Delta_2)$, $t_2 = \letx{(x_1,x_2)}{t}{t'}$, $\tau_2 = \tau'$ and $n_2 =\max(n_1',n_2')$. \\
To show $ \max(\Gamma, \max(\Delta_1,\Delta_2) ) \jtype{\max(n_1 + p,\max(n_1',n_2') )}{}{  (\letx{(x_1,x_2)}{t}{t'})[t_1/x] }{\tau'}  $. \\
By induction hypothesis on ($\clubsuit$), we get $\max(\Gamma, \Delta_2), x_1:\tau_1', x_2: \tau_2'  \jtype{\max(n_1 + p,n_2') }{}{t'[t_1/x]}{\tau'}~(\clubsuit\clubsuit) $. \\
 $x \not \in \fcv{\Delta_1} \implies t[t_1/x] = t $.\\
It is proved by the rule \rname{LET-P} using ($\star$) and ($\clubsuit\clubsuit$). \\

\textbf{Subcase 3 }
\[
    \inferrule*[ right = let-p ]
   {\Delta_1 , x: [\tau_1]_p \jtype{n_1'}{}{t}{\tau_1' \times \tau_2'}~(\star) \\ \Delta_2, x_1:\tau_1', x_2: \tau_2' , x: [\tau_1]_p \jtype{n_2'}{}{t'}{\tau'}~(\clubsuit)}
   {  \max(\Delta_1, x: [\tau_1]_p, \Delta_2) \jtype{\max(n_1',n_2')}{}{\letx{(x_1,x_2)}{t}{t'}}{\tau'}  }
\]
where $\Delta = \max(\Delta_1,\Delta_2)$, $t_2 = \letx{(x_1,x_2)}{t}{t'}$, $\tau_2 = \tau'$ and $n_2 =\max(n_1',n_2')$. \\
To show $ \max(\Gamma, \max(\Delta_1,\Delta_2) ) \jtype{\max(n_1 + p,\max(n_1',n_2') )}{}{  (\letx{(x_1,x_2)}{t}{t'} )[t_1/x] }{\tau'}  $. \\
By induction hypothesis on ($\star$), we get $\max(\Gamma, \Delta_1) \jtype{\max(n_1 + p, n_1') }{}{t[t_1/x]}{\tau_1' \times \tau_2'}~(\star\star) $. \\
By induction hypothesis on ($\clubsuit$), we get $\max(\Gamma, \Delta_2),x_1: \tau_1', x_2:\tau_2' \jtype{\max(n_1 + p,n_2') }{}{t'[t_1/x]}{\tau'}~(\clubsuit\clubsuit) $. \\
It is proved by the rule \rname{LET-P} using ($\star\star$) and ($\clubsuit\clubsuit$).\\

\noindent \textbf{Case} 
$$
     \inferrule*[right = pair]
   {\Gamma_1 \jtype{n_1}{}{t_1}{\tau_1} \\ \Gamma_2 \jtype{n_2}{}{t_2}{\tau_2}}
   { \max(\Gamma_1, \Gamma_2)  \jtype{\max(n_1,n_2)}{}{(t_1, t_2)}{\tau_1 \times \tau_2}  }
$$
There are three sub cases,$x$ only in $\Gamma_1$,  $x$ only in $\Gamma_2$ and $x$ appears in both $\Gamma_1$ and $\Gamma_2$. When $x$ only in $\Gamma_1$, it is proved by induction hypothesis on the first premise and then using the rule \rname{PAIR}. When $x$ only in $\Gamma_2$, it is proved by induction hypothesis on the second premise and then using the rule \rname{PAIR}. When $x$  appears in both $\Gamma_1$ and $\Gamma_2$, it is proved by induction hypothesis on both premises and then using rule \rname{PAIR}.\\

\noindent \textbf{Case} 
$$
    \inferrule*[ right = case-const ]
   {\Gamma_1 \jtype{n_1}{}{t}{b} \\ \Gamma_2 \jtype{n_2}{}{t_i}{b} }
   {\max(\Gamma_1, \Gamma_2) \jtype{\max(n_1,n_2)}{}{\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b} } {b} }
$$

There are three sub cases.\\

\textbf{Subcase 1: x $\not \in \fcv{\Delta_2}$ }
\[
   \inferrule*[ right = case-const ]
   {\Delta_1, x: [\tau_1]_p \jtype{n_1'}{}{t}{b}~(\star) \\ \Delta_2 \jtype{n_2'}{}{t_i}{b}~(\clubsuit) }
   {\max(\Delta_1, x: [\tau_1]_p, \Delta_2) \jtype{\max(n_1',n_2')}{}{\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b} } {b} }
\]
where $\Delta = \max(\Delta_1, \Delta_2)$, $t_2 =\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b}$, $\tau_2 = b$ and $n_2 = \max(n_1', n_2')$.\\ 
To show $ \max(\Gamma, \max(\Delta_1,\Delta_2) ) \jtype{\max(n_1 + p,\max(n_1',n_2') )}{}{  (\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b})[t_1/x] }{b}  $. \\
 By induction hypothesis on ($\star$), we get $\max(\Gamma, \Delta_1) \jtype{\max(n_1 + p, n_1') }{}{t[t_1/x]}{b}~(\star\star) $. \\
 $x \not \in \fcv{\Delta_2} \implies t_i[t_1/x] =  t_i$.\\
 It is proved by the rule \rname{CASE-CONST} using ($\star\star$) and ($\clubsuit$). \\

\textbf{Subcase 2: x $\not \in \fcv{\Delta_1}$ }
\[
     \inferrule*[ right = case-const ]
   {\Delta_1 \jtype{n_1'}{}{t}{b}~(\star) \\ \Delta_2, x: [\tau_1]_p \jtype{n_2'}{}{t_i}{b}~(\clubsuit) }
   {\max(\Delta_1, x: [\tau_1]_p, \Delta_2) \jtype{\max(n_1',n_2')}{}{\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b} } {b} }
\]
where $\Delta = \max(\Delta_1, \Delta_2)$, $t_2 =\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b}$, $\tau_2 = b$ and $n_2 = \max(n_1', n_2')$.\\ 
To show $ \max(\Gamma, \max(\Delta_1,\Delta_2) ) \jtype{\max(n_1 + p,\max(n_1',n_2') )}{}{  (\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b})[t_1/x] }{b}  $. \\
By induction hypothesis on ($\clubsuit$), we get $\max(\Gamma, \Delta_2) \jtype{\max(n_1 + p, n_2') }{}{t_i[t_1/x]}{b}~(\clubsuit\clubsuit) $. \\
 $x \not \in \fcv{\Delta_1} \implies t[t_1/x] = t $.\\
It is proved by the rule \rname{CASE-CONST} using ($\star$) and ($\clubsuit\clubsuit$). \\

\textbf{Subcase 3 }
\[
    \inferrule*[ right = case-const ]
   {\Delta_1, x: [\tau_1]_p \jtype{n_1'}{}{t}{b}~(\star) \\ \Delta_2, x: [\tau_1]_p \jtype{n_2'}{}{t_i}{b}~(\clubsuit) }
   {\max(\Delta_1, x: [\tau_1]_p, \Delta_2) \jtype{\max(n_1',n_2')}{}{\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b} } {b} }
\]
where $\Delta = \max(\Delta_1, \Delta_2)$, $t_2 =\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b}$, $\tau_2 = b$ and $n_2 = \max(n_1', n_2')$.\\ 
To show $ \max(\Gamma, \max(\Delta_1,\Delta_2) ) \jtype{\max(n_1 + p,\max(n_1',n_2') )}{}{  (\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b})[t_1/x] }{b}  $. \\
By induction hypothesis on ($\star$), we get $\max(\Gamma, \Delta_1) \jtype{\max(n_1 + p, n_1') }{}{t[t_1/x]}{b}~(\star\star) $. \\
By induction hypothesis on ($\clubsuit$), we get $\max(\Gamma, \Delta_2) \jtype{\max(n_1 + p, n_2') }{}{t_i[t_1/x]}{b}~(\clubsuit\clubsuit) $.. \\
It is proved by the rule \rname{CASE-CONST} using ($\star\star$) and ($\clubsuit\clubsuit$).\\



\noindent \textbf{Case} 
\[
    \inferrule*[ right = case-query]
   {\Gamma_1 \jtype{n_1'}{}{t}{b} \\ \Gamma_2 \jtype{n_2'}{}{t_i}{query} }
   {\max(\Gamma_1, \Gamma_2) \jtype{\max(n_1',n_2')}{}{\tcaseof{t}\ \{c_i \Rightarrow t_i\}_{c_i \in b} } {query} }
\]
There are three sub cases. Thre proof are quite similar as the one of $\rname{CASE-CONST}$.\\

\noindent \textbf{Case} 
\[
   \inferrule*[right = iabs]
  { 
    \inferrule*[]
    {}
    {i::\mathbb{N};\Delta,x:[\tau_1]_p \jtype{n}{}{t}{ \tau } ~(\star)}
    \and
    \inferrule*[]
    {}
    { i \notin \fiv{\Delta,x:\tau_1}  } 
  }
  { \Delta, x:[\tau_1]_p \jtype{n}{ }{  \Lambda.t  }{ \tforallN{i}{\tau}  } }
 \]
To show $\max(\Gamma, \Delta) \jtype{\max(n_1 + p,n)}{}{\Lambda.t[t_1/x] }{\tforallN{i}{\tau}} $.\\
 By induction hypothesis on ($\star$), we get : $ i :: \mathbb{N};\max(\Gamma, \Delta) \jtype{\max(n_1,n)}{}{t[t_1/x]}{\tau}(\star\star)$.\\
 There are two cases.\\
 \textbf{Sub case 1: $i \not \in \fiv{\Gamma}$}
  It is proved by using rule \rname{IABS} with $(\star\star)$.\\
  \textbf{Sub case 2: $i \in \fiv{\Gamma}$}
  We choose $j \not \in \fiv{\max(\Gamma,\Delta)}$. We rename all the $i$ to $j$ in $(\star\star)$ and use rule \rname{IABS} to get:
  $ \max(\Gamma, \Delta) \jtype{\max(n_1,n)}{}{\Lambda.t[t_1/x] }{\tforallN{j}{\tau}}$. It is just a renaming version of the goal.
 

\noindent \textbf{Case} 
\[ 
   \inferrule*[ right =  iapp]
  { 
    \inferrule*[]
    {}
    { \Delta, x:[\tau_1]_p \jtype{n}{}{t}{ \tforallN{i}{\tau}   } (\star) }
    \and
    \inferrule*[]
    {}
    { \jiterm{I}{ \mathbb{N} } } 
  }
  {\Delta, x:[\tau_1]_p \jtype{n }{ }{t\, [] }{ \tau \{ I/i \}  } }
\]
To show $ \max(\Gamma, \Delta) \jtype{\max(n_1 + p, n)}{}{t[t_1/x] \, []}{ \tau \{ I/i \} } $.\\
By ih on $(\star)$, we get: $ \max(\Gamma,\Delta)  \jtype{\max(n_1 + p, n)}{}{t}{ \tforallN{i}{\tau} } ~ (\star\star) $.\\
It is proved by the rule \rname{IAPP} with $(\star\star)$.\\

\noindent \textbf{Case} 
\[
  \inferrule*[right = sub]
  { 
   { \Delta, x:[\tau_1]_p \jtype{n}{}{t}{\tau} ~(\star) } \\
   { \Delta', x:[\tau_1]_p \subseteq \Delta,x:\tau_1 ~ (\clubsuit) }  \\
   { \vDash n \leq n' } ~(\spadesuit) \\
   { \tau \subseteq \tau' }
  }
  { \Delta',x:[\tau_1]_p \jtype{n'}{}{t}{\tau'} }
\]
To show $ \max(\Gamma, \Delta') \jtype{\max(n_1 + p, n')}{}{t}{\tau'}$.\\
By induction hypothesis on ($\star$), we get : $\max(\Gamma, \Delta) \jtype{\max(n_1 + p, n)}{}{t}{\tau} $.\\
$(\clubsuit) \implies \max(\Gamma,\Delta') \subseteq \max(\Gamma,\Delta)~(\clubsuit\clubsuit) $.\\
$ (\spadesuit) \implies  \vDash \max(n_1 + p, n) \leq \max(n_1 + p,n') $.\\
It is proved by the rule \rname{SUB}.\\


\noindent \textbf{Case}
\[
\inferrule*[right = pr]
   {[\Delta_2], x:[\tau_1]_{p - p'}\jtype{n}{}{t}{\tau}}
   {
   \Delta_1, p' + [\Delta_2], x:[\tau_1]_p\jtype{n + p'}{}{!t}{!_p' \tau}
   }
\]
TS: $\max(\Gamma,(\Delta_1, p+[\Delta_2]) ) \jtype{\max(n_1 + p, n + p')}{}{!t[t_1/x]}{!_{p'} \tau}$.\\
By induction hypothesis on premise, we get:                     .\\
By rule \rname{PR} with $(\star)$, we get: $\Delta_1, p'+[\Delta_2] \jtype{n + p'}{}{!t[t_1/x]}{!_{p'} \tau} $.
It is proved by the Lemma \ref{lem:coex} and Lemma~\ref{lem:deweaken1} from the conclusion.


\end{proof}


\end{document}




































