% \[\begin{array}{lcl}
% \max(\bot, \nnatbiA) & = & \nnatbiA \\
% \max(\nnatbiA, \bot) & = & \nnatbiA \\
% \max(\infty, \nnatbiA) & = & \infty \\
% \max(\nnatbiA, \infty) & = & \infty \\
% \\
% %
% \bot + \nnatbiA & = & \bot \\
% \nnatbiA + \bot & = & \bot \\
% \infty + \nnatbiA & = & \infty ~~~~ \mbox{if } \nnatbiA \neq \bot \\
% \nnatbiA + \infty & = & \infty ~~~~ \mbox{if } \nnatbiA \neq \bot \\
% \\
% %
% \bot \leq \nnatbiA \\
% \nnatbiA \leq \infty
% \end{array}
% \]

% \[\begin{array}{llll}
% \mbox{Expr.} & \expr & ::= & x ~|~ \expr_1 \eapp \expr_2 ~|~ \efix f(x).\expr
%  ~|~ (\expr_1, \expr_2) ~|~ \eprojl(\expr) ~|~ \eprojr(\expr) ~| \\
% %
% & & & \etrue ~|~ \efalse ~|~ \eif(\expr_1, \expr_2, \expr_3) ~|~
% \econst ~|~ \eop(\expr)  ~|~  {\eilam \expr ~|~ \expr \eapp [] } \\
% & & & ~|~  {\elet  x:q = \expr_1 \ein \expr_2 } ~|~ \enil ~|~  \econs (
%       \expr_1, \expr_2) \\
% & & & ~|~ { ~~~~~~~
%  \bernoulli \eapp \expr ~|~ \uniform \eapp \expr_1 \eapp
%       \expr_2 } \\
% & & & ~|~  \wq{ \evec({\attr_i \to \expr_i'}^{ i \in 1\dots n})    } \\\
% %
% \mbox{Value} & \valr & ::= & \etrue ~|~ \efalse ~|~ \econst ~|~
% (\efix f(x:\type).\expr, \env) ~|~ (\valr_1, \valr_2) 
%     ~|~ \enil ~|~ \econs (\valr_1, \valr_2) | \\
% & & & {(\eilam \expr , \env) } ~|~ \wq{ \evec 
% ({\attr_i \to \valr_i'}^{ i \in 1\dots n} )  } \\
% %
% \mbox{Environment} & \env & ::= & x_1 \mapsto \valr_1, \ldots, x_n \mapsto \valr_n
% \end{array}\]


% \[\begin{array}{llll}
% \mbox{Trace} & \tr & ::= &  {(x, \env)} ~|~ \trapp{\tr_1}{\tr_2}{f}{x}{\tr_3} ~|~
% { (\trfix f(x:\type).e, \env) } ~|~ (\tr_1, \tr_2) ~|~ \trprojl(\tr) ~|\\ 
% %
% & & & \trprojr(\tr) ~|~ \trtrue ~|~ \trfalse ~|~ \trift(\tr_b, \tr_t)
% ~|~ \triff(\tr_b, \tr_f) ~|~ \trconst ~|~ \trop(\tr) \\
% %
% & & & \trnil ~|~ \trcons (\tr_1, \tr_2) ~|~ \triapp{\tr_1}{\tr_2} ~|~
%        {(\eilam \expr, \env)} \\
% & & & ~|~  \wq { \evec({\tr_i} ^{i \in 1\dots n}) } \\
% \end{array}\]



% \begin{figure}
% \begin{mathpar}
%    { \inferrule{ }{\env, x \bigstep \env(x), (x, \env ) }  }
%   %
%   \and
%   %
%   \inferrule{ }{\env, \econst \bigstep \econst, \trconst}
%   %
%   \and
%   %
%   \inferrule{ }{\env, \etrue \bigstep \etrue, \trtrue}
%   %
%   \and
%   %
%   \inferrule{ }{\env, \efalse \bigstep \efalse, \trfalse}
%   %
%   \and
%   { \inferrule{  \env, \expr \bigstep \econst, \tr }{\env, \bernoulli \eapp \expr \bigstep \econst,
%       \bernoulli (\tr)
%     } }
%   \and
%  \inferrule{ \env, \expr_1 \bigstep \econst, \tr_1 \\ \env, \expr_2 \bigstep \econst, \tr_2  }{\env, \uniform \eapp \expr_1 \eapp
%       \expr_2\bigstep \econst, \uniform(\tr_1,\tr_2)  } 
%   \and
%   %
%   { \inferrule{
%   }{
%     \env, \efix f(x:\type). \expr \bigstep (\efix f(:\type).\expr, \env),
%     (\trfix f(x:\type).\expr, \env)
%   }
% }
%   %
%   \and
%   %
%   \inferrule{
%     \env, \expr_1 \bigstep \valr_1, \tr_1 \\
%     { \valr_1 = (\efix f(x:\type).\expr, \env')} \\\\
%     \env, \expr_2 \bigstep \valr_2, \tr_2 \\
%     \env'[f \mapsto \valr_1, x \mapsto \valr_2], \expr \bigstep \valr, \tr
%   }{
%     \env, \expr_1 \eapp \expr_2 \bigstep \valr, \trapp{\tr_1}{\tr_2}{f}{x}{\tr}
%   }
%   %
%   \and
%   %
%   \inferrule{
%     \env, \expr_1 \bigstep \valr_1, \tr_1 \\
%     \env, \expr_2 \bigstep \valr_2, \tr_2
%   }{
%     \env, (\expr_1, \expr_2) \bigstep (\valr_1, \valr_2), (\tr_1, \tr_2)
%   }
%   %
%   \and
%   %
%   \inferrule{
%     \env, \expr \bigstep (\valr_1, \valr_2), \tr
%   }{
%     \env, \eprojl(\expr) \bigstep \valr_1, \trprojl(\tr)
%   }
%   %
%   \and
%   %
%   \inferrule{
%     \env, \expr \bigstep (\valr_1, \valr_2), \tr
%   }{
%     \env, \eprojr(\expr) \bigstep \valr_2, \trprojr(\tr)
%   }
%   %
%   \and
%   %
%   \inferrule{
%     \env, \expr \bigstep \etrue, \tr \\
%     \env, \expr_1 \bigstep \valr, \tr_1
%   }{
%     \env, \eif(\expr, \expr_1, \expr_2) \bigstep \valr, \trift(\tr, \tr_1)
%   }
%   %
%   \and
%   %
%   \inferrule{
%     \env, \expr \bigstep \efalse, \tr \\
%     \env, \expr_2 \bigstep \valr, \tr_2
%   }{
%     \env, \eif(\expr, \expr_1, \expr_2) \bigstep \valr, \triff(\tr, \tr_2)
%   }
%   %
%   \and
%   %
%   \inferrule{
%     \env, \expr \bigstep \valr, \tr \\
%     \eop{}(\valr) = \valr'
%   }{
%     \env, \eop(\expr) \bigstep \valr', \trop(\tr)
%   }
% %
% \and
% %
%   \inferrule{
% }
% { \env, \enil \bigstep \enil, \trnil }
% %
% \and
% %
% \inferrule{
% \env, \expr_1 \bigstep \valr_1, \tr_1 \\
% \env, \expr_2 \bigstep \valr_2, \tr_2
% }
% { \env, \econs (\expr_1, \expr_2)  \bigstep \econs (\valr_1, \valr_2),
%   \trcons(\tr_1, \tr_2)
% }
% %
% \and
% %
% \inferrule{
%   \env, \expr_1 \bigstep \valr_1, \tr_1 \\
%   \env[x \mapsto \valr_1] , \expr_2 \bigstep \valr, \tr_2
% }
% {\env, \elet x;q = \expr_1 \ein \expr_2 \bigstep \valr, \trlet (x,
%   \tr_1, \tr_2) }
% %
% \\\\
% %
% \inferrule
% {
%   \empty
% }
% {
%   \env, \eilam \expr \bigstep (\eilam \expr, \env), (\eilam \expr , \env)
% }
% %
% \and
% %
% \inferrule{
%   \env, \expr \bigstep (\eilam \expr', \env'), \tr_1 \\
%   \env, \expr' \bigstep \valr, \tr_2
% }
% {
%   \env, \expr [] \bigstep \valr, \triapp{\tr_1}{\tr_2} }
%   \and
% \wq 
% {
%   \inferrule
%   {
%      \env, {\expr_i'}^{i \in 1\dots n} \bigstep {\valr_i'}^{i \in 1\dots n}, {\tr_i'}^{ i \in 1\dots n}
%   }
%   {
%       \env, \evec 
%       (\attr_i \to {\expr_i'}^{i \in 1\dots n}) \bigstep \evec 
%       (\attr_i \to {\valr_i'}^{i \in 1\dots n}), \evec 
%       ({\tr_i'}^{i \in 1\dots n}) 
%   }
% }

% \end{mathpar}
%   \caption{Big-step semantics with provenance, vector}
%   \label{fig:big-step-vector}
% \end{figure}


% \begin{figure}
%   \framebox{$\adap: \mbox{Traces} \to \nat$}
%   \begin{mathpar}
%     \begin{array}{lcl}
%       \wq { \adap( (x,\env) )} & = & 0 \\
%       %
%       \adap(\trapp{\tr_1}{\tr_2}{f}{x}{\tr_3}) & = &
%       \adap(\tr_1) + \max (\adap(\tr_3), \adap(\tr_2) + \ddep{x}(\tr_3))\\
%       %
%       \wq {\adap( (\trfix f(x:\type).\expr, \env)  ) } & = & 0 \\
%       %
%       \adap((\tr_1, \tr_2)) & = & \max(\adap(\tr_1), \adap(\tr_2)) \\
%       %
%       \adap(\trprojl(\tr)) & = & \adap(\tr) \\
%       %
%       \adap(\trprojr(\tr)) & = & \adap(\tr) \\
%       %
%       \adap(\trtrue) & = & 0 \\
%       %
%       \adap(\trfalse) & = & 0 \\
%       %
%       \adap(\trift(\tr_b, \tr_t)) & = & \adap(\tr_b) + \adap(\tr_t) \\
%       %
%       \adap(\triff(\tr_b, \tr_f)) & = & \adap(\tr_b) + \adap(\tr_f) \\
%       %
%       \adap(\trconst) & = & 0 \\
%       %
%       \adap(\trop(\tr)) & = &\wq { 1 + \adap(\tr) } \\
%       %
%      \adap(\trnil) & = & 0 \\
%      %
%      \adap(\trcons(\tr_1,\tr_2) ) & = &  \max(\adap(\tr_1),
%                                         \adap(\tr_2)) \\
%      %
%     \adap( \trlet (x, \tr_1,\tr_2) ) & = & \max (\adap(\tr_2),
%                                            \adap(\tr_1)+\ddep{x}(\tr_2)  )
%                                            \\
%      \adap(\triapp{\tr_1}{\tr_2}) & = & \adap(\tr_1) + \adap(\tr_2)\\
%     %
%      { \adap( (\eilam \expr, \env) ) } & = & 0 \\
%      { \adap( \bernoulli (\tr)  ) } & = & \adap(\tr) \\
%       { \adap( \uniform  (\tr_1, \tr_2)  ) } & = & \max (\adap(\tr_1),
%                                                       \adap(\tr_2) ) \\
%      \wq { \adap( \evec 
%      ({\tr_i}^{i \in 1\dots n}  )  ) } & = & \max (\adap{(\tr_i)}^{i \in 1\dots n} ) 
%       \end{array}
%   \end{mathpar}
%   %
%   \framebox{$\ddep{x}: \mbox{Traces} \to \natb$}
%   \begin{mathpar}
%     \begin{array}{lcl}
%       { \ddep{x}( ( y, \env )) } & = &
%       \left\lbrace
%       \begin{array}{ll}
%         0 & \mbox{if } x = y \\
%         \bot & \mbox{if } x \neq y
%       \end{array}
%       \right.\\
%       %
%       \ddep{x}(\trapp{\tr_1}{\tr_2}{f}{y}{\tr_3}) & = & \max(\ddep{x}(\tr_1), \\
%       & & \adap(\tr_1) + \max(\ddep{x}(\tr_3), \ddep{x}(\tr_2) + \ddep{y}(\tr_3))) \\
%       %
%       { \ddep{x}(  (\trfix f(y:\type).\expr,\env)  )  }& = & \bot \\
%       %
%       \ddep{x}((\tr_1, \tr_2)) & = & \max(\ddep{x}(\tr_1), \ddep{x}(\tr_2)) \\
%       %
%       \ddep{x}(\trprojl(\tr)) & = & \ddep{x}(\tr) \\
%       %
%       \ddep{x}(\trprojr(\tr)) & = & \ddep{x}(\tr) \\
%       %
%       \ddep{x}(\trtrue) & = & \bot \\
%       %
%       \ddep{x}(\trfalse) & = & \bot \\
%       %
%       \ddep{x}(\trift(\tr_b, \tr_t)) & = & \max(\ddep{x}(\tr_b), \adap(\tr_b) + \ddep{x}(\tr_t)) \\
%       %
%       \ddep{x}(\trift(\tr_b, \tr_f)) & = & \max(\ddep{x}(\tr_b), \adap(\tr_b) + \ddep{x}(\tr_f)) \\
%       %
%       \ddep{x}(\trconst) & = & \bot \\
%       %
%       \ddep{x}(\trop(\tr)) & = & 1 +  \ddep{x}(\tr)  \\  
%        %
%       \ddep{x}(\trnil) & = & \bot \\
%       %
%       \ddep{x}(\trcons(\tr_1,\tr_2) ) & = & \max(\ddep{x}(\tr_1),
%                                             \ddep{x}(\tr_2)) \\
%       %
%       \ddep{x}( \trlet(y, \tr_1, \tr_2) ) & = & \max( \ddep{x}(\tr_2),
%                                                 \ddep{x}(\tr_1)+\ddep{y}(\tr_2)  )\\
%        \ddep{x}(\triapp{\tr_1}{\tr_2})  & = & 
%                                                     \max(\ddep{x}(\tr_1), \adap(\tr_1) + \ddep{x}(\tr_2))\\
%     %
%      { \ddep{x}( (\eilam \expr, \env) ) } & = & \bot \\
%     \ddep{x}(\uniform (\tr_1,\tr_2) ) & = & \max(\ddep{x}(\tr_1),
%                                             \ddep{x}(\tr_2)) \\
%   \ddep{x}(\bernoulli (\tr)) & = & \ddep{x}(\tr)\\
%   %
%   \ddep{x}(\evec({\tr_i}^{i \in 1 ... n})) & = & \max{(\ddep{x}(\tr_i))}
%     \end{array}
%   \end{mathpar}
%   \caption{Adaptivity of a trace and depth of variable $x$ in a trace}
%   \label{fig:adap}
% \end{figure}


%%%%%%EXAMPLES---TWO ROUNDS%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\begin{algorithm}
\caption{A two-round analyst strategy for random data (Algorithm 4 in ...)}
\label{alg:BitGOF}
\begin{algorithmic}
\REQUIRE Mechanism $\mathcal{M}$ with a hidden state $X\in \{-1,+1\}^{n\times (k+1)}$.
\STATE  {\bf for}\ $j\in [k]$\ {\bf do}.  
\STATE \qquad {\bf define} $q_j(x)=x(j)\cdot x(k)$ where $x\in \{-1,+1\}^{k+1}$.
\STATE \qquad {\bf let} $a_j=\mathcal{M}(q_j)$ 
\STATE \qquad \COMMENT{In the line above, $\mathcal{M}$ computes approx. the exp. value  of $q_j$ over $X$. So, $a_j\in [-1,+1]$.}
\STATE {\bf define} $q_{k+1}(x)=\mathrm{sign}\big (\sum_{i\in [k]} x(i)\times\ln\frac{1+a_i}{1-a_i} \big )$ where $x\in \{-1,+1\}^{k+1}$.
\STATE\COMMENT{In the line above,  $\mathrm{sign}(y)=\left \{ \begin{array}{lr} +1 & \mathrm{if}\ y\geq 0\\ -1 &\mathrm{otherwise} \end{array} \right . $.}
\STATE {\bf let} $a_{k+1}=\mathcal{M}(q_{k+1})$
\STATE\COMMENT{In the line above,  $\mathcal{M}$ computes approx. the exp. value  of $q_{k+1}$ over $X$. So, $a_{k+1}\in [-1,+1]$.}
\RETURN $a_{k+1}$.
\ENSURE $a_{k+1}\in [-1,+1]$
\end{algorithmic}
\end{algorithm}


\begin{figure}
\small
Two-rounds:



\[
\begin{array}{l}
  \elet \eapp  g: \bot = 
  \efix \eapp f(j: \tint). \lambda k: \tint.\\
  \hspace{.2cm}  \eif \big (  (j < k)  ,  \\
  \hspace{.8cm}  \elet \eapp  a: 0 = 
                 \eop \eapp  
             \Big(\evec 
             \big({\attr_i \to (\eget \eapp \attr_i \eapp j) * (\eget \eapp \attr_i \eapp  k)}^{i \in 1\dots 2^k} 
             \big) 
             \Big) 
                  \eapp \ein \\
  \hspace{1.2cm} (a, j) :: (f  \eapp (j+1) \eapp  k) \\
  \hspace{1.2cm} ,\eapp  [] \big) \eapp \ein\\
  \hspace{.2cm}  \efix \eapp \mathsf{twoRound}(k : \tint). 
                 \\
  \hspace{.8cm}  \elet \eapp  l: 1 = g \eapp  0 \eapp  k  \eapp  \ein \\
  \hspace{.8cm}  \elet \eapp  q: 1 = \evec 
  \Big(\attr_i \to
                    \mathsf{sign} \eapp \\ 
  \hspace{.8cm}  (\mathsf{foldl} \eapp  (\lambda acc: \treal. 
                 \lambda ai: \treal \cdot \tint. 
                 \big(acc\eapp + (\eget \eapp \attr_i \eapp  (\eprojr \eapp ai)) 
                 \cdot \mathsf{log}(\frac{1+ (\eprojl \eapp ai) }{1- (\eprojl \eapp ai)}) 
                 \big)
                 \eapp  0.0 \eapp  l )^{i \in 1\dots 2^k} \Big) \eapp  \ein \\
  \hspace{.8cm}  \eop ( q )
\end{array}
\]
\end{figure}

%%%%%%EXAMPLES--- MULTI ROUNDS%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\clearpage
\begin{algorithm}
\footnotesize
\caption{A multi-round analyst strategy for random data (Algorithm 5 in ...)}
\label{alg:multiRound}
\begin{algorithmic}
\REQUIRE Mechanism $\mathcal{M}$ with a hidden state $X_0 \in [N]^{n}$ sampled u.a.r., control set size $c$
\STATE Define control dataset $C = \{0,1, \cdots, c - 1\}$
\STATE Initialize $Nscore(i) = 0$ for $i \in [N]$, $I = \emptyset$ and $Cscore(C(i)) = 0$ for $i \in [c]$
\STATE  {\bf for}\ $j\in [k]$\ {\bf do} 
\STATE \qquad {\bf let} $p=\uniform(0,1)$ 
\STATE \qquad {\bf define} $q (x) = \bernoulli ( p )$ .
\STATE \qquad {\bf define} $qc (x) = \bernoulli ( p )$ .
\STATE \qquad {\bf define} $qj(x) = \mathsf{restrict}(q, X_j)$
\STATE \qquad {\bf let} $a = \mathcal{M}(qj)$ 
\STATE \qquad {\bf for}\ $i \in [N]$\ {\bf do}
\STATE \qquad \qquad $Nscore(i) = Nscore(i) + (a - p)*(q (i) - p)$ if $i \notin I$
\STATE \qquad {\bf for}\ $i \in [c]$\ {\bf do}
\STATE \qquad \qquad $Cscore(C(i)) = Cscore(C(i)) + (a - p)*(qc (i) - p)$
\STATE \qquad {\bf let} $I = \{i | i\in [N] \land Nscore(i) > \max(Cscore)\}$
\STATE \qquad {\bf let} $X_j = X_{j - 1} \setminus I$ 
\RETURN $X_j$.
% \ENSURE 
\end{algorithmic}
\end{algorithm}



\begin{figure}
\small
\[
\begin{array}{l}
\elet \mathsf{updtSC} =\\
                 \efix \eapp  \mathsf{f}(z: \tunit). \lambda sc: \tlist{\treal}. 
                 \lambda a: \treal. \lambda p: \treal. \lambda q.\\
                 \lambda I: \tlist{\tint}. \lambda i: \tint. \lambda n: \tint. \\
 \hspace{.2cm}   \eif \Big ( (i < n)  ,  \\
 \hspace{0.4cm}  \eif \big( ( \mathsf{in} \eapp i \eapp I  ) ,       \\
 \hspace{0.8cm}  \elet \eapp x: 0 =( \ddep \eapp sc \eapp i) 
                 + (a-p)*(q \{ i\} - p)  \ein \\
 \hspace{0.8cm}  \elet \eapp sc': 0 =  \mathsf{updt} \eapp sc \eapp i
                 \eapp x \ein \\
 \hspace{1.2cm}  \mathsf{f}  \eapp () \eapp sc' \eapp a \eapp p
                 \eapp q \eapp I \eapp  \eapp (i+1) \eapp n  \\ 
 \hspace{0.4cm}  , \mathsf{f}  \eapp () \eapp sc \eapp a \eapp p
                 \eapp q \eapp I \eapp  \eapp (i+1) \eapp n \big )  \\ 
 \hspace{0.2cm}  , sc  \Big ) \eapp \ein
\end{array}
\]
%
%
\[
\begin{array}{l}
\elet \mathsf{updtSCC} = \\
                \efix \eapp  \mathsf{f}(z: \tunit). \lambda scc: \tlist{\treal}. \lambda a: \treal. 
                \lambda p: \treal. \lambda qc\\ 
                \lambda i: \tint. \lambda cr: \tint. \\
 \hspace{.2cm}  \eif \Big ( (i < cr) ,  \\
 \hspace{0.8cm} \elet \eapp x: 0 =( \mathsf{nth} \eapp scc \eapp i) 
                + (a-p)*(qc \{ i\} - p)  \ein \\
 \hspace{0.8cm} \elet \eapp scc': 0 =  \mathsf{updt} \eapp scc \eapp i
                \eapp x \ein \\
 \hspace{1.2cm} \mathsf{f}  \eapp () \eapp scc' \eapp a \eapp p \eapp qc
                \eapp (i+1) \eapp  cr  \\ 
 \hspace{0.2cm} , scc  \Big ) \eapp \ein
\end{array}
\]
%
%
\[
\begin{array}{l}
\elet \mathsf{updtI} = \\
                 \efix \eapp  \mathsf{f}(z : \tunit). \lambda maxScc: \treal. 
                 \lambda sc: \tlist{\treal}. \lambda i: \tint. \lambda n: \tint. \\
 \hspace{.2cm}   \eif \Big (   (i < n)  ,  \\
 \hspace{0.4cm}  \eif \big( ( ( \mathsf{nth} \eapp scc \eapp i)  >  maxScc  ) ,       \\
 \hspace{0.8cm}  i :: ( \mathsf{f}  \eapp () \eapp maxScc \eapp sc
                 \eapp (i+1) \eapp n  )\\
 \hspace{0.8cm}  \mathsf{f}  \eapp () \eapp maxScc \eapp sc
                 \eapp (i+1) \eapp n  \big )  \\
 \hspace{0.2cm}  , [] \Big ) \eapp \ein
\end{array}
\]
%
%
\[
\begin{array}{l}
 \efix \eapp  \mathsf{multiRound}(z : \tunit). \Lambda k. \Lambda j. 
        \lambda k: \tint[k]. \lambda j: \tint[j]. \lambda sc: \tlist{\treal}.\\
        \lambda scc: \tlist{\treal}. \lambda il: \tlist{\tint}. \lambda n: \tint.
        \lambda cr: \tint. \lambda d: \tlist{\tint}.\\
 \hspace{.2cm}  \eif   \big (   (j < k)  ,  \\
 \hspace{.2cm}  \elet \eapp p: k - j = \uniform \eapp 0 \eapp 1 \ein \\
 \hspace{0.4cm} \elet \eapp q: k - j = 
   \evec 
   (\attr_i \to \bernoulli \eapp p^{i \in 1\dots n}) \ein \\
 \hspace{0.4cm} \elet \eapp qc: k - j = \evec 
 (\attr_i \to \bernoulli \eapp p^{i \in 1\dots n}) \ein \\
 \hspace{0.4cm} \elet \eapp qj : k - j = \evec 
 ( \attr_i \to if( (\mathsf{in}\eapp e_i \eapp d) \, , \, q\{e_i\} \,, \mathsf{else}\eapp 0)^{i \in 1\dots n} )\\
 \hspace{0.4cm} \elet \eapp a: k - j - 1 = \eop (q_j)  \ein \\
 \hspace{0.8cm} \elet \eapp sc': k - j - 1 =  \mathsf{updtSC} \eapp () \eapp sc  \eapp a \eapp p
                \eapp qj \eapp il \eapp  \eapp 0 \eapp  n \eapp  \ein \\
 \hspace{0.8cm} \elet \eapp scc': k - j - 1 =  \mathsf{updtSCC} \eapp () \eapp scc \eapp a \eapp p
                \eapp qc \eapp  \eapp 0 \eapp  cr \ein \\
 \hspace{0.8cm} \elet \eapp maxScc: k - j - 1 =  \mathsf{foldl} \eapp 
                (\lambda acc : \treal. \lambda a: \treal. 
                \eif ( acc < a, a, acc)) \eapp 0 \eapp scc' \ein \\
 \hspace{0.8cm} \elet \eapp il': k - j - 1 =  \mathsf{updtI}  \eapp () \eapp maxScc \eapp sc
                \eapp 0 \eapp n  \ein \\
 \hspace{0.8cm} \elet \eapp d': k - j - 1 =  d \setminus il' \ein \\
 \hspace{1.2cm} a :: (\mathsf{multiRound} \eapp () \eapp [k] \eapp [j + 1]  
                 \eapp k \eapp (j+1) \eapp sc' \eapp scc' \eapp il'
                 \eapp n \eapp cr \eapp d')\\ 
 \hspace{0.2cm} , []  \big)
\end{array}
\]

\end{figure}

% \clearpage
% \[
% \begin{array}{llll}
% \mbox{Index Term} & \idx, \nnatA & ::= &     i ~|~ n ~|~ \idx_1 + \idx_2 ~|~  \idx_1
%                                  - \idx_2 ~|~ \smax{\idx_1}{\idx_2}\\
%   \mbox{Sort} & S & ::= & \nat \\
%   \mbox{Type} & \type & ::= & \tbase ~|~ \tbool ~|~ \type_1 \times
%   \type_2 ~|~ \tarr{\type_1}{\type_2}{\nnatbiA}{}{\nnatA} ~|~
%                               \tlist{\type} ~|~ \tbox{\type} ~|~ \\
%     & & & {   \treal ~|~ \tint ~|~   \tint[I]  ~|~
%           \tforall{}{\nnatA}{i} \type  } ~|~ \mathsf{VC}(\type_i
%           \to {\type_i'}^{ \, i \in 1,2,\dots n} ) 
% \end{array}
% \]


% \begin{figure}
%   \begin{mathpar}
%     \inferrule{
%       \Gamma(x) = \type \\
%       \dmap(x) \geq 0
%     }{
%       \Delta; \Gamma;\dmap \tvdash{0} x: \type
%     }~\textbf{var}
%     %
%     \and
%     %
%     \inferrule{
%       \Delta; \Gamma ;\dmap_1  \tvdash{\nnatA_1} \expr_1: \wq{\tarr{\type_1}{\type_2}{}{\nnatbiA}{\nnatA}} \\
%       \Delta; \Gamma ; \dmap_2 \tvdash{\nnatA_2} \expr_2: \type_1 \\\\
%       \nnatA' = \nnatA_1 + \max(\nnatA, \nnatA_2 + \nnatbiA) \\
%       \wq{ \dmap' = \max( \dmap_1, \nnatA_1 + \dmap_2 ) }
%     }{
%       \Delta; \Gamma; \dmap' \tvdash{\nnatA'} \expr_1 \eapp \expr_2 : \type_2
%     }~\textbf{app}
%     %
%     \and
%     %
%     \inferrule{
%       \Delta; \Gamma, f: (\tarr{\type_1}{\type_2}{}{\nnatbiA
%       }{\nnatA}), x: \type_1    ; \dmap, [x: \nnatbiA]
%       \tvdash{\nnatA}
%       \expr: \type_2
%     }{
%       \Delta; \Gamma; \wq{ \dmap } \tvdash{0} \efix f(x).\expr:
%       \tarr{\type_1}{( { \type_2} ) }{}{\nnatbiA}{\nnatA}
%     }~\textbf{fix}
%     %
%     \and
%     %
%     \inferrule{
%       \Delta; \Gamma ; \dmap_1 \tvdash{\nnatA_1} \expr_1: \type_1 \\
%       \Delta; \Gamma; \dmap_2  \tvdash{\nnatA_2} \expr_2: \type_2 \\\\
%       \nnatA' = \max(\nnatA_1,\nnatA_2) \\
% \dmap' = \max(\dmap_1, \dmap_2)
%     }{
%       \Delta; \Gamma; \dmap' \tvdash{\nnatA'} (\expr_1, \expr_2): \type_1 \times \type_2
%     }~\textbf{pair}
%     %
%     \and
%     %
%     \inferrule{
%       \Delta; \Gamma ; \dmap \tvdash{\nnatA} \expr: \type_1 \times \type_2
%     }{
%       \Delta; \Gamma ; \dmap \tvdash{\nnatA} \eprojl(\expr): \type_1
%     }~\textbf{fst}
%     %
%     \and
%     %
%     \inferrule{
%       \Delta; \Gamma;\dmap \tvdash{\nnatA} \expr: \type_1 \times \type_2
%     }{
%       \Delta; \Gamma; \dmap \tvdash{\nnatA} \eprojr(\expr): \type_2
%     }~\textbf{snd}
%     %
%     \and
%     %
%     \inferrule{
%     }{
%       \Delta; \Gamma;\dmap \tvdash{\nnatA} \etrue: \tbool
%     }~\textbf{true}
%     %
%     \and
%     %
%     \inferrule{
%     }{
%        \Delta; \Gamma;\dmap \tvdash{\nnatA} \efalse: \tbool
%     }~\textbf{false}
%     %
%     \and
%       \inferrule{
%         \Delta; \Gamma; \dmap' \tvdash{\nnatA'} \expr: \type'
%         \\
%         \nnatA' < \nnatA
%         \\
% \dmap' < \dmap
% \\
%         \Delta \models \sub{\type' }{ \type  } 
%     }{
%        \Delta; \Gamma; \dmap \tvdash{\nnatA} \expr: \type
%     }~\textbf{subtype}
%     %
%     \and
%      \inferrule{
%       \Delta; \Gamma ; \dmap \tvdash{\nnatA} \expr : \treal
%     }{
%        \Delta; \Gamma; \dmap \tvdash{\nnatA} \bernoulli \eapp \expr: \treal
%     }~\textbf{bernoulli}
%     %
%      \and
%      \inferrule{
%       \Delta; \Gamma ; \dmap_1 \tvdash{\nnatA_1} \expr_1 : \treal
%       \\
%       \Delta ; \Gamma; \dmap_2  \tvdash{\nnatA_2} \expr_2 : \treal
%       \\
%       \nnatA = \max(\nnatA_1, \nnatA_2)\\
%       \dmap' = \max( \dmap_1, \dmap_2  )
%     }{
%        \Delta; \Gamma; \dmap' \tvdash{\nnatA'} \uniform \eapp \expr_1 \eapp \expr_2: \treal
%     }~\textbf{uniform}
    
%   \end{mathpar}
%   \caption{Typing rules, part 1}
%   \label{fig:type-rules}
% \end{figure}


% \begin{figure}
% \begin{mathpar}
%     %
%     \inferrule{
%        \Delta;\Gamma ; \dmap_1 \tvdash{\nnatA_1} \expr_1: \tbool \\
%        \Delta;\Gamma ; \dmap \tvdash{\nnatA} \expr_2: \type \\
%        \Delta;\Gamma ;  \dmap \tvdash{\nnatA} \expr_3: \type \\\\
%       \nnatA' = \nnatA_1 + \nnatA \\
%       \dmap' = \max(\dmap_1, \nnatA_1 + \dmap)
%     }{
%        \Delta;\Gamma ; \dmap' \tvdash{\nnatA'} \eif(\expr_1, \expr_2, \expr_3):  \type
%     }~\textbf{if}
%     %
%     \and
%     %
%     \inferrule{
%     }{
%        \Delta;\Gamma ; \dmap \tvdash{\nnatA} \econst: \tbase
%     }~\textbf{const}
%     \and
%     %
%     \inferrule{
%     }{
%        \Delta;\Gamma ; \dmap \tvdash{\nnatA} n: \tint[n]
%     }~\textbf{intI} 
%     \and
%     %
%     \inferrule{
%     }{
%        \Delta;\Gamma ;\dmap \tvdash{\nnatA} n: \tint
%     }~\textbf{int} 
%    \and
%     %
%     \inferrule{
%       \Delta \wf{\type} \\
%     }{
%       \Delta; \Gamma; \dmap \tvdash{\nnatA} \enil: \tlist{\type}
%     }~\textbf{nil}
%     % 
%  	\and
%     %
%     \inferrule
%     {
%       \Delta; \Gamma ; \dmap \tvdash{\nnatA} \expr:  \mathsf{DICT}(\type_i \to
%       {\type_i'}^{\, i \in 1,2\dots n} ) \\
%       \nnatA' = 1 + \nnatA 
%     }
%     {
%        \Delta; \Gamma; \dmap \tvdash{\nnatA'} \eop(\expr): \treal
%     }~\textbf{$\delta$}
%
  % \and
% %
%      {
%      \inferrule
%      {
%         \Delta; \Gamma; \dmap \tvdash{\nnatA} \expr: \type 
%            \\
%         \forall x \in \dom(\Gamma), \sub{\Gamma(x)}{  \tbox{\Gamma(x)}
%          }
%            \\
%         \delta \not\in \expr
%         \\
%         \dom(\Gamma') = \dom(\dmap')
%     }
%     {
%         \Delta; \Gamma, \Gamma'; \dmap, \boxed{\dmap'} \tvdash{\nnatA} \expr: \tbox{\type}
%     } ~\textbf{box}
%     }
    %
  %   \and
%     %
%    \inferrule{
%    \Delta; \Gamma; \dmap_1 \tvdash{\nnatA_1} \expr_1 : \type \\
%    \Delta; \Gamma; \dmap_2 \tvdash{\nnatA_2} \expr_2 : \tlist{\type}\\
%    \nnatA' = \max ( \nnatA_1, \nnatA_2 ) \\
%   \dmap' = \max( \dmap_1, \dmap_2 )
%    }
%    { 
%    \Delta; \Gamma; \dmap' \tvdash{\nnatA'} \econs(\expr_1, \expr_2) :
%      \tlist{\type}  } ~\textbf{cons}
%    %
%    \and
%    %
%    \inferrule{
%      \Delta; \Gamma; \dmap_1 \tvdash{\nnatA_1} \expr_1 : \type_1 \\
%      \Delta; \Gamma, x:\type_1 ; \dmap_2  \tvdash{\nnatA_2} \expr_2 :
%      \type \\
%      \nnatA' = \max ( \nnatA_2, \nnatA_1 + q ) \\
%    \dmap' = \max( \dmap_2, \dmap_1 + q  )
%    }
%    {  \Delta; \Gamma \tvdash{\nnatA'}  \elet x;q = \expr_1 \ein \expr_2 : \type}~\textbf{let}
%    %
%    \and
%    %
%   \inferrule{
%       i,\Delta; \Gamma ; \dmap  \tvdash{\nnatA} \expr: \type
%       \\
%       i \not\in  \fiv{\Gamma}
%     }{
%      \Delta;  \Gamma ; \dmap \tvdash{\nnatA'}    \eilam \expr    :  \tforall{}{\nnatA}{i} \type 
%     }~\textbf{ilam}
%     %
%     \and
%     %
%   \inferrule{
%         \Delta; \Gamma ; \dmap \tvdash{\nnatA} \expr: \tforall{}{\nnatA_1}{i} \type 
%       \and
%        \Delta \tvdash{}  I ::  S
%        \\
%        \nnatA' = \nnatA_1[I/i] + \nnatA
%     }{
%      \Delta;  \Gamma ; \dmap \tvdash{\nnatA'}    \expr \eapp []   :
%      \type[I/i]
%     }
% 	 ~\textbf{iapp}         
% %
% \and
% %
%  \inferrule{
%  \Delta; \Gamma; \dmap  \tvdash{\nnatA_i'} \expr_i': \type_i' 
%        \\
%        \nnatA' =\max({\nnatA_i'}^{\, 1,2\dots n})
%     }{
%      \Delta;  \Gamma ; \dmap \tvdash{\nnatA'}   \evec(\attr_i \to
%      {\expr_i'}^{\, i \in 1,2\dots n})  : \mathsf{DICT}(\type_i \to
%      {\type_i'}^{\, i \in 1,2\dots n} )
%     }
% 	 ~\textbf{dict}         


% \end{mathpar}

% %    \framebox{
% %   \begin{mathpar}
% %     \mbox{\textbf{where: }} \\
% % %    \dmapb \defeq \lambda x.\eapp  \bot \\
% %     \nnatbiA + \dmap \defeq \dmap + \nnatbiA \defeq \lambda x.\eapp  (\nnatbiA + \dmap(x)) \\
% %     \dmap_1 + \dmap_2 \defeq \lambda x.\eapp  (\dmap_1(x) + \dmap_2(x)) \\
% %     \max(\dmap_1, \dmap_2) \defeq \lambda x.\eapp  \max(\dmap_1(x), \dmap_2(x))
% %   \end{mathpar}}

%   \caption{Typing rules, part 2}
%   \label{fig:type-rules2}
% \end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%% soundness %%%%%%%%%%%%%%%

\clearpage

% \begin{figure}
%   \begin{mathpar}
%     \begin{array}{lll}
%       \lrv{\tbool} & = & \{(\stepiA, \etrue) ~|~ \stepiA \in \nat\} \cup
%       \{ (\stepiA, \efalse) ~|~ \stepiA \in \nat\} \\
%       %
%       \lrv{\tbase} & = & \{(\stepiA, \econst) ~|~ \stepiA \in \nat \conj \econst: \tbase \} \\
%       %
%       \lrv{\type_1 \times \type_2} & = & \{(\stepiA, (\valr_1, \valr_2)) ~|~ (\stepiA, \valr_1) \in \lrv{\type_1} \conj (\stepiA, \valr_2) \in \lrv{\type_2} \}\\
%       %
%       \lrv{\tarr{\type_1}{\type_2}{\nnatbiA}{\dmap}{\nnatA}} & = &
%       \{(\stepiA, (\efix f(x).\expr, \env)) ~|~ \forall \stepiB < \stepiA.\eapp  \forall (\stepiB, \valr) \in \lrv{\type_1}.\\
%       & & 
%       ~~~~~~(\stepiB, (\env[x \mapsto \valr, f \mapsto (\efix
%           f(x).\expr, \env)], \expr)) \in \lre{\dmap[x: \nnatbiA, f:
%           \infty]}{\nnatA}{\type_2}\} \\
%         %
%    \wq{   \lrv{\tarr{\type_1}{\type_2}{}{  \nnatbiA}{\nnatA}} } & = &
%       \{(\stepiA, (\efix f(x).\expr, \env)) ~|~ \forall \stepiB < \stepiA.\eapp  \forall (\stepiB, \valr) \in \lrv{\type_1}.\\
%       & & 
%       ~~~~~~( \env[x \mapsto \valr, f \mapsto (\efix
%           f(x).\expr, \env)], \expr  \bigstep \valr, \tr  )  \conj
%           |\tr| = \stepiB' \leq \stepiB\\
%     & &  \conj
%           \ddep{x}(\tr) \leq \nnatbiA \conj  \adap(\tr) \leq \nnatA
%         \conj \valr \in ( \stepiB - \stepiB',  \valr) \in
%         \lrv{\type_2} \}  \\
%       %
%      { \lrv{\tlist{\type}}  } & = & \{  (\stepiA, \enil) ~|~ \stepiA \in
%                                 \nat \} \cup \{  (\stepiA,
%                                 \econs(\valr_1,\valr_2) ) ~|~
%                                 (\stepiA, \valr_1) \in \lrv{\type}
%                                 \land (\stepiA, \valr_2) \in \lrv{\tlist{\type}} \}
%       \\
%       %
%       \\ 
%       %
%       \lre{\dmap}{\nnatA}{\type} & = & \{ (\stepiA, (\env, \expr)) ~|~ \forall \valr\eapp  \tr\eapp  \stepiB.\eapp  (\env, \expr \bigstep \valr, \tr) \conj (\size{\tr} = \stepiB) \conj (\stepiB \leq \stepiA) \\
%       & & ~~~~~~~~~~~~~~~~~~~~~~~~~\Rightarrow (\adap(\tr) \leq \nnatA \conj \\
%       & & ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\forall x \in \mbox{Vars}.\eapp  \ddep{x}(\tr) \leq \dmap(x) \conj \\
%       & & ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~((\stepiA - \stepiB,  \valr) \in \lrv{\type})
%       \}\\
%       %	
%       { \lrv{\tint}} & = & \{(\stepiA, i) ~|~ \stepiA \in \nat \conj i : \tint \}\\
%       %
%      { \lrv{\treal}} & = & \{(\stepiA, r) ~|~ \stepiA \in \nat \conj r : \treal \}\\
%       %
%      { \lrv{\tforall{\dmap}{\nnatA}{i} \type} } & = & \{(\stepiA, (\eilam \expr, \env)) ~|~ \stepiA \in \nat \conj \forall I. ~  \tvdash{} I ::S, (\stepiA, \expr) \in \lre{\dmap}{\nnatA[I/i]}{\type[I/i]} \}\\
%       %
%       { \lrv{ \tint[I] } } & = & \{(\stepiA, n) ~|~ \stepiA \in \nat \conj n = I \}\\
%   \end{array}
%   \end{mathpar}
%   \caption{Logical relation with step-indexing}
%   \label{fig:lr:step}
% \end{figure}

% \begin{thm}[Fundamental theorem]
%   If $\Delta; \Gamma; \dmap \tvdash{\nnatA} \expr: \type$ and $ \ienv \in \lrv{\Delta}$ and $(\stepiA, \env)
%   \in \lrv{\ienv \Gamma}$, then $(\stepiA, (\env, \ienv \expr)) \in
%   \lre{\dmap}{\ienv \nnatA}{\ienv \type}$.
% \end{thm}

% \begin{proof}
% By induction on the given typing derivation. For the case of
% $\efix$, we subinduct on the step index.\\
% \begin{mainitem} 
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% fix %%%%%%%%%%%%%%%%%%%%%%%%%

% \caseL{
% $
% \boxed{
%     \inferrule{
%       \Delta; \Gamma, f: (\tarr{\type_1}{\type_2}{}{\nnatbiA
%       }{\nnatA}), x: \type_1    ; \dmap, [x: \nnatbiA]
%       \tvdash{\nnatA}
%       \expr: \type_2 ~(1)
%     }{
%       \Delta; \Gamma; \wq{ \dmap } \tvdash{0} \efix f(x).\expr:
%       \tarr{\type_1}{( { \type_2} ) }{}{\nnatbiA}{\nnatA}
%     }~\textbf{fix}
% }
% $
% }

% Assume $ \ienv \in \lrv{\Delta}$, $(\stepiA, \env) \in \lrv{\ienv \Gamma}$.\\
% %
% TS: $(\stepiA, (\env, \ienv \efix f(x). \expr)) \in \lre{\dmap}{
%   0}{\ienv (\tarr{\type_1}{\type_2}{ }{\nnatbiA }{\nnatA}) }$.\\
% %
% By inversion, 
% STS: $\forall \valr, \tr, j$ 
% $(\env, \ienv \efix f(x). \expr \bigstep \valr, \tr) \land (\size{\tr} = j) \land (j \leq \stepiA)$\\
% %
% 1. $(\adap(\tr) \leq 0 ) $;\\
% %
% 2. $ (\forall x \in \mbox{Vars}. \ddep{x}(\tr) \leq \dmap(x)) $;\\
% %
% 3. $ ((\stepiA - j), \valr) \in \lrv{\ienv (\tarr{\type_1}{\type_2}{ }{\nnatbiA }{\nnatA})}$.\\
% %
% By E-FIX, let $\valr = (\ienv \efix f(x). \expr, \env)$, $\tr =  (\ienv \efix f(x). \expr, \env)$ we know:\\
% %
% (2). $(\env, \ienv \efix f(x). \expr) \bigstep ((\ienv \efix f(x). \expr, \env), \ienv \efix f(x). \expr) $;\\
% %
% (3). $| (\ienv \efix f(x). \expr, \env)|= j \land j < \stepiA$.\\
% %
% Suppose $(2), (3)$, STS:\\
% %
% 1. $ \adap(\ienv \efix f(x). \expr) = 0 \leq 0$;\\
% %
% 2. $ \forall x \in \mbox{Vars}. \ddep{x}( (\ienv \efix f(x). \expr,
% \env) ) = \bot \leq \dmap(x) $;\\
% %
% 3. $((\stepiA -j), (\ienv \efix f(x). \expr, \env)) \in \lrv{ \ienv (\tarr{\type_1}{\type_2}{ }{\nnatbiA }{\nnatA}) }$.\\
% %
% 1. and 2. are proved by definition.\\
% The third statement is proved by a general theorem: \\
% %
% Set $\stepiA - j = \stepiA'$, $\forall m \leq \stepiA', (m, (\ienv \efix f(x). \expr, \env)) \in \lrv{\ienv (\tarr{\type_1}{\type_2}{ }{\nnatbiA }{\nnatA})}$.\\
% %
% Induction on $m$:

% {\bf Subcase 1:} $m = 0$,\\
% 	%
% 	$~~~~$ TS: $\forall j' < 0. (j', \valr_m ) \in \lrv{\ienv
%           \tau_1}$, $ (\env[x \mapsto \valr_m, f \mapsto (\ienv \efix
%         f(x).\expr, \ienv \env)], \expr \bigstep \valr, \tr ) \dots $\\
% 	%
% 	$~~~~$ it is obviously true because $j' < 0 \notin \mathbb{N}$.\\
% 	%
% {\bf Subcase 2:} $m = m' + 1 \leq \stepiA'$,\\
% 	%
% 	$~~~~$ TS: $ (m, (\ienv \efix f(x). \expr, \env)) \in \lrv{ \ienv (\tarr{\type_1}{\type_2}{ }{\nnatbiA }{\nnatA}) }$.\\
% 	%
% 	$~~~~$ Pick $\forall j' < m' + 1$, $\forall (j', \valr_m) \in \lrv{\type_1}$,\\
% 	%

% 	$~~~~$ STS: $ (\env[x \mapsto \valr_m, f \mapsto (\ienv \efix
%         f(x).\expr, \env)], \ienv \expr) \bigstep \valr, \tr \conj
%         |\tr| = \stepiB'' \conj
%         \adap(\tr) \leq \ienv \nnatA \conj \ddep{x}(\tr) \leq \nnatbiA
%         \conj (j' - j'', v) \in \lrv{\ienv \type_2}$ (4).\\
% 	%

% 	$~~~~$ By sub ih, we have:
% 	(5). $(m', \ienv( \efix f(x). \expr, \env)) \in \lrv{\ienv (\tarr{\type_1}{\type_2}{\nnatbiA}{\dmap}{\nnatA})}$.\\
% 	%
% 	$~~~~$ Pick $\env' = \env[x \mapsto \valr_m, f \mapsto \ienv ( \efix f(x).\expr, \env)]$,\\
% 	%

% 	$~~~~$ So we know:  $$(j', \env') \in \lrv{\Gamma,
%           f:\ienv (\tarr{\type_1}{\type_2}{\nnatbiA}{\dmap}{\nnatA}),  x:
%           \ienv  \type_1}~(6)$$ proved by:
%     \begin{enumih}	
% 	\item $ (\stepiA, \env) \in \lrv{\Gamma}$, applying Lemma~\ref{lem:downward} on assumption, we get: $(j', \env) \in \lrv{\Gamma}$.
	
% 	\item $(j', \valr_m) \in \lrv{\ienv \type_1}$, from the assumption.
	
% 	\item $(j', (\efix f(x). \expr, \env)) \in \lrv{\ienv (\tarr{\type_1}{\type_2}{\nnatbiA}{\dmap}{\nnatA})}$ from $(5)$.\\
% 	\end{enumih}

% by induction hypothesis on $(1)$ and $(6)$,  we conclude that:
%      $$(j', (\env[x \mapsto \valr_m, f \mapsto \ienv ( \efix
%      f(x).\expr, \env)], \expr ))  \in \lre{\dmap[x:\nnatbiA]}{
%   \ienv \nnatA}{\ienv \type_2} $$
% Unfold the conclusion, we get:
%     $ (\env[x \mapsto \valr_m, f \mapsto (\ienv \efix
%         f(x).\expr, \env)], \ienv \expr) \bigstep \valr, \tr \conj
%         |\tr| = \stepiB'' \leq \stepiB' $$\conj
%         \adap(\tr) \leq \ienv \nnatA $$\conj \forall x \in
%         \mbox{Vars}.\eapp  \ddep{x}(\tr) \leq \dmap[x:\nnatbiA](x) 
%         \conj (j' - j'', v) \in \lrv{\ienv \type_2}$.
% %
%    (4) is proved by the above statements.\\
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% APP %%%%%%%%%%%%
% \caseL
% {
% $
%     \boxed{
%      \inferrule{
%       \Delta; \Gamma ;\dmap_1  \tvdash{\nnatA_1} \expr_1: \wq{\tarr{\type_1}{\type_2}{}{\nnatbiA}{\nnatA}}~(\star) \\
%       \Delta; \Gamma ; \dmap_2 \tvdash{\nnatA_2} \expr_2: \type_1~(\diamond) \\\\
%       \nnatA' = \nnatA_1 + \max(\nnatA, \nnatA_2 + \nnatbiA) \\
%       \wq{ \dmap' = \max( \dmap_1, \nnatA_1 + \dmap_2 ) }
%     }{
%       \Delta; \Gamma; \dmap' \tvdash{\nnatA'} \expr_1 \eapp \expr_2 : \type_2
%     }~\textbf{app}
% }
% $
% }
% %
% Assume $ \ienv \in \lrv{\Delta}$, $(\stepiA, \env) \in \lrv{\ienv
%   \Gamma} ~ (\triangle)$. \\
% TS: $(\stepiA, (\env, \ienv  (\expr_1 \eapp \expr_2))) \in \lre{\dmap'}{\ienv \nnatA'}{\ienv \type_2}$.\\
% %
% By inversion, pick any $\valr, \tr, j$
% %
% s.t. $((\env, \expr_1 \eapp \expr_2) \bigstep (\valr, \tr)) 
% \land (\size{\tr} = j) 
% \land (j \leq \stepiA) $, \\
% %
% STS:\\
% 1. $(\adap(\tr) \leq \ienv \nnatA') $;\\
% %
% 2. $ (\forall x \in \mbox{Vars}. \ddep{x}(\tr) \leq \dmap'(x))$;\\
% %
% 3. $(((\stepiA - j), \valr) \in \lrv{\ienv \type_2})$.\\
% %
% By ih on $\star$ and $\triangle$, we get: (1) $(\stepiA, (\env, \ienv
% \expr_1)) \in \lre{\dmap_1}{\ienv  \nnatA_1}{ \ienv
%   (\tarr{\type_1}{\type_2}{ }{\nnatbiA}{\nnatA}) }$.\\
% %
% Inversion on $(1)$, we get:\\
% %
% Pick any $\valr_1, \tr_1, j_1$, s.t. $((\env, \ienv \expr_1) \bigstep (\valr_1, \tr_1)) ~(a) \land (\size{\tr_1} = j_1) \land (j_1 < \stepiA)$, \\
% %
% we know: \\
% (2) $(\adap(\tr_1) \leq \ienv \nnatA_1)$;\\
% %
% (3) $ (\forall x \in \mbox{Vars}. \ddep{x}(\tr_1) \leq \dmap_1(x))$;\\
% %
% (4) $((\stepiA - j_1), \valr_1) \in \lrv{ \ienv
%   (\tarr{\type_1}{\type_2}{ }{ \nnatbiA }{\nnatA}) }$.\\
% %
% $\valr_1$ is a function by definition.\\
% %
% Let $\valr_1 = (\efix f(x). \expr, \env') ~(b)$ s.t. $\tr_1= (\efix
% f(x). \expr, \env)$\\
% %
% By inversion on $(4)$, we know: $\forall j' < (\stepiA - j_1) \land (j', \valr') \in \lrv{\ienv \type_1}$,
% %

%  $   (\env'[x \mapsto \valr', f \mapsto (\efix f(x).\expr, \env')],
%  \expr) \bigstep \valr'', \tr''~(d) \conj |\tr''| = \stepiB'' \leq \stepiB'
%  \conj \adap(\tr') \leq \ienv \nnatA  \conj \ddep{x}(\tr') \leq \ienv
%  \nnatbiA \conj    (j'-j'', \valr'') \in \lrv{\ienv \type_2} ~ (5)$.\\ 
% %

% By ih on $\diamond$ and $\square$, we get:
% %
%  $ (\stepiA, (\env, \ienv \expr_2)) \in \lre{\dmap_2}{\ienv \nnatA_2}{\ienv \type_1} ~(6)$.\\
% %
% Inversion on (6), we get:\\
% %
% Pick any $\valr_2, \tr_2, j_2$, s.t. 
% %
% $((\env, \ienv \expr_2) \bigstep (\valr_2, \tr_2))~(c) 
% \land (\size{\tr_2} = j_2) 
% \land (j_2 \leq \stepiA)$,\\
% %
% we know: \\
% %
% (7). $(\adap(\tr_2) \leq \ienv \nnatA_2)$;\\
% %
% (8). $(\forall x \in \mbox{Vars}. \ddep{x}(\tr_2) \leq \dmap_2(x))$; \\
% %
% (9). $((\stepiA - j_2), \valr_2) \in \lrv{\ienv \type_1}$\\
% %
% Apply Lemma~\ref{lem:downward} on $(9)$, we have $((\stepiA - j_2 - j_1-1), \valr_2) \in \lrv{\ienv  \type_1}$\\
% %
% Pick $j' = \stepiA - j_1 - j_2 - 1, \valr' = \valr_2$, from (5), we have:\\
% %
% (11). $\adap(\tr'') \leq \ienv  \nnatA$;\\
% %
% (12). $ \ddep{x}(\tr'')\leq
%  \nnatbiA$;\\
% %
% (13). $(\stepiA - j_1 - j_2 - j''-1, \valr'') \in \lrv{\ienv \type_2}$.\\
% %
% Apply E-APP rule on $(a) (b) (c) (d)$ we have:
% \[
%   \inferrule{
%     \env, \ienv  \expr_1 \bigstep \valr_1, \tr_1 ~ (a) \\
%     \valr_1 = (\efix f(x).\expr, \env')~(b) \\\\
%     \env, \ienv  \expr_2 \bigstep \valr_2, \tr_2 ~ (c) \\
%     \env'[f \mapsto \valr_1, x \mapsto \valr_2], \expr \bigstep \valr'', \tr'' ~(d)
%   }{
%     \env,\ienv ( \expr_1 \eapp \expr_2) \bigstep \valr'', \trapp{\tr_1}{\tr_2}{f}{x}{\tr''}
%   }
% \]
% Pick $\valr = \valr'', j = j_1 + j_2 + j'' + 1, \tr =
% \trapp{\tr_1}{\tr_2}{f}{x}{\tr''}$ s.t. $ \env, \expr_1 \eapp \expr_2
% \bigstep \valr, \tr  \land |\tr| = j \land j \leq k $.  \\
% Suffice to show the follwing three:\\
% %
% 1. $\adap(\tr) = \adap(\trapp{\tr_1}{\tr_2}{f}{x}{\tr''}) =
% \adap(\tr_1) + \max(\adap(\tr''), \adap(\tr_2) + \ddep{x}(\tr'')) \leq
% %
% \ienv \nnatA_1 + \max(\ienv \nnatA, \ienv \nnatA_2 + \nnatbiA) = \ienv \nnatA'$ proved by $(2),(7),(11),(12)$.\\
% %
% 2. $\forall y \in \mbox{Vars}. \ddep{y}(\tr) = \max(\ddep{y}(\tr_1), \adap(\tr_1) +
% \max(\ddep{y}(\tr''), \ddep{y}(\tr_2) + \ddep{x}(\tr''))) \leq
% \max(\dmap_1, \nnatA_1 + \max(\dmap, \dmap_2 + \nnatbiA)) = \dmap'(y)$
% proved by $(2),(3),(8),(12)$. \\
% %
% 3. $(\stepiA - j, \valr) = (\stepiA - j_1 - j_2 - j''-1, \valr'') \in
% \lrv{\ienv \type_2}$ proved by $(13)$.\\
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%DELTA%%%%%%%%%%%%%%%
% \wq{ \caseL{
% $
%   \boxed{
%     \inferrule
%     {
%       \Delta; \Gamma ; \dmap \tvdash{\nnatA} \expr:  \mathsf{DICT}(\type_i \to
%       {\type_i'}^{\, i \in 1,2\dots n} ) \\
%       \nnatA' = 1 + \nnatA 
%     }
%     {
%        \Delta; \Gamma; \dmap \tvdash{\nnatA'} \eop(\expr): \treal
%     }~\textbf{$\delta$}
%     }
% $
% } }

% Assume $ \ienv \in \lrv{\Delta}$, $(\stepiA, \env) \in \lrv{\ienv \Gamma}$, TS: $(\stepiA, \ienv (\eop(\expr), \env)) \in \lre{\dmap'}{\ienv \nnatA'}{\treal}$.\\
% %
% Unfold, pick $\valr, \tr$, assume  $(\ienv \env, \ienv \eop(\expr) \bigstep \valr, \tr) \land (\size{\tr} = j) \land (j \leq \stepiA)$.\\
% %
% STS: 
% 1.
% $(\adap(\tr) \leq \ienv \nnatA') $ \\ 
% 2. $ (\forall x \in \mbox{Vars}. \ddep{x}(\tr) \leq \dmap'(x)) $ \\
% 3.  $ ((\stepiA - j, \valr) \in \lrv{\treal})$.\\
% %
% From the evaluation rules, we assume that :
% \[
%  \inferrule{
%     \ienv \env, \ienv \expr \bigstep \valr', \tr' \\
%     \eop{}(\valr') = \valr
%   }{
%     \env, \eop(\expr) \bigstep \valr', \trop(\tr')
%   }
% \]

% By induction hypothesis on $\star$, we get:
%  \[
% (\stepiA, (\ienv \expr, \ienv \env)) \in \lre{\dmap}{\ienv \nnatA}{\tbox{
%     (\tarr{ \type_1}{ \type_2 }{0}{\dmap''}{0})}} ~ (1)
% \].\\
% %
% Assume $\ienv \env, \ienv \expr \bigstep \valr', \tr' \conj |\tr'|=j'
% \conj j' < \stepiA$,\\
%  we know: $(\adap(\tr') \leq \ienv \nnatA) ~ (a) $ \\
% $ (\forall x \in \ddep{x}(\tr') \leq \dmap(x)) ~ (b)$ \\
% $ ((\stepiA - j', \valr') \in \lrv{\tbox{  (\tarr{ \type_1}{
%       \type_2 }{0}{\dmap''}{0})     }}) ~ (c)$ \\

% \begin{enumerate}
% \item [STS1:] $\adap(\tr) = \adap(\trop(\tr') )  \leq \ienv \nnatA'
%   $\\
% Unfold $\adap(\trop(\tr') ) $, STS:\\
%  $1+ \adap(\tr') + \textsf{MAX}_{\valr \in \type_1} \Big(
%                               \max \big(\adap(\tr_3 (\valr) ),
%                               \ddep{x}(\tr_3(\valr)) \big) \Big) \leq
%                               \ienv \nnatA' $. \\
%       $\mathsf{where}$   $\valr_1 = (\efix f(x: \type_1). \expr_1, \env_1 ) =
%                        \mathsf{extract}(\tr') $ and $  \env_1[f \mapsto
%                        \valr_1, x \mapsto \valr], \expr_1 \bigstep
%                        \valr'', \tr_3(\valr)  $\\
%   By Lemma\ref{lem:trace_extract} based on our assumption $\ienv \env, \ienv \expr \bigstep \valr', \tr'$,  we know that $\valr_1 =
%                        \mathsf{extract}(\tr) = v' $.\\
%  Unfold $(c)$, we know : $(\stepiA - j',  (\efix f(x: \type_1). \expr_1, \env_1 ) ) \in \lrv{  (\tarr{ \type_1}{
%       \type_2 }{0}{\dmap''}{0}) }~(d) $  and $ \delta \not\in  (\efix
%   f(x: \type). \expr_1, \env_1 ) $  \\
%   Unfold $(d)$, we get : $ \forall j_1 < (\stepiA-j'). (\stepiB_1,
%   \valr_a) \in \lrv{\type_1} $, $  ( \stepiB_1, ( \expr_1 ,\env_1[f \mapsto
%                        \valr_1, x \mapsto \valr_a]) )\in
%                        \lre{\dmap''[x:0,f:\infty]}{0}{\type_2}~(e) $.\\  
%    Pick $\valr_a$, unfold $(e)$, we assume:  $ \env_1[f \mapsto
%                        \valr_1, x \mapsto \valr_a], \expr_1 \bigstep
%                        \valr'', \tr_3(\valr_a)  \conj |\tr_3(\valr_a)|
%                        = j_2 \conj j_2 \leq j_1.$
%                        \\
%    we get: $ \adap(\tr_3(\valr_a)) \leq 0 (f)$ \\
%              $ \forall x \in \ddep{x}(\tr_3(\valr_a)) \leq
%              \dmap''[x:0,f:\infty](x) ~(h)$ \\

%   From $(f)$, we know $\forall \valr_a \in
%   \lrv{\type_1}. \adap(\tr_3(\valr_a)) =0$. \\
%  By Lemma~\ref{lem:adap_depth_zero}, we conclude that $ \textsf{MAX}_{\valr \in \type_1} \Big(
%                               \max \big(\adap(\tr_3 (\valr) ),
%                               \ddep{x}(\tr_3(\valr)) \big) \Big) \leq 0~(g) $.\\
%            This property is proved by $(a),(g)$.

% \item [STS2:] $ \ddep{x}(\tr) = \ddep{x}(\trop (\tr')) =  1 +  \max(\ddep{x}(\tr'),
%         \adap(\tr') + \textsf{MAX}_{\valr \in \type_1} \Big(
%           \max(\ddep{x}(\tr_3(\valr)), \bot )   \Big ) )$ \\
%  $\leq      \dmap'(x) $.\\
%        It is proved by $(a),(b),(h)$.\\
% \item[STS3:] $ ((\stepiA - j, \valr) \in \lrv{\treal})$\\
%     It is proved by the property of the constuct $\trop$ whose
%     codomain is real number. \\
        
% \end{enumerate}

% \end{mainitem}
% \end{proof}