\begin{example}
[Multiple Rounds Odds Algorithm]
\label{ex:overapproximate}
The $\THESYSTEM$ comes across an over-approximation due to its path-insensitive nature. 
It occurs when the control flow can be decided in a particular way in front of conditional branches,
while the static analysis fails to witness. 

As in Figure~\ref{fig:overappr_example}(a), $\kw{multipleRoundsOdd}(k)$
is an example program with $1 + k$ adaptivity rounds and two paths while loop.
% we call it a multiple rounds odd iteration algorithm. 
In each iteration, 
the query $\query(\chi[x])$ in command $5$ is based on previous query results stored in $x$, which is similar to Example~\ref{ex:multipleRounds}.
The difference is that, only the query answers from the even iterations ($i = 0, 2, \cdots $) are 
% used to $b$. 
used in the query 
in command $7$, $\query(\chi[\ln(y)])$.
  Because the execution trace only updates 
%   $b$ using the query answers at odd iterations, so the answers from even iterations do not affect the queries at odd iterations. From the query-based dependency graph in Figure~\ref{fig:overappr_example}(b), we can see that there is no edge from queries at odd iterations (such as $q_1,q_3,q_5$) to queries at even iteration(such as $q_2,q_4$). The longest path is dashed with a length $3$.  However, {\THESYSTEM} fails to realize that odd iteration will always execute then branch and even iteration means else branch, so its dependency graph considers both branches for every iteration. In this sense, the dependency graph by {\THESYSTEM} is similar to the one in the multiple rounds strategy. We show the estimated graph in Figure~\ref{fig:overappr_example}(c). The estimated upper bound is then, $5$, instead of $3$. 
$x$ using the query answers in even iterations, so the answers from odd iterations do not affect the queries in even iterations. 
From the execution-based dependency graph in Figure~\ref{fig:overappr_example}(b), 
we can see that the weight for the vertex $y^5$ is 
$f_{k/2}$.
$f_{k/2} : \trace_0 \to (\env(\trace_0) k) / 2$, computes return the value of $k/2$ from input initial $\trace_0$.  
However, {\THESYSTEM} fails to realize that all the odd iterations only execute the first branch
and only even iterations execute the second branch. 
% its dependency 
So it considers both branches for every iteration when estimating the adaptivity. 
In this sense, the weight estimated for $y^5$ and $p^6$ are both 
$k$ as in Figure~\ref{fig:overappr_example}(c).
As a result, {\THESYSTEM}  estimates the longest walk from Figure~\ref{fig:overappr_example}(c) as
$y^5  \to x^7  \to y^5  \to \cdots \to x^7  $ with each vertex being visited $k$ times.
And the computed adaptivity  
% estimated from the program-based dependency graph graph from by finding the walk with the longest query length 
is $1 + 2 * k$, instead of $1 + k$. 
% We omitted the estimated graph, which is identical to the graph in Figure~\ref{fig:overappr_example}(b). 
%
{ \small
\begin{figure}
\centering
    \begin{subfigure}{0.33\textwidth}
\centering
\small{
    \[
    %
    \begin{array}{l}
        \kw{multipleRoundsOdd}(k) \triangleq \\
        \clabel{ \assign{j}{k}}^{0} ; 
        \clabel{ \assign{x}{\query(\chi[0])} }^{1} ; \\
            \ewhile ~ \clabel{j > 0}^{2} ~ \edo ~ 
            \Big(
             \clabel{\assign{j}{j-1}}^{3} ;\\
             \eif(\clabel{j \% 2 == 0}^{4}, \\
             \clabel{\assign{y}{\chi[x]}}^{5}, 
             \clabel{\assign{p}{\chi[x]}}^{6});\\                            
             \clabel{\assign{x}{\query(\chi(\ln(y)))} }^{7} \Big)
        \end{array}
    \]
}
 \caption{}
    \end{subfigure}
%
\begin{subfigure}{.31\textwidth}
    \begin{centering}
    \begin{tikzpicture}[scale=\textwidth/11cm,samples=200]
% Variables Initialization
\draw[] (5, 1) circle (0pt) node{{ $x^1: {}^{f_1}_{1}$}};
% Variables Inside the Loop
 \draw[] (0, 7) circle (0pt) node{{ $y^5: {}^{f_k/2}_{1}$}};
 \draw[] (0, 4) circle (0pt) node{{ $p^6: {}^{f_k/2}_{1}$}};
 \draw[] (0, 1) circle (0pt) node{{ $x^7: {}^{f_k}_{1}$}};
 % Counter Variables
 \draw[] (5, 7) circle (0pt) node {{$j^0: {}^{f_1}_{0}$}};
 \draw[] (5, 4) circle (0pt) node {{ $j^3: {}^{f_k}_{0}$}};
 %
 % Value Dependency Edges:
 \draw[ thick, -latex,]  (0, 3.5) -- (0, 1.5) ;
%  \draw[ thick, -Straight Barb] (1, 4.2) arc (220:-100:1);
 \draw[ thick, -Straight Barb] (6.5, 4.5) arc (150:-150:1);
 \draw[ thick, -latex] (5, 4.5)  -- (5, 6.5) ;
%  \draw[ thick, -Straight Barb] (1., 1.5) arc (120:-200:1);
 % Value Dependency Edges on Initial Values:
 \draw[ thick, -latex,] (1.5, 1)  -- (4, 1) ;
 %
 \draw[ ultra thick, -latex, densely dotted,] (-0.6, 1.5)  to  [out=-220,in=220]  (-0.5, 6.5);
\draw[ ultra thick, -latex, densely dotted,]  (0.5, 6.5) to  [out=-30,in=30] (0.6, 1.6) ;
%  \draw[ ultra thick, -latex, densely dotted,]  (0.5, 10)  to  [out=-50,in=50] (0.5, 4);
 % Control Dependency
 \draw[ thick,-latex] (1.5, 7)  -- (4, 6) ;
 \draw[ thick,-latex] (1.5, 4)  -- (4, 6) ;
 \draw[ thick,-latex] (1.5, 1)  -- (4, 6) ;
%  \draw[ thick,-latex] (1.5, 10)  -- (4, 6) ;
 \end{tikzpicture}
 \caption{}
    \end{centering}
    \end{subfigure}
    \begin{subfigure}{.31\textwidth}
        \begin{centering}
        \begin{tikzpicture}[scale=\textwidth/11cm,samples=200]
    % Variables Initialization
    \draw[] (5, 1) circle (0pt) node{{ $x^1: {}^1_{1}$}};
    % Variables Inside the Loop
     \draw[] (0, 7) circle (0pt) node{{ $y^5: {}^{k}_{1}$}};
     \draw[] (0, 4) circle (0pt) node{{ ${p^6: {}^{k}_{1}}$}};
     \draw[] (0, 1) circle (0pt) node{{ ${x^7: {}^{k}_{1}}$}};
     % Counter Variables
     \draw[] (5, 7) circle (0pt) node {{$j^0: {}^{1}_{0}$}};
     \draw[] (5, 4) circle (0pt) node {{ $j^3: {}^{k}_{0}$}};
     %
% Value Dependency Edges:
 \draw[ thick, -latex,]  (0, 3.5) -- (0, 1.5) ;
%  \draw[ thick, -Straight Barb] (1, 4.2) arc (220:-100:1);
 \draw[ thick, -Straight Barb] (6.5, 4.5) arc (150:-150:1);
 \draw[ thick, -latex] (5, 4.5)  -- (5, 6.5) ;
%  \draw[ thick, -Straight Barb] (1., 1.5) arc (120:-200:1);
 % Value Dependency Edges on Initial Values:
 \draw[ thick, -latex,] (1.5, 1)  -- (4, 1) ;
 %
 \draw[ ultra thick, -latex, densely dotted,] (-0.6, 1.5)  to  [out=-220,in=220]  (-0.5, 6.5);
\draw[ ultra thick, -latex, densely dotted,]  (0.5, 6.5) to  [out=-30,in=30] (0.6, 1.6) ;
%  \draw[ ultra thick, -latex, densely dotted,]  (0.5, 10)  to  [out=-50,in=50] (0.5, 4);
 % Control Dependency
 \draw[ thick,-latex] (1.5, 7)  -- (4, 6) ;
 \draw[ thick,-latex] (1.5, 4)  -- (4, 6) ;
 \draw[ thick,-latex] (1.5, 1)  -- (4, 6) ;
%  \draw[ thick,-latex] (1.5, 10)  -- (4, 6) ;
     \end{tikzpicture}
     \caption{}
        \end{centering}
        \end{subfigure}
        \vspace{-0.4cm}
\caption{(a) The multiple rounds odd example 
(b) The execution-based dependency graph
(c) The program-based dependency graph graph from $\THESYSTEM$.}
    \label{fig:overappr_example}
    \vspace{-0.5cm}
\end{figure}
}
%
\end{example}