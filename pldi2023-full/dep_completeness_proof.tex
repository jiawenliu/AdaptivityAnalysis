 \begin{proof}[Proof of Theorem.~\ref{thm:alg_correct}].
Induction on $\trace$:
\begin{case}
[$\trace = \event_1 \cdot \event_2$]
\[
\begin{array}{l}
  \forall \event_1, \event_2 \in \eventset^{\asn}, D \in \dbdom , c \st
  \\ \quad 
   \forall l \in \mathcal{A}( \event_1, \event_2,  \event_1 \cdot \event_2, c, D) \st
   \\ \quad 
   \forall z^i, y^j \in \lvar_c, l_h, l_t \st 
   l = l_h ++ [z^i, y^j] ++ l_t 
   \implies \flowsto(z^i, y^j)
\end{array}
\]
%
Unfolding $\mathcal{A}(\event_1, \event_2, \trace, c, D)$
$\eventdep^{val}(\event_1, \event_2, \trace, c) \implies [\pi_1(\event_1)^{\pi_2(\event_1)}, \pi_1(\event_2)^{\pi_2(\event_2)}]$.
\\
Proved by the base case of $\flowsto$
\end{case}
%
\begin{case}
[$\trace = \event_1 \tracecat \trace_{ih} \cdot \event_2$]
by strong induction on $\trace$,
\[
\begin{array}{l}
  \forall \event_{ih1}, \event_{ih2} \eventin \trace, D \in \dbdom , c \st
  \\ \quad 
   \forall l \in \mathcal{A}(\event_{ih1}, \event_{ih2}, \trace[\event_{ih1}:\event_{ih2}], c, D) \st
   \\ \quad 
   \forall z^i, y^j \in \lvar_c, l_h, l_t \st 
   l = l_h ++ [z^i, y^j] ++ l_t 
   \implies \flowsto(z^i, y^j)
   \\
   \implies
   \forall D \in \dbdom , c \st
  \\ \quad 
   \forall l \in \mathcal{A}(\event_1, \event_2, \trace, c, D) \st
   \\ \quad 
   \forall z^i, y^j \in \lvar_c, l_h, l_t \st 
   l = l_h ++ [z^i, y^j] ++ l_t 
   \implies \flowsto(z^i, y^j)  
\end{array}
\]
%
Inversion on $l \in \mathcal{A}(\event_1, \event_2, \trace, c, D)$, get:
\[
  \exists \event_z, \event_y \in \eventset^{\asn}, l_h, l_t 
  \st l_h ++ [\event_z, \event_y] ++ l_t \land 
\]
or
\[
    \exists \event_b \st l_h ++ [\event_z, \event_b, \event_y] ++ l_t
\]
\begin{subcase}[ $l_h ++ {[\event_z, \event_y]} ++ l_t$ ].
\\
inversion on  $l_h ++ {[\event_z, \event_y]} ++ l_t$, 
\[
  \exists l_{h}' ++ [\event_y] ++ l_t, \trace \st
  \eventdep^{val}(\event_z, \event_y, \trace[\event_z: \event_y], c, D)
  \land 
  \neg \eventdep^{val} (\event_z, l_h')
\]
%
By $\eventdep^{val}(\event_z, \event_y, \trace[\event_z: \event_y], c, D)$, 
we have
\[
  [\pi_1(\event_z)^{\pi_2(\event_z)}, \pi_1(\event_y)^{\pi_2(\event_y)}] 
  \in \mathcal{A}(\event_z, \event_y, \trace[\event_{z}:\event_{y}], c, D) 
\]
%
By induction hypothesis on subtrace $\trace[\event_z: \event_y]$ and $\event_z, \event_y$ and conclusion above, we know:
\[
  \flowsto(\pi_1(\event_z)^{\pi_2(\event_z)}, \pi_1(\event_y)^{\pi_2(\event_y)})
\]
This case is proved.
%
\completeness{
\\
By $\neg \eventdep^{val} (\event_z, l_h')$, 
\[
  \forall x \in l_h' \st
  \env \app \trace x = \env \app \trace' x
\]
%
$\forall \event \in \trace \land \event \notin l_h'$, by induction hypothesis on $l_{h}' ++ [\event_y] ++ l_t$, 
\[
  \neg \eventdep^{val} (\event, \event_y, c, D)
\]
%
We know:
\\
%
$\event_z$ is the only possible cause of difference in $\event_y$ and $\event_y'$.
%
\\
By inversion Lemma.~\ref{lem:inv_a}, 
\[
  z \in VAR(y)
\]
%
By $\flowsto$ definition:
\[
  \flowsto(z, y)
\]
}
%
\end{subcase}
%
\begin{subcase}[ $l_h ++ {[\event_z, \event_b, \event_y]} ++ l_t$ ].
\\
by strong induction on $\trace$,
\[
\begin{array}{l}
  \forall \event_{ih1}, \event_{ih2} \eventin \trace, D \in \dbdom , c \st
  \\ \quad 
   \forall l \in \kw{dfs}(\event_{ih1}, \trace[\event_{ih1}:\event_{ih2}], c, D) \st
   \\ \quad 
   \forall \event_b \in \eventin (\trace \cap \eventset^{\test}), \event_c \in \eventset, l_h, l_t \st 
   l = l_h ++ [ \event_b, \event_c] ++ l_t 
   \implies \forall z \in VAR(\pi_1(\event_b)) \implies \exists i \in \mathbb{N}, \flowsto(z^i, y^j)
   \\
   \implies
   \forall D \in \dbdom , c \st
  \\ \quad 
   \forall l \in \kw{dfs}(\event_1, \trace, c, D) \st
   \\ \quad 
   \forall \event_b \in \eventin (\trace \cap \eventset^{\test}), \event_c \in \eventset, l_h, l_t \st 
   l = l_h ++ [ \event_b, \event_c] ++ l_t 
   \implies \forall z \in VAR(\pi_1(\event_b)) \implies \exists i \in \mathbb{N}, \flowsto(z^i, y^j)
\end{array}
\]
inversion on  $l_h ++ {[\event_z,  \event_b, \event_y]} ++ l_t \in \kw{dfs}(\event_1, \trace, c, D)$, 
\[
  \exists l_{h}' ++ [\event_b, \event_y] ++ l_t, \trace \st
  \eventdep^{val}(\event_z, \event_b, \trace[\event_z: \event_b], c, D)
  \land 
  \neg \eventdep^{val} (\event_z, l_h', \trace[\event_z: l_h'], c, D)
  \land 
  \eventdep^{\ctl} (\event_b, \event_y, c, D)
\]
%
By $\eventdep^{\ctl} (\event_b, \event_y) $, we have:
\[
  [\event_b, \event_y]\in \kw{dfs}(\event_{z}, \trace[\event_{z}:\event_{y}], c, D)
\]
%
By induction hypothesis, we have:
\begin{equation}
\label{ih_ctl}
  \forall z \in VAR(\pi_1(\event_b)) \implies \exists i \in \mathbb{N}, \flowsto(z^i, y^j)
\end{equation}
%
By $\eventdep^{val}(\event_z, \event_b, \trace[\event_z: \event_b], c, D)$, we have:
\[
  [\event_z, \event_b]\in \kw{dfs}(\event_{z}, \trace[\event_{z}:\event_{b}], c, D)
\]
%
By induction hypothesis, we have:
\[
  \pi_1(\event_z) \in VAR(b)
\]
%
By $\flowsto$ definition, we have $\pi_2(\event_z)$ be the label in Eq.~\ref{ih_ctl} s.t.:
\[
  \flowsto(\pi_1(\event_z)^{\pi_2(\event_z)}, y^j)
\]
%
This case is proved
%
\completeness{
\\
By $\neg \eventdep^{val} (\event_z, l_h')$, 
\[
  \forall x \in l_h' \st
  \env \app \trace x = \env \app \trace' x
\]
%
$\forall \event \in \trace \land \event \notin l_h'$, by induction hypothesis on $l_{h}' ++ [\event_y] ++ l_t$, 
\[
  \neg \eventdep^{val} (\event, \event_y, c, D)
\]
%
We know:
\\
%
$\event_z$ is the only possible cause of difference in $\event_b$ and $\event_b'$.
%
By inversion Lemma.~\ref{lem:inv_b}, 
\[
  z \in VAR(b)
\]
%
By $  \eventdep^{\ctl} (\event_b, \event_y)$:
\[
  \forall x \in VAR(b) \st \flowsto(x, y)
\]
i.e.,
\[
  \flowsto(z, y)
\]
}
%
\end{subcase}
%
\begin{subcase}[ $l_h ++ {[\event_z, \event_{b_1}, \cdots, \event_{b_n}, \event_y]} ++ l_t$ ].
\\
inversion on  $l_h ++ {[\event_z,  \event_{b_1}, \cdots, \event_{b_n},\event_y]} ++ l_t$, 
\[
  \exists l_{h}' ++ [ \event_{b_1}, \cdots, \event_{b_n}, \event_y] ++ l_t, \trace \st
  \eventdep^{val}(\event_z, \event_{b_1}, \trace)
  \land 
  \neg \eventdep^{val} (\event_z, l_h')
  \land 
  \eventdep^{\ctl} (\event_{b_1}, \event_{b_2})
  \land 
  \cdots
  \land 
  \eventdep^{\ctl} (\event_{b_n}, \event_y)
\]
%
By $\neg \eventdep^{val} (\event_z, l_h')$, 
\[
  \forall x \in l_h' \st
  \env \app \trace x = \env \app \trace' x
\]
%
$\forall \event \in \trace \land \event \notin l_h'$, by induction hypothesis on $l_{h}' ++ [\event_y] ++ l_t$, 
\[
  \neg \eventdep^{val} (\event, \event_y, c, D)
\]
%
We know:
\\
%
$\event_z$ is the only possible cause of difference in $\event_{b_1}$ and $\event_{b_1}'$.
%
By inversion Lemma.~\ref{lem:inv_b}, 
\[
  z \in VAR(b_1)
\]
%
%
By transitivity of control dependency between testing events in Lemma.~\ref{lem:ctl_trans},
we have:
 $ \eventdep^{\ctl} (\event_{b_1}, \event_y)$:
\[
  \forall x \in VAR(b_1) \st \flowsto(x, y)
\]
i.e.,
\[
  \flowsto(z, y)
\]
%
\end{subcase}
%
\end{case}
%
%
Unfolding $\vardep({x}_1^{l_1}, {x}_2^{l_2}, {c})$ by Definition~\ref{def:var_dep},
we get:
\[
\exists \event_1, \event_2 \in \eventset^{\asn}, D \in \dbdom \st
\pi_{(1,2)}{(\event_1)} = ({x}_1, l_1)
\land
\pi_{(1,2)}{(\event_2)} = ({x}_2, l_2)
\land 
\eventdep(\event_1, \event_2, c, D)
\]
%
Then, it is sufficient to show
%
\[
\begin{array}{l}
\forall {x}_1^{l_1}, {x}_2^{l_2} \in \lvar_{{c}},
 \event_1, \event_2 \in \eventset^{\asn}, D \in \dbdom \st
 \\ \quad
(\pi_{1}{(\event_1)}, \pi_{2}{(\event_1)}) = ({x}_1, l_1)
\implies
(\pi_{1}{(\event_2)}, \pi_{2}{(\event_2)}) = ({x}_2, l_2)
\implies 
\eventdep(\event_1, \event_2, c, D)
 \\ \qquad \implies
   \Big(\exists  n \in \mathbb{N},z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}} \st 0 \leq n
 \land \flowsto(x_1^{l_1}, z_1^{r_1}, c) \land \cdots \land \flowsto(z_n^{r_n}, {x}_2^{l_2}, c) \Big)
\end{array}
\]
%
%
%
%
%
Unfolding $\eventdep(\event_1, \event_2, c, D)$ by Definition~\ref{def:event_dep}, we have:
\[
\forall \trace_2 \in \mathcal{T} \st
\eventdep^{val}(\event_1, \event_2, \trace_2, c, D) ~ (a) 
\lor
\eventdep^{\ctl}(\event_1, \event_2, c, D) ~ (b)
\]
%
Then, it is sufficient to show
%
\[
\begin{array}{l}
\forall {x}_1^{l_1}, {x}_2^{l_2} \in \lvar_{{c}}, \trace_2 \in \mathcal{T}, 
\event_1, \event_2 \in \eventset^{\asn}, D \in \dbdom \st
\\ \quad
(\pi_{1}{(\event_1)}, \pi_{2}{(\event_1)}) = ({x}_1, l_1)
\implies
(\pi_{1}{(\event_2)}, \pi_{2}{(\event_2)}) = ({x}_2, l_2)
 \\ \qquad \implies 
\eventdep^{val}(\event_1, \event_2, \trace_2, c, D) ~ (a)
\lor
\eventdep^{\ctl}(\event_1, \event_2, c, D)  ~ (b)
 \\ \qquad \implies
   \Big(\exists  n \in \mathbb{N}, z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}} \st 0 \leq n
 \land \flowsto(x_1^{l_1}, z_1^{r_1}, c) \land \cdots \land \flowsto(z_n^{r_n}, {x}_2^{l_2}, c) \Big)
\end{array}
\]
%
%
By strong induction on structure of $\vtrace_2$, there are 2 cases and the statements need to be proved for the 2 cases are as follows:
%
$$
\begin{array}{l}
P(\cdot)
 \triangleq
\forall {x}_1^{l_1}, {x}_2^{l_2} \in \lvar_{{c}},
\event_1, \event_2 \in \eventset^{\asn}, D \in \dbdom \st
\\ \quad
(\pi_{1}{(\event_1)}, \pi_{2}{(\event_1)}) = ({x}_1, l_1)
\implies
(\pi_{1}{(\event_2)}, \pi_{2}{(\event_2)}) = ({x}_2, l_2)
 \\ \qquad \implies 
\eventdep^{val}(\event_1, \event_2, \cdot, c, D)
\lor
\eventdep^{\ctl}(\event_1, \event_2, c, D)  ~ (b)
  \\ \qquad \implies
   \Big(\exists  n \in \mathbb{N}, z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}} \st 0 \leq n
 \land \flowsto(x_1^{l_1}, z_1^{r_1}, c) \land \cdots \land \flowsto(z_n^{r_n}, {x}_2^{l_2}, c) \Big)
\end{array}
$$
%
$$
\begin{array}{l}
P(\trace_{ih} \cdot \event_{ih})
\triangleq 
\forall \trace_{ih}', \trace_{ih}'' \in \mathcal{T} \st \trace_{ih} = \trace_{ih}' \tracecat \trace_{ih}'' \st
\forall {x}_1^{l_1}, {x}_2^{l_2} \in \lvar_{{c}},
\event_1, \event_2 \in \eventset^{\asn}, D \in \dbdom \st
\\ \quad
(\pi_{1}{(\event_1)}, \pi_{2}{(\event_1)}) = ({x}_1, l_1)
\implies
(\pi_{1}{(\event_2)}, \pi_{2}{(\event_2)}) = ({x}_2, l_2)
 \\ \qquad \implies 
\eventdep^{val}(\event_1, \event_2, \trace_{ih}', c, D)
\lor
\eventdep^{\ctl}(\event_1, \event_2, c, D)  ~ (b)
  \\ \qquad \implies
   \Big(\exists  n \in \mathbb{N}, z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}} \st 0 \leq n
 \land \flowsto(x_1^{l_1}, z_1^{r_1}, c) \land \cdots \land \flowsto(z_n^{r_n}, {x}_2^{l_2}, c) \Big)
\\ \quad \implies
\forall {x}_1^{l_1}, {x}_2^{l_2} \in \lvar_{{c}},
\event_1, \event_2 \in \eventset^{\asn}, D \in \dbdom \st
\\ \quad
(\pi_{1}{(\event_1)}, \pi_{2}{(\event_1)}) = ({x}_1, l_1)
\implies
(\pi_{1}{(\event_2)}, \pi_{2}{(\event_2)}) = ({x}_2, l_2)
 \\ \qquad \implies 
\eventdep^{val}(\event_1, \event_2, \trace_{ih} \cdot \event_{ih}, c, D)
\lor
\eventdep^{\ctl}(\event_1, \event_2, c, D)  ~ (b)
  \\ \qquad \implies
   \Big(\exists  n \in \mathbb{N}, z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}} \st 0 \leq n
 \land \flowsto(x_1^{l_1}, z_1^{r_1}, c) \land \cdots \land \flowsto(z_n^{r_n}, {x}_2^{l_2}, c) \Big)
\end{array}
$$
%
It is proved by splitting the cases $(a)$ and $(b)$:
%
\caseL{$(a) ~ \eventdep^{val}(\event_1, \event_2, \trace_2, c, D)$}
%
In this case, it is sufficient to show
 %
 \[
\begin{array}{l}
\forall {x}_1^{l_1}, {x}_2^{l_2} \in \lvar_{{c}}, \trace_2 \in \mathcal{T}, 
\event_1, \event_2 \in \eventset^{\asn}, D \in \dbdom \st
\\ \quad
(\pi_{1}{(\event_1)}, \pi_{2}{(\event_1)}) = ({x}_1, l_1)
\implies
(\pi_{1}{(\event_2)}, \pi_{2}{(\event_2)}) = ({x}_2, l_2)
 \\ \qquad \implies 
\eventdep^{val}(\event_1, \event_2, \trace_2, c, D)
 \\ \qquad \implies
   \Big(\exists  n \in \mathbb{N}, z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}} \st 0 \leq n
 \land \flowsto(x_1^{l_1}, z_1^{r_1}, c) \land \cdots \land \flowsto(z_n^{r_n}, {x}_2^{l_2}, c) \Big)
\end{array}
\]
%
%   Or proved as follows:
%  $$
%    \begin{array}{l}
% P(\cdot \event_1 \tracecat \trace_{ih} \cdot \event_{ih} \cdot \event_2, c)
%  = 
%  \big(P(\cdot \event_1 \tracecat \trace_{ih} \cdot \event_{ih}, c) \land P(\event_{ih} \cdot \event_2, c)\big) 
%   \\ \qquad \lor 
%  \Big(\exists c' \st (P(\cdot \event_1 \tracecat \trace_{ih} \cdot \event_2, c') 
%  \land \eventdep^{val}(\event_1, \event_2,c, D) 
%  \\ \quad \qquad \land
%  \big(\forall x^i, y^j \in \lvar_{c'} \st \flowsto(x^i, y^j, c') \implies \flowsto(x^i, y^j , c) \big)\Big)
% %   \lor 
% % \big( \exists \event_3 = (z, l, n, v) \in \trace_2' (P(\cdot \event_1 \tracecat \trace_{ih} \cdot \event_{ih}) \land 
% %   \flowsto(z^l, {x}_2^{l_2}, c))\big)
%  \end{array}
%  $$
%   \todo{
%   intuition of
%   $\exists c' \st (P(\cdot \event_1 \tracecat \trace_{ih} \cdot \event_2, c') 
%  \land 
%  \big(\forall x^i, y^j \in \lvar_{c'} \st \flowsto(x^i, y^j, c') \implies \flowsto(x^i, y^j , c)$ 
%  is:
%  \\
%  if $\event_{ih}$ doesn't have dependency on $\event_1$ or with $\event_2$,
%  then there exists a program $c'$ without generating $\event_{ih}$ such that
%  $\flowsto$ relation from $x_1$ to $x_2$ in $c'$ is exactly the same as the $\flowsto$ relation from $x_1$ to $x_2$ in $c$.
%   }
\begin{case}[$P(\cdot)$].
\label{case:valdep_base}
%
\\
We have $P(\cdot)$ as follows:
%
\[
\begin{array}{l}
\forall {x}_1^{l_1}, {x}_2^{l_2} \in \lvar_{{c}}, \trace_2 \in \mathcal{T}, 
\event_1, \event_2 \in \eventset^{\asn}, D \in \dbdom \st
\\ \quad
(\pi_{1}{(\event_1)}, \pi_{2}{(\event_1)}) = ({x}_1, l_1)
\implies
(\pi_{1}{(\event_2)}, \pi_{2}{(\event_2)}) = ({x}_2, l_2)
 \\ \qquad \implies 
\eventdep^{val}(\event_1, \event_2, \cdot, c, D)
 \\ \qquad \implies
   \Big(\exists  n \in \mathbb{N}, z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}} \st 0 \leq n
 \land \flowsto(x_1^{l_1}, z_1^{r_1}, c) \land \cdots \land \flowsto(z_n^{r_n}, {x}_2^{l_2}, c) \Big)
\end{array}
\]
%
%
%
Unfolding $\eventdep^{val}_{\trace}(\event_1, \event_2, \cdot, c, D)$, we have:
\[
\exists \vtrace_0,
\vtrace_1, \vtrace_2' \in \mathcal{T}, \event_2' \in \eventset, \event_1' \in \eventset^{\asn}, {c}_1, {c}_2,  {c}_2'.
  \left(
  \begin{array}{ll}   
 & \config{{c}, \vtrace_0} \rightarrow^{*} 
\config{{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
  \config{{c}_2,  \vtrace_1 \cdot \event_1 \cdot \event_2 } 
  % 
 \\ 
 \bigwedge &
  \config{{c}_1, \vtrace_1 \cdot \event_1'}  \rightarrow^{*} 
  \config{{c}_2',  \vtrace_1 \cdot \event_1' \cdot \vtrace_2' \cdot \event_2' } 
\\
\bigwedge &  \pi_1(\event_1) = \pi_1(\event_2) \land \pi_2(\event_1) = \pi_2(\event_2) \\
\bigwedge & l_1 = \pi_2(\event_1) \land l_2 = \pi_2(\event_2)
\land \vcounter(\vtrace_1 \cdot \event_1) l_1 = \vcounter(\vtrace_1 \cdot \event_1')l_1 
\\
\bigwedge & 
\diff(\event_2,\event_2' ) \land 
\vcounter(\vtrace_1 \cdot \event_1 \cdot \event_2) l_2
= 
\vcounter(\vtrace_1 \cdot \event_1' \cdot \vtrace_2'\cdot \event_2') l_2\\
\end{array}
\right)
\]
By Inversion Lemma~\ref{lem:inv_asn} on 
 $\event_1$, $\event_2$ and following execution from $\eventdep^{val}_{\trace}(\event_1, \event_2, \cdot, c, D)$:
 %
 \[
 \config{{c}, \vtrace_0} \rightarrow^{*} 
\config{{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
  \config{{c}_2,  \vtrace_1 \cdot \event_1 \cdot \event_2 } 
 \]
 %
 we know $\exists \expr_1$ or $\qexpr_1$, $\exists \expr_2$ or $\qexpr_2$ and following instance of execution:
 \\
 \todo{notation $\assign{x}{\expr / \query(\qexpr)}$ denotes variable $x$ is assigned by either an expression $\expr$ or query $\query(\qexpr)$}
 %
\begin{equation}
\label{eq:valdep_inv1}
  \begin{array}{l}   
\config{{c}, \vtrace_0} \rightarrow^{*} 
\config{[\assign{{x}_1}{\expr_1 / \query(\qexpr_1)}]^{l_1} ; {c}_1, \vtrace_0 \cdot \vtrace_1}  
\rightarrow^{assn/query}
 \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1} \\
  \qquad \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_2, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1} 
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event_2} 
  % 
\end{array}
\end{equation}
%
%
By Inversion Lemma~\ref{lem:inv_asn} on 
$\event_2'$ and following execution from $\eventdep^{val}_{\trace}(\event_1, \event_2, \cdot, c, D)$,
\[
\config{{c}_1, \vtrace_1 \cdot \event_1'}  \rightarrow^{*} 
  \config{{c}_2',  \vtrace_1 \cdot \event_1' \cdot \vtrace_2' \cdot \event_2' } 
  \], we know $\exists \expr_2'$ or $\qexpr_2'$
 \[
  \begin{array}{l}   
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{*} 
  \config{[\assign{{x}_2'}{\expr_2' / \query(\qexpr_2')}]^{l_2'} ; {c}_2', \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \vtrace_2'} 
  \rightarrow^{assn/query} 
  \config{{c}_2',  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \vtrace_2' \cdot \event_2'} 
  % 
\end{array}
 \]
%
Unfolding $\diff(\event_2,\event_2')$, we have:
\[
  x_2 = x_2' \land l_2 = l_2' 
\] 
%
Then, we have:
\begin{equation}
\label{eq:valdep_inv2}
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2' / \query(\qexpr_2')}]^{l_2} ; {c}_2', \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \vtrace_2'} 
  \rightarrow^{assn/query} 
  \config{{c}_2',  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \vtrace_2' \cdot \event_2'} 
\end{equation}
%
From the $\eventdep^{val}_{\trace}(\event_1, \event_2, \cdot, c, D)$ definition, we also have:
\[
  \vcounter(\vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event_2) l_2 = 
  \vcounter(\vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \vtrace_2' \cdot \event_2') l_2'
  \land 
  \pi_2(\event_1) = \pi_2(\event_1')
\] 
Then, we have:
\begin{equation}
\label{eq:valdep_invn}
  \vcounter(\vtrace_2') l_2 = 0
\end{equation}
%
 %
%
%
 By Induction on the operational semantics rules on following execution from Eq.~\ref{eq:valdep_inv1}:
 %
 \[\config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1}
  \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_2, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1} \]
 %
 we know by  \todo{Inversion Lemma: no event generated, iff the program is $\eskip$}, \todo{notation $[\eskip]{}^*$}:
 \[
 c_1 =_c 
 [\eskip]{}^*;[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_2
 \]
 %
 %
The following subproof shows there is only 1 possible execution instance of Eq.~\ref{eq:valdep_inv2}.
\begin{subproof}[Subproof]
\label{pf:noiteration_inv2}
There are two possible cases, 
where $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_2$ 
or $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \notin_c c_2$.
%
\begin{enumerate}
\item{$[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2}\notin_c c_2$}
\\
By substituting $c_1$ in the execution in Eq.~\ref{eq:valdep_inv2}, we have 
\todo{notation $\rightarrow^{\eskip^*}$ denotes evaluations of $\eskip$ command 0 for more times}
 %
  \[
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip^*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} ; {c}_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event_2'} 
 \]
%
\item{$[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_2$}
\\
\todo{Inversion lemma}, it must be in a while body.
\\
 By substituting $c_1$ in the execution in Eq.~\ref{eq:valdep_inv2}, we have following possible execution instances:
 %
  \[
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip^*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} ; {c}_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot (x_2, l_2, n_2', v_2')} 
 \]
%
  \[
  \begin{array}{l}
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip^*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} ; {c}_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot (x_2, l_2, n_2', v_2')} 
  \\ \qquad
  \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} ; {c}_2, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot (x_2, l_2, v_2') \cdot \trace_3} 
  \\ \qquad
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot (x_2, l_2, n_2', v_2') \cdot \trace_3 \cdot (x_2, l_2, n_2'', v_2'')} 
 \end{array}
 \]
\[
  \cdots
\] 
with iterations of the while body in $c_2$ $0$ or more times.
%
\\
%
For each execution instance, we have the corresponding instance of $\trace_2'$ as follows:
\\
  $\trace_2'  = \cdot$
\\
$\trace_2' = \cdot (x_2, l_2, n_2', v_2') \cdot \trace_3 $
%
\\
$\cdots$
%
\\
%
By Eq.~\ref{eq:valdep_invn}, we know:
%
\[
 \vcounter(\trace_2') l_2 = 0
\]
%
Only the first execution with 0 iteration of while body in $c_2$ satisfy this restriction, i.e., $\trace_2' = \cdot$ and $\event_2' = (x_2, l_2, n_2', v_2')$
%
\end{enumerate}
In conclusion, we have the execution instance of \ref{eq:valdep_inv2}  as follows and $\trace_2' = \cdot$.
  \[
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip^*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} ; {c}_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot (x_2, l_2, n_2', v_2')} 
 \]
\end{subproof}
%
By $\eventdep^{val}(\event_1, \event_2, c)$, and definition of environment, 
the environment only able to obtain different values for variable $x_1$ 
from trace $\vtrace_0 \cdot \vtrace_1 \cdot \event_1$ and 
$\vtrace_0 \cdot \vtrace_1 \cdot \event_1'$, i.e.,
\[
  \forall z^r \in \lvar_c \setminus \{x_1^{l_1}\} ,
  \env(\vtrace_0 \cdot \vtrace_1 \cdot \event_1) (z) =  
  \env(\vtrace_0 \cdot \vtrace_1 \cdot \event_1') (z)
\]
%
By {Inversion Lemma~\ref{lem:inv_a}} of arithmetic expression evaluation, and Inversion Lemma~\ref{lem:inv_live}, we have 
\[
  x_1 \in VAR(\expr_2 / \qexpr_2) 
  \land x_1^{l_1} \in \live^{l_2}(c)
\]
%
By $\flowsto$ definition, we have:
%
\[
\flowsto(x_1^{l_1}, {x}_2^{l_2}, c)
\]
i.e.,
%
\[
\Big(\exists z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}} \st (0 \leq n )
 \land \flowsto(x_1^{l_1}, z_1^{r_1}, c) \land \cdots \land \flowsto(z_n^{r_n}, {x}_2^{l_2}, c) \Big)
 \]
%
This case is proved.
\end{case}
%
\begin{case}[$P(\trace_{ih} \cdot \event_{ih})$]
\label{case:valdep_ih}.
\begin{subcase}[$\neg \eventdep^{val}(\event_1, \event_{ih}, \trace_{ih}, c, D) \land  \neg\eventdep^{\ctl}(\event_1, \event_{ih}, \trace_{ih}, c, D) $]
\label{case:valdep_ihindep}.
\end{subcase}
\begin{subcase}[$\eventdep^{val}(\event_1, \event_{ih}, \trace_{ih}, c, D) \lor \eventdep^{\ctl}(\event_1, \event_{ih}, \trace_{ih}, c, D) $]
\label{case:valdep_ihdep}.
\begin{subsubcase}[$\event_{ih} \in \eventset^{\asn}$].
\label{case:valdep_ihdepasn}.
\begin{subsubsubcase}[$\eventdep^{val}(\event_{ih}, \event_2, \cdot, c, D)$]
ih
\end{subsubsubcase}
\begin{subsubsubcase}[$\neg\eventdep^{val}(\event_{ih}, \event_2, \cdot, c, D)$]
Proved in the same way as Case.~\ref{case:valdep_ihindep}.
\end{subsubsubcase}
\end{subsubcase}
\begin{subsubcase}[$\event_{ih} \in \eventset^{\test}$].
\begin{subsubsubcase}[$\eventdep^{\ctl}(\event_1, \event_{ih}, \trace_{ih}, c, D)$]
Proved in the same way as Case.~\ref{case:valdep_ihindep}.
\end{subsubsubcase}
\begin{subsubsubcase}[$\eventdep^{val}(\event_1, \event_{ih}, \trace_{ih}, c, D)$]
proved 
\end{subsubsubcase}
\end{subsubcase}
\end{subcase}
\end{case}
\begin{case}[$P(\trace_{ih} \cdot \event_{ih})$]
\label{case:valdep_ih}.
\\
%
By $P(\trace_{ih} \cdot \event_{ih})$, the statement needed to be proved is:
$$
\begin{array}{l}
\forall {x}_1^{l_1}, {x}_2^{l_2} \in \lvar_{{c}}, \trace_{ih}' \subseteq \trace_{ih},
\event_1, \event_2 \in \eventset^{\asn}, D \in \dbdom \st
\\ \quad
(\pi_{1}{(\event_1)}, \pi_{2}{(\event_1)}) = ({x}_1, l_1)
\implies
(\pi_{1}{(\event_2)}, \pi_{2}{(\event_2)}) = ({x}_2, l_2)
 \\ \qquad \implies 
\eventdep^{val}(\event_1, \event_2, \trace_{ih}', c, D)
 \\ \qquad \implies
   \Big(\exists  n \in \mathbb{N}, z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}} \st 0 \leq n
 \land \flowsto(x_1^{l_1}, z_1^{r_1}, c) \land \cdots \land \flowsto(z_n^{r_n}, {x}_2^{l_2}, c) \Big)
\\ \quad \implies
\forall {x}_1^{l_1}, {x}_2^{l_2} \in \lvar_{{c}},
\event_1, \event_2 \in \eventset^{\asn}, D \in \dbdom \st
\\ \quad
(\pi_{1}{(\event_1)}, \pi_{2}{(\event_1)}) = ({x}_1, l_1)
\implies
(\pi_{1}{(\event_2)}, \pi_{2}{(\event_2)}) = ({x}_2, l_2)
 \\ \qquad \implies 
\eventdep^{val}(\event_1, \event_2, \trace_{ih} \cdot \event_{ih}, c, D)
 \\ \qquad \implies
   \Big(\exists  n \in \mathbb{N}, z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}} \st 0 \leq n
 \land \flowsto(x_1^{l_1}, z_1^{r_1}, c) \land \cdots \land \flowsto(z_n^{r_n}, {x}_2^{l_2}, c) \Big)
\end{array}
$$
%
\begin{subcase}[$\neg \eventdep^{val}(\event_1, \event_{ih}, \trace_{ih}, c, D) \land  \neg\eventdep^{\ctl}(\event_1, \event_{ih}, \trace_{ih}, c, D) $]
\label{case:valdep_ihindep}.
\\
Let $\event_{ih} = (z_{ih}, l_{ih}, n_{ih}, v_{ih})$, 
%
By Inversion Lemma~\ref{lem:inv_asn} on $\event_1$, $\event_{ih}$ and $\event_2$ in execution Eq.~\ref{eq:valdep_inv1}, we have following execution:
\begin{equation}
\label{eq:m1asn_inv1}
  \begin{array}{l}   
\config{{c}, \vtrace_0} \rightarrow^{*} 
\config{[\assign{{x}_1}{\expr_1 / \query(\qexpr_1)}]^{l_1} ; {c}_1, \vtrace_0 \cdot \vtrace_1}  \rightarrow^{assn/query}
 \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1} \\
  \qquad \rightarrow^{*} 
  \config{[\assign{z_{ih}}{\expr_{ih} / \query(\qexpr_{ih})}]^{l_{ih}};{c}_2, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \tracecat \trace_{ih}} 
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \tracecat \trace_{ih} \cdot \event_{ih}}  \\
  \qquad \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_3, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1  \tracecat \trace_{ih} \cdot \event_{ih}} 
  \rightarrow^{assn/query} 
  \config{{c}_3,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1  \tracecat \trace_{ih} \cdot \event_{ih} \cdot \event_2} 
  % 
\end{array}
 \end{equation}
By conclusion from Case.~\ref{case:valdep_base}, we know:
\[
 c_2 =_c [\eskip]{}^*; [\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_3
 \]
 %
%
% \begin{subsubsubcase}[$\neg \eventdep^{val}(\event_1, \event_{ih}, c, D) $].
\\
By inversion on $\event_{ih}$ and $\neg \eventdep^{val}(\event_1, \event_{ih}, \trace_{ih}, c, D) \land  \neg\eventdep^{\ctl}(\event_1, \event_{ih}, \trace_{ih}, c, D) $,
we have following execution from Eq.~\ref{eq:valdep_inv2}:
\begin{equation}
\label{eq:m1asn_inv2}
  \begin{array}{l}   
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{*} 
  \config{[\assign{z_{ih}}{\expr_z / \query(\qexpr_z)}]^{l_{ih}};{c}_2, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \tracecat \trace_{ih}'} 
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1'  \tracecat \trace_{ih}' \cdot \event_{ih}}  \\
  \qquad \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_3, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1'  \tracecat \trace_{ih}' \cdot \event_{ih}' \tracecat \trace_{ih2}} 
  \rightarrow^{assn/query} 
  \config{{c}_3,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1'  \tracecat \trace_{ih}' \cdot \event_{ih}' \tracecat \trace_{ih2} \cdot \event_2'} 
\end{array}
 \end{equation}
 %
and
 %
 \[
 \vcounter(\trace_{ih}) l_2 = \vcounter(\trace_{ih}'\tracecat \trace_{ih2}) l_2
 \]
 %
By substituting $c_2$  in execution above, 
we have following instances of executions for Eq.~\ref{eq:valdep_inv2}, 
%  and conclusion from Subproof~\ref{pf:noiteration_inv2}, we know the only possible execution satisfying:
%  \[
%   \vcounter(\vtrace_2') l_2 = \vcounter(\event_{ih}) l_2
% \]
% %
%  is as follows, where $\trace_2' = \event_{ih}'$.
%  %
%
\begin{equation}
\label{eq:m1asn_inv2}
  \begin{array}{l}   
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{*} 
  \config{[\assign{z_{ih}}{\expr_z / \query(\qexpr_z)}]^{l_{ih}};{c}_2, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \tracecat \trace_{ih}'} 
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1'  \tracecat \trace_{ih}' \cdot \event_{ih}'}  \\
  \qquad \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_3, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1'  \tracecat \trace_{ih}' \cdot \event_{ih}'} 
  \rightarrow^{assn/query} 
  \config{{c}_3,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1'  \tracecat \trace_{ih}' \cdot \event_{ih}' \cdot \event_2'} 
\end{array}
 \end{equation}
 or 
 %
\[
  \begin{array}{l}   
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{*} 
  \config{[\assign{z_{ih}}{\expr_z / \query(\qexpr_z)}]^{l_{ih}};{c}_2, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \tracecat \trace_{ih}'} 
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1'  \tracecat \trace_{ih}' \cdot \event_{ih}'}  \\
  \qquad \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_3, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1'  \tracecat \trace_{ih}' \cdot \event_{ih}' \tracecat \trace_{ih2}} 
  \\ \qquad
  \rightarrow^{assn/query} 
  \config{{c}_3,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1'  \tracecat \trace_{ih}' \cdot \event_{ih}' \cdot (z_{ih1}, l_{ih}, n_{ih1}, v_{ih1})} 
  \\ \qquad
  \rightarrow^{*} 
  \config{[\assign{z_{ih}}{\expr_z / \query(\qexpr_z)}]^{l_{ih}};{c}_2, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \tracecat \trace_{ih}' \cdot \event_{ih}' \cdot (z_{ih1}, l_{ih}, n_{ih1}, v_{ih1}) \tracecat \trace_{ih}''} 
  \\ \qquad
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1'  \tracecat \trace_{ih}' \cdot \event_{ih}' \cdot (z_{ih1}, l_{ih}, n_{ih1}, v_{ih1}) \tracecat \trace_{ih}'' \cdot \event_{ih}''}  
  \\
  \qquad \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_3, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1'  \tracecat \trace_{ih}' \cdot \event_{ih}' \cdot (z_{ih1}, l_{ih}, n_{ih1}, v_{ih1}) \tracecat \trace_{ih}'' \cdot \event_{ih}''} 
  \\ \qquad
  \rightarrow^{assn/query} 
  \config{{c}_3,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \tracecat \trace_{ih}' \cdot \event_{ih}' \cdot (z_{ih1}, l_{ih}, n_{ih1}, v_{ih1}) \tracecat \trace_{ih}'' \cdot \event_{ih}''\cdot \event_2'} 
\end{array}
\]
%
 \[\cdots\]
 %
 if $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_3$ and the execution involves 1 or more iterations of $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2}$.
 %
 By conclusion from the Subproof.~\ref{pf:noiteration_inv2} in Case.~\ref{case:valdep_base} and restriction from Eq.~\ref{eq:valdep_invn}, 
 we know the only possible instance for execution Eq.~\ref{eq:valdep_inv2} is Eq.~\ref{eq:m1asn_inv2},
 %
 where $\event_{ih} \eventeq \event_{ih}'$, $\trace_{ih2} = \cdot$ and
 %
 \[
 \vcounter(\trace_{ih}) l_2 = \vcounter(\trace_{ih}') l_2
 \]
%
%
Let $\eventset_{diff} \subseteq \eventset $ such that $\forall \event_i \in \eventset$, $\event_i \in \eventset_{diff}$ iff:
\begin{equation}
\label{eq:valdep_ihdiff}
  \begin{array}{l}
  \exists \trace_{ih1}, \trace_{ih2}, \trace_{ih1}', \trace_{ih2}' \in \mathcal{T},
  \st 
  \vcounter (\trace_{ih1} )\pi_2({\event_i}) = \vcounter(\trace_{ih1}') \pi_2(\event_i) \land
  \vcounter (\trace_{ih2} )\pi_2({\event_i}) = \vcounter(\trace_{ih2}') \pi_2(\event_i) = 0
  \land
  \\ \quad \exists \event_i' \in \eventset^{\asn}  \st
  \diff(\event_i, \event_i') \land 
  \trace_{ih} = \trace_{ih1} \cdot \event_i \tracecat \trace_{ih2} 
  \land 
  \trace_{ih} = \trace_{ih1}' \cdot \event_i' \tracecat \trace_{ih2}'
  \\ \qquad \lor 
  \trace_{ih} = \trace_{ih1} \cdot \event_i \tracecat \trace_{ih2} 
  \land 
  \trace_{ih} = \trace_{ih1}' \tracecat \trace_{ih2}'
  \\ \qquad \lor 
  \trace_{ih} = \trace_{ih1} \tracecat \trace_{ih2} 
  \land 
  \trace_{ih} = \trace_{ih1}' \cdot \event_i \tracecat \trace_{ih2}'
  \end{array}
\end{equation}
%
\\
By Definition~\ref{def:event_valdep} and \todo{CLT definition needs to be modified \ref{def:event_ctldep}}, we know
\[
  \forall \event_i \in \eventset_{diff} \st \exists \trace_{ihi} \in \mathcal{T} \st
  \eventdep^{val}(\event_1, \event_i, \trace_{ihi}, c, D) 
  \lor \eventdep^{\ctl}(\event_1, \event_i, \trace_{ihi}, c, D)
\]
Let $V_{diff} = VAR(\eventset_{diff} \subseteq \lvar_c$ such that $\forall z_i^{r_i} \in \lvar_c$, $z_i^{r_i} \in V_{diff}$ iff:
\[
  \exists \event_i \in \event_{diff} \st \pi_1(\event_i), \pi_2(\event_i) = z_i, r_i
\]
Then, by induction hypothesis, $\forall z_i^{r_i} \in V_{diff}$, we have:
\[
  \bigwedge_{z_i^{r_i} \in V_{diff}}
  \exists y_1, \cdots, y_m \st 
  m \geq 0 \land
  \flowsto(x_1^{l_1}, y_1^{r_1}, c) \land \cdots \land \flowsto(y_m^{r_m}, z_i^{r_i}, c) \land 
\]
%
%
By Eq.~\ref{eq:valdep_ihdiff}, we know 
the environment only able to obtain different values for variables in $V_{diff}$ or variable $x_1$
from trace $\vtrace_0 \cdot \vtrace_1 \cdot \event_1' \tracecat \trace_{ih}' \cdot \event_{ih}' \tracecat \trace_{ih2}$ 
and 
$\vtrace_0 \cdot \vtrace_1 \cdot \event_1' \tracecat \trace_{ih} \cdot \event_{ih}$, i.e.,
 i.e., 
\[
\begin{array}{l}
  \big(\forall u^r \in \lvar_c \setminus (V_{diff} \cup \{x_1^{l_1}\}) \st
    \env(\vtrace_0 \cdot \vtrace_1 \cdot \event_1' \tracecat \trace_{ih}' \cdot \event_{ih}' \tracecat \trace_{ih2}) (u) =  
    \env(\vtrace_0 \cdot \vtrace_1 \cdot \event_1 \tracecat \trace_{ih} \cdot \event_{ih}) (u)
    \big)
  \end{array}
\]
%
%
By {Inversion Lemma~\ref{lem:inv_a}} of arithmetic expression evaluation, we have: 
%
\[
  \bigvee_{z_i^{r_i} \in V_{diff}} z_i \in VAR(\expr_2)
  \bigwedge_{z_i^{r_i} \in V_{diff}} (z_i^{r_i} \in \live^{l_2}(c))
\]
%
By Eq.~\ref{eq:valdep_ihdiff}, we also have:
\[
   \forall u^r \in V_{diff} \st r = \llabel(\vtrace_0 \cdot \vtrace_1 \cdot \event_1' \tracecat \trace_{ih}' \cdot \event_{ih}' \tracecat \trace_{ih2}) u
\]
%
Then by Inversion Lemma~\ref{lem:inv_live}, we have:
\[
  \bigwedge_{z_i^{r_i} \in V_{diff}} (z_i^{r_i} \in \live^{l_2}(c))
\]
%
By Definition of $\flowsto$, we know
\[
   \bigvee_{z_i^{r_i} \in V_{diff}}  \flowsto(z_i^{r_i}, x_2^{l_2}, c)
\]
%
%
%
Then, we have
\[
  \bigwedge_{z_i^{r_i} \in V_{diff}}
  \exists y_1, \cdots, y_m \st 
  m \geq 0 \land
  \flowsto(x_1^{l_1}, y_1^{r_1}, c) \land \cdots \land \flowsto(y_m^{r_m}, z_i^{r_i}, c) \land 
   \bigvee_{z_i^{r_i} \in V_{diff}}  \flowsto(z_i^{r_i}, x_2^{l_2}, c)
\]
i.e.,
\[
\Big(\exists z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}} \st (0 \leq n  )
 \land \flowsto(x_1^{l_1}, z_1^{r_1}, c) \land \cdots \land \flowsto(z_n^{r_n}, {x}_2^{l_2}, c) \Big)
\]
This case is proved.
\end{subcase}
%
\begin{subcase}[$\eventdep^{val}(\event_1, \event_{ih}, \trace_{ih}, c, D) \lor \eventdep^{\ctl}(\event_1, \event_{ih}, \trace_{ih}, c, D) $]
\label{case:valdep_ihdep}.
\\
There are 2 sub-cases: 
%
 \[
 \big(\event_{ih} \in \eventset^{\test}\big) \lor \big(\event_{ih} \in \eventset^{\asn}\big)
 \]
%
This case is proved by splitting the 2 sub-cases.
\begin{subsubcase}[$\event_{ih} \in \eventset^{\asn}$].
\label{case:valdep_ihdepasn}.
\begin{subsubsubcase}[$\eventdep^{val}(\event_{ih}, \event_2, \cdot, c, D)$].
\\
Consider trace $\trace_{ih} \subseteq \trace_{ih}$,  $\event_1, \event_{ih} \in \eventset$, 
$\pi_1(\event_1), \pi_2(\event_1) = (x_1, l_1)$, $\pi_1(\event_{ih}), \pi_2(\event_{ih}) = (z_{ih}, l_{ih})$ and
$\eventdep^{val}(\event_1, \event_{ih}, \trace_{ih}, c, D) \lor \eventdep^{\ctl}(\event_1, \event_{ih}, \trace_{ih}, c, D) $, 
 %
We have following conclusion from the induction hypothesis:
%
\[
\Big(\exists z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}} \st \flowsto(x_1^{l_1}, z_1^{r_1}, c) \land \cdots \land \flowsto(z_n^{r_n}, z_{ih}^{l_{ih}}, c) \Big)
\]
%
By induction hypothesis from Case.~\ref{case:valdep_base}, on trace $\event_{ih}$ and $\eventdep^{val}(\event_{ih}, \event_2, c, D)$,
 %
we also have:
\[
\Big( \flowsto(z_{ih}^{l_{ih}}, {x}_2^{l_2}, c) \Big)
\]
%
Then, we have
%
\[
\Big(\exists z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}} \st  0 \leq n \land
 \flowsto(x_1^{l_1}, z_1^{r_1}, c) \land \cdots \land \flowsto(z_n^{r_n}, z_{ih}^{l_{ih}}, c)
  \Big)\land \flowsto(z_{ih}^{l_{ih}}, {x}_2^{l_2}, c)
\]
%
i.e.,
\[
\exists z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}} \st 1 \leq n \land \flowsto(x_1^{l_1}, z_1^{r_1}, c) \land \cdots 
\land \flowsto(z_n^{r_n}, {x}_2^{l_2}, c)
% \land \flowsto(z_n^{r_n}, z_{ih}^{l_{ih}}, c)
%  \land \flowsto(z_{ih}^{l_{ih}}, {x}_2^{l_2}, c) 
\]
%
This case is proved.
\end{subsubsubcase}
\begin{subsubsubcase}[$\neg\eventdep^{val}(\event_{ih}, \event_2, \cdot, c, D)$].
\\
Proved in the same way as Case.~\ref{case:valdep_ihindep}.
\end{subsubsubcase}
\end{subsubcase}
\begin{subsubcase}[$\event_{ih} \in \eventset^{\test}$].
\begin{subsubsubcase}[$\eventdep^{\ctl}(\event_1, \event_{ih}, \trace_{ih}, c, D)$].
\\
Proved in the same way as Case.~\ref{case:valdep_ihindep}.
\end{subsubsubcase}
\begin{subsubsubcase}[$\eventdep^{val}(\event_1, \event_{ih}, \trace_{ih}, c, D)$].
\\
Let $\event_{ih} = (b, l_b, n_b, v_b)$, by Eq.~\ref{eq:valdep_inv1} and {Inversion Lemma~\ref{lem:inv_test}}, we have:
\begin{equation}
\label{eq:m1test_inv1}
  \begin{array}{l}   
\config{{c}, \vtrace_0} \rightarrow^{*} 
\config{[\assign{{x}_1}{\expr_1 / \query(\qexpr_1)}]^{l_1} ; {c}_1, \vtrace_0 \vtrace_1}  
\rightarrow^{assn/query}
 \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1} 
 \\
  \qquad \rightarrow^{*} 
  \config{\eif ([b]^{l_b}, c_t, c_f) / \ewhile [b]^{l_b} \edo c_w;{c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1 \tracecat \trace_{ih}} 
 \rightarrow^{if-b / while-b} 
  \config{c_3, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \tracecat \trace_{ih} \cdot \event_{ih}} 
  \\
  \qquad   \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \tracecat \trace_{ih} \cdot \event_{ih}} 
  \rightarrow^{assn/query} 
  \config{{c}_4,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1  \tracecat \trace_{ih} \cdot \event_{ih} \cdot \event_2} 
  % 
\end{array}
\end{equation}
 By induction on operational semantics rules and the evaluations: 
 \todo{Inversion Lemma: no event generated, iff the program is $\eskip$}
 \[
 \config{c_3, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \tracecat \trace_{ih} \cdot \event_{ih}} 
  \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \tracecat \trace_{ih} \cdot \event_{ih}} 
 \]
 we know:
  \[
 c_3 =_c 
 [\eskip^*]; [\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4
 \]
\label{case:valdep_ihtestdep}
\\
%
By induction hypothesis on $\eventdep^{val}(\event_1, \event_{ih}, \trace_{ih}, c, D)$, we know:
%
\begin{equation}
\label{eq:valdep_ihtestb}
  \bigvee_{\{y_i^{r_i} \vert y \in VAR(b) \land r_i = \llabel(\trace_{ih}) y_i\}}
  \exists z_1^{j_1} \cdots z_m^{j_m}, m \in \mathbb{N} \st 
  \flowsto(x_1^{l_1}, z_1^{j_1}) \cdots \flowsto(z_m^{j_m}, y_i^{r_i})
\end{equation}
%
By execution Eq.~\ref{eq:m1test_inv1} and $\eventdep^{val}(\event_1, \event_{ih}, c, D)$ we have following execution instance of Eq.~\ref{eq:valdep_inv2},
 %
\begin{equation}
\label{eq:m1test_inv2}
  \begin{array}{l}   
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{*} 
  \config{\eif ([b]^{l_b}, c_t, c_f) / \ewhile [b]^{l_b} \edo c_w ; {c}_2', \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \tracecat \trace_{ih}'} 
  \rightarrow^{if / while} 
  \config{c_3', \vtrace_0 \cdot \vtrace_1 \cdot \event_1'  \tracecat \trace_{ih}' \cdot \event_{ih}'} 
  \\
  \qquad \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4', 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event_{ih}' \cdot \trace_3}
  \rightarrow^{assn/query} 
  \config{{c}_4',  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \tracecat \trace_{ih}' \cdot \event_{ih}' \tracecat \trace_{ih2} \cdot \event_2'} 
\end{array}
\end{equation}
 %
where 
\[
  \event_{ih} \eventeq \event_{ih}' \lor \diff(\event_{ih}, \event_{ih}')
\]
%
Case of $\event_{ih} \eventeq \event_{ih}'$ is proved in the same way in Case.~\ref{case:valdep_ihtestnodep}.
%
By Eq.~\ref{eq:valdep_invn}, we know:
%
\[
\vcounter(\trace_{ih}' \cdot \event_{ih}' \tracecat \trace_{ih2}) l_2  = \vcounter(\trace_{ih}) l_2 
 \]
%
\\
Case of $\diff(\event_{ih}, \event_{ih}')$ is proved by splitting two following cases:
\[
  c_1 =_c \eif ([b]^{l_b}, c_t, c_f);{c}_2
  \lor
  c_1 =_c \ewhile [b]^{l_b} \edo c_w;{c}_2
\]
\begin{subproof}[\textbf{Subsubsub-case}:] 
%
$c_1 =_c \eif ([b]^{l_b}, c_t, c_f);{c}_2$ 
\\
Without loss of generalization, 
let $\event_{ih} = (b, l_b, n_b, \etrue)$ and
$\event_{ih}' = (b, l_b, n_b, \efalse)$,
by execution Eq.~\ref{eq:m1test_inv1} and $\event_{ih} = (b, l_b, n_b, \etrue)$, we have:
\[
  \begin{array}{l}   
  \config{{c}, \vtrace_0} \rightarrow^{*} 
  \config{[\assign{{x}_1}{\expr_1 / \query(\qexpr_1)}]^{l_1} ; {c}_1, \vtrace_0 \vtrace_1}  
  \rightarrow^{assn/query}
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1} 
  \\
  \qquad \rightarrow^{*} 
  \config{\eif ([b]^{l_b}, c_t, c_f);{c}_2, \vtrace_0 \vtrace_1 \cdot \event_1} 
  \rightarrow^{if-t} 
  \config{c_t;c_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event_{ih}} 
  \\
  \qquad \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event_{ih}} 
  \rightarrow^{assn/query} 
  \config{{c}_4,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event_{ih} \cdot \event_2} 
  % 
  \end{array}
\]
and 
\[
  c_t;c_2 =_c [\eskip^*]; [\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4
\]
%
By execution in Eq.~\ref{eq:valdep_inv2} and $\event_{ih}' = (b, l_b, n_b, \efalse)$, we have:
 %
\begin{equation}
\label{eq:m1testif_inv2}
  \begin{array}{l}   
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip^*} 
  \config{\eif ([b]^{l_b}, c_t, c_f); {c}_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{if-f} 
  \config{c_f;c_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event_{ih}'} 
  \\
  \qquad \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4', 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event_{ih}' \cdot \trace_2'}
  \rightarrow^{assn/query} 
  \config{{c}_4',  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event_{ih}' \cdot \trace_2' \cdot \event_2'} 
\end{array}
\end{equation}
 %
%
 By uniqueness of label, we have following cases:
 \begin{enumerate}
 \item $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_t$:
\\
By definition of $\lvar$, we know:
\[
  x_2^{l_2} \in \lvar_{c_t}
\]
%
 By uniqueness of program label, we have:
 \[
 [\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \notin_c c_f
 \]
 %
 If $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \notin_c c_2$,
 %
we know $\forall \trace, \trace' \in \mathcal{T}$, there doesn't exist execution
 \[
  \config{c_f;c_2, \vtrace} \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4', \trace'}
 \]
 This is contradict to the existence of execution in Eq.\ref{eq:m1testif_inv2}.
 \\
 If $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_2$, 
 by uniqueness of label \todo{Inversion Lemma}, 
 it must exist in the body of a while command in $c_2$,
 and $\eif ([b]^{l_b}, c_t, c_f) \in_c c_2$ and $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_t$. 
 %
\\
%
i.e., $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2}$ will only show up in $c_t$.
\\
%
By $\flowsto$ definition, we have:
\[
  \forall z_i^{r_i} \in \lvar_{c_t},  x_j^{l_j} \in \lvar_c \st x_j \in VAR(b) \land l_j = \llabel(\trace_{ih}) x_j \implies
  \flowsto(x_j^{l_j}, z_i^{r_i}, c)
\]
i.e.,
\[
  \bigwedge_{\{ x_j^{l_j} \in \lvar_c \vert x_j \in VAR(b) \land x_j^{l_j} \in \live^{l_b}(c)\}}
  \flowsto(x_j^{l_j}, x_2^{l_2}, c)
\]
%
Based on Eq.~\ref{eq:valdep_ihtestb}, we know:
%
\[
  \bigvee_{\{y_i^{r_i} \vert y_i \in VAR(b) \land r_i = \llabel(\trace_{ih}) y_i\}}
  \exists z_1^{j_1} \cdots z_m^{j_m}, m \in \mathbb{N} \st 
  \flowsto(x_1^{l_1}, z_1^{j_1}) \land \cdots \land  \flowsto(z_m^{j_m}, y_i^{r_i})
  \land \flowsto(y_i^{r_i}, x_2^{l_2}, c) 
\]
%
i.e.,
\[
\Big(\exists z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}} \st 0 \leq n 
 \land \flowsto(x_1^{l_1}, z_1^{r_1}, c) \land \cdots \land \flowsto(z_n^{r_n}, {x}_2^{l_2}, c) \Big)
\]
%
This case is proved.
\item $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \notin_c c_t$:
\begin{enumerate}
 \item $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_f$:
 \\
 This case is symmetrical to the case $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_t$ and proved in the same way
 \item $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \notin_c c_f$:
 \\
 Then we know $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_2$.
 \\
 By
 \[
  c_t;c_2 =_c [\eskip^*]; [\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4
\]
we know:
\[
  c_t = [\eskip^*]; \land c_2 = [\eskip^*]; [\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4
\]
Substituting $c_2$ in the execution in Eq.\ref{eq:m1testif_inv2}, by the restriction:
\[
  \vcounter(\trace_3)l_2 = 0
\]
we have the following execution as the only possible instance of Eq.~\ref{eq:m1testif_inv2} from the conclusion in Subproof~\ref{pf:noiteration_inv2}, where $\trace_3 = \trace_f$ 
and $\trace_2' = {} \cdot {} \event_{ih}' \cdot \trace_f$ in Eq.~\ref{eq:valdep_inv2}.
\[
    \begin{array}{l}   
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip^*} 
  \config{\eif ([b]^{l_b}, c_t, c_f); {c}_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{if-f} 
  \config{c_f;c_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event_{ih}'} 
  \\
  \qquad \rightarrow^{*} 
  \config{c_2, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event_{ih}' \cdot \trace_f}
  \\
  \qquad \rightarrow^{\eskip*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event_{ih}' \cdot \trace_f}
  \rightarrow^{assn/query} 
  \config{{c}_4,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event_{ih}' \cdot \trace_f \cdot \event_2'} 
\end{array}
\]
and \todo{Inversion Lemma, notation $VAR{(\trace)}$ denotes the labeled variables in $\trace$}
\[
  VAR{(\trace_f)} \subseteq \lvar_{c_f}
\]
%
By $\flowsto$ definition, we have:
\[
  \forall z_i^{r_i} \in \lvar_{c_f},  x_j^{l_j} \in \lvar_c \st x_j \in VAR(b) \land l_j = \llabel(\trace_{ih}) x_j \implies
  \flowsto(x_j^{l_j}, z_i^{r_i}, c)
\]
% i.e.,
% \[
%   \bigwedge_{\{ x_j^{l_j} \in \lvar_c \vert x_j \in VAR(b) \land x_j^{l_j} \in \live^{l_b}(c)\}}
%   \flowsto(x_j^{l_j}, x_2^{l_2}, c)
% \]
%
Based on Eq.~\ref{eq:valdep_ihtestb}, we know:
%
\[
  \bigvee_{\{y_i^{r_i} \vert y_i \in VAR(b) \land r_i = \llabel(\trace_{ih}) y_i\}}
  \exists z_1^{j_1} \cdots z_m^{j_m}, m \in \mathbb{N} \st 
  \flowsto(x_1^{l_1}, z_1^{j_1}) \land \cdots \land  \flowsto(z_m^{j_m}, y_i^{r_i})
  \bigwedge_{z_i^{r_i} \in \lvar_{c_f}}
    \flowsto(y_i^{r_i}, z_i^{r_i}, c) 
\]
%
By Inversion Lemma~\ref{lem:inv_a} on evaluation of expression $\expr_2$ and following: 
\[
  \forall z \in \lvar \setminus (\{x_1^{l_1}\} \cup VAR{(\trace_f)}) \st
  \env(\vtrace_0 \cdot \vtrace_1 \cdot \event_1' \tracecat \trace_{ih}' \cdot \event_{ih}' \cdot \trace_f)(z) 
  = \env(\vtrace_0 \cdot \vtrace_1 \cdot \event_1 \tracecat \trace_{ih} \cdot \event_{ih})(z)
\]
%
we have:
\[
  x_1 \in VAR(\expr_2) \bigvee_{z_i^{r_i} \in VAR{(\trace_f)}} z_i \in VAR(\expr_2)
\]
%
Let $S = (\{x_1^{l_1}\} \cup VAR{(\trace_f)}) \cap \live^{l_2}(c) $
%
By $\flowsto$ definition, we have:
\[
   \bigvee_{z_i^{r_i} \in S}  \flowsto(z_i^{r_i}, x_2^{l_2}, c)
\]
By $ \bigwedge_{\forall z_i^{r_i} \in \lvar_{c_f}} \flowsto(x_1^{l_1}, z_i^{r_i}, c)$ and $S \subseteq VAR{(\trace_f)} \subseteq \lvar_{c_f}$, we have:
\[
\bigvee_{z_i^{r_i} \in S} 
(\flowsto(x_1^{l_1}, z_i^{r_i}) \land \flowsto(z_i^{r_i}, x_2^{l_2}))
\]
%
i.e.,
\[
\Big(\exists z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}} \st 0 \leq n 
 \land \flowsto(x_1^{l_1}, z_1^{r_1}) \land \cdots \land \flowsto(z_n^{r_n}, {x}_2^{l_2}) \Big)
\]
%
This case is proved.
\end{enumerate}
%
\end{enumerate}
%
This case is proved.
\end{subproof}
%
\begin{subproof}[\textbf{subsubsub-case}:] $c_1 =_c \ewhile [b]^{l_b} \edo c_w;{c}_2$ 
%
\\
There are 2 cases:
$$
\Big(\event_{ih} = (b, l_b, n_b, \etrue) \land \event_{ih}' = (b, l_b, n_b, \efalse) \Big)
\lor 
\Big(\event_{ih} = (b, l_b, n_b, \efalse) \land \event_{ih}' = (b, l_b, n_b, \etrue) \Big)
$$
%
\textbf{subsubsubsub-case:} $\event_{ih} = (b, l_b, n_b, \etrue) \land \event_{ih}' = (b, l_b, n_b, \efalse)$
\\
By execution in Eq.~\ref{eq:m1test_inv1} and $\event_{ih} = (b, l_b, n_b, \etrue)$, we have:
\[
  \begin{array}{l}   
  \config{{c}, \vtrace_0} \rightarrow^{*} 
  \config{[\assign{{x}_1}{\expr_1 / \query(\qexpr_1)}]^{l_1} ; {c}_1, \vtrace_0 \vtrace_1}  
  \rightarrow^{assn/query}
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1} 
  \\
  \qquad \rightarrow^{*} 
  \config{\ewhile [b]^{l_b} \edo c_w;{c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1} 
  \rightarrow^{while-t} 
  \config{c_w;\ewhile [b]^{l_b} \edo c_w; c_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event_{ih}} 
  \\
  \qquad \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event_{ih}} 
  \rightarrow^{assn/query} 
  \config{{c}_4,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event_{ih} \cdot \event_2} 
  % 
  \end{array}
\]
% 
\[
  c_1 =_c [\eskip]{}^*; \ewhile [b]^{l_b} \edo c_w;{c}_2
\]
and
\[
  c_w;\ewhile [b]^{l_b} \edo c_w; c_2 =_c [\eskip]{}^*;[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4
\]
%
By substituting $c_1'$ with $c_1$ in execution in Eq.~\ref{eq:valdep_inv2} and $\event_{ih}' = (b, l_b, n_b, \efalse)$, we have:
 %
  \[
  \begin{array}{l}   
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip^*} 
  \config{\ewhile [b]^{l_b} \edo c_w;{c}_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{while-f} 
  \config{[\eskip]^{l_b};c_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event_{ih}'} 
  \\
  \qquad \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4', 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event_{ih}' \cdot \trace_2'}
  \rightarrow^{assn/query} 
  \config{{c}_4',  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event_{ih}' \cdot \trace_2' \cdot \event_2'} 
\end{array}
 \]
 %
By Inversion Lemma~\ref{lem:inv_b} on evaluation of boolean expression $b$ and following: 
\[
  \forall z \in \lvar \setminus \{x_1^{l_1}\} \st
  \env(\vtrace_0 \cdot \vtrace_1 \cdot \event_1')(z) = \env(\vtrace_0 \cdot \vtrace_1 \cdot \event_1)(z)
\]
we know:
\[
  x_1 \in VAR(b) \land x_1^{l_1} \in \live^{l_b}(c)
\]
%
 By uniqueness of label, we have 2 cases:
 \begin{enumerate}
 \item $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_w$:
 \\
 If $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \notin_c c_2$,
 %
 Then we know $\forall \trace, \trace' \in \mathcal{T}$, there doesn't exist execution
 \[
  \config{[\eskip]^{l_b};c_2, \vtrace} \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4', \trace'}
 \]
 This is contradict to the existence of execution in Eq.\ref{eq:m1testif_inv2}.
 \\
  If $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_2$, there must exist another while command
   in $c_2$ such that 
  $\ewhile [b]^{l_b} \edo c_w \in c_{w2}$ and $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_w$.
  \\
  We know $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2}$ will only shows up in $c_w$.
  \\
  By $\flowsto$ definition, we have:
  \[
    \forall z_i^{r_i} \in \lvar_{c_w}, x_j^{l_j} \in VAR(b) \st
    \flowsto(x_j^{l_j}, z_i^{r_i})
  \]
  %
  Since $x_2^{l_2} \in \lvar_{c_w}$ by $\flowsto$ definition, we have: 
  \[
    \flowsto(x_1^{l_1}, x_2^{l_2})
  \]
  %
  This case is proved.
  %
 \item $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \notin_c c_w$
 \\
 By
 \[
  c_w;\ewhile [b]^{l_b} \edo c_w; c_2 =_c [\eskip^*]; [\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4
\]
we know:
\[
  c_w;\ewhile [b]^{l_b} \edo c_w; =_c [\eskip^*]; \land c_2 = [\eskip^*]; [\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4
\]
This is contradict to program equivalence definition, i.e.,
\[
  c_w;\ewhile [b]^{l_b} \edo c_w; \neq_c [\eskip^*]
\]
This case is proved.
%
 \end{enumerate}
%
\textbf{subsubsubsub-case:}$\event_{ih} = (b, l_b, n_b, \efalse) \land \event_{ih}' = (b, l_b, n_b, \etrue)$
\\
By execution in Eq.~\ref{eq:m1test_inv1} and $\event_{ih} = (b, l_b, n_b, \etrue)$, we have:
\[
  \begin{array}{l}   
  \config{{c}, \vtrace_0} \rightarrow^{*} 
  \config{[\assign{{x}_1}{\expr_1 / \query(\qexpr_1)}]^{l_1} ; {c}_1, \vtrace_0 \vtrace_1}  
  \rightarrow^{assn/query}
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1} 
  \\
  \qquad \rightarrow^{*} 
  \config{\ewhile [b]^{l_b} \edo c_w;{c}_2, 
  \vtrace_0 \vtrace_1 \cdot \event_1} 
  \rightarrow^{while-f} 
  \config{[\eskip]; c_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event_{ih}} 
  \\
  \qquad \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event_{ih}} 
  \rightarrow^{assn/query} 
  \config{{c}_4,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \event_{ih} \cdot \event_2} 
  % 
  \end{array}
\]
%
\[
  c_1 =_c [\eskip]{}^*; \ewhile [b]^{l_b} \edo c_w;{c}_2
\]
% 
\[
  [\eskip]; c_2 =_c [\eskip^*];[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4
\]
i.e,
\[
  c_2 =_c [\eskip^*];[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4
\]
%
By substituting $c_1'$ with $c_1$ in execution in Eq.~\ref{eq:valdep_inv2} and $\event_{ih}' = (b, l_b, n_b, \etrue)$, we have:
 %
  \begin{equation}
  \label{eq:m1testwhile_inv2}
  \begin{array}{l}   
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip^*} 
  \config{\ewhile [b]^{l_b} \edo c_w;{c}_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{while-t} 
  \config{c_w;\ewhile [b]^{l_b} \edo c_w;c_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event_{ih}'} 
  \\
  \qquad \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4', 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event_{ih}' \cdot \trace_3}
  \rightarrow^{assn/query} 
  \config{{c}_4',  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event_{ih}' \cdot \trace_3 \cdot \event_2'} 
\end{array}
\end{equation}
%
Proof by cases of $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_w$ or 
$[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \notin_c c_w$
\begin{enumerate}
  \item $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_w$.
  \\
  By uniqueness of the program label, there must exist another while command in $c_2$, -- i.e., $\ewhile [b_2]^{l_{b2}} \edo c_{w2} \in_c c_2$ --
    such that 
  $\ewhile [b]^{l_b} \edo c_w \in c_{w2}$ and $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_w$, i.e.,:
  %
  \[
  \exists b_2, l_{b2} \in \mathbb{N}, c_{w2} \st 
  \ewhile [b_2]^{l_{b2}} \edo c_{w2} \in_c c_2 
  \land \ewhile [b]^{l_b} \edo c_w \in c_{w2}
  \land [\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_w
  \]
%
Then we know there exists $c_5$ and $c_6$ such that:
\[
  c_2 =_c c_5; \ewhile [b_2]^{l_{b2}} \edo c_{w2};c_6
\]
Which is contradict to $c_2 =_c [\eskip^*];[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4$ by program equality definition.
%
%
 \item $[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \notin_c c_w$.
%
\\
%
Substituting $c_2$ in the execution in Eq.\ref{eq:m1testwhile_inv2}, we have the following execution be the only possible execution satisfying $\vcounter(\trace_3) l_2 = 0$ where $\trace_2' = \event_{ih}' \cdot \trace_3 = \event_{ih}' \cdot \trace_w$:
\[
    \begin{array}{l}   
  \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip^*} 
  \config{\ewhile [b]^{l_b} \edo c_w;{c}_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1'} 
  \rightarrow^{while-t} 
  \config{c_w;\ewhile [b]^{l_b} \edo c_w;c_2, \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event_{ih}'} 
  \\
  \qquad \rightarrow^{*} 
  \config{c_2,\vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event_{ih}' \cdot \trace_w}
  \\
  \qquad \rightarrow^{\eskip*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_4, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event_{ih}' \cdot \trace_w}
  \rightarrow^{assn/query} 
  \config{{c}_4,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1' \cdot \event_{ih}' \cdot \trace_w \cdot \event_2'} 
\end{array}
\]
and
\[
  VAR{(\trace_w)} \subseteq \lvar_{c_w}
\]
%
By $\flowsto$ definition, we also have:
\[
  \forall z_i^{r_i} \in \lvar_{c_w},  x_j^{l_j} \in \lvar_c \st x_j \in VAR(b) \land x_j^{l_j} \in \live^{l_b}(c) \implies
  \flowsto(x_j^{l_j}, z_i^{r_i})
\]
Since $x_1 \in VAR(b) \land x_1^{l_1} \in \live^{l_b}(c)$ , we have:
\[
  \bigwedge_{\forall z_i^{r_i} \in \lvar_{c_w}}
  \flowsto(x_1^{l_1}, z_i^{r_i})
\]
%
By Inversion Lemma~\ref{lem:inv_a} on evaluation of expression $\expr_2$ and following: 
\[
  \forall z \in \lvar \setminus \{x_1^{l_1}\} \cup VAR{(\trace_w)} \st
  \env(\vtrace_0 \cdot \vtrace_1 \cdot \event_1'\cdot \event_{ih}' \cdot \trace_2')(z) 
  = \env(\vtrace_0 \cdot \vtrace_1 \cdot \event_1\cdot \event_{ih})(z)
\]
%
we have:
\[
  x_1 \in VAR(\expr_2) \bigvee_{z_i \in VAR{(\trace_w)}} z_i^{r_i} \in VAR(\expr_2)
\]
%
Let $S = (\{x_1^{l_1}\} \cup VAR{(\trace_f)}) \cap \live^{l_2}(c) $
%
By $\flowsto$ definition, we have:
\[
   \bigvee_{z_i^{r_i} \in S}  \flowsto(z_i^{r_i}, x_2^{l_2})
\]
By $ \bigwedge_{\forall z_i^{r_i} \in \lvar_{c_w}} \flowsto(x_1^{l_1}, z_i^{r_i})$ and $S \subseteq VAR{(\trace_w)} \subseteq \lvar_{c_w}$, we have:
\[
\bigvee_{z_i^{r_i} \in S} 
(\flowsto(x_1^{l_1}, z_i^{r_i}) \land \flowsto(z_i^{r_i}, x_2^{l_2}))
\]
%
i.e.,
\[
\Big(\exists z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}}
 \land \flowsto(x_1^{l_1}, z_1^{r_1}) \land \cdots \land \flowsto(z_n^{r_n}, {x}_2^{l_2}) \Big)
\]
%
This case is proved.
\end{enumerate}
\end{subproof}
%
This case is proved.
\end{subsubsubcase}
\end{subsubcase}
\end{subcase}
\end{case}
%
\caseL{$(b)~\eventdep^{\ctl}(\event_1, \event_2, c, D)$}
Unfolding $\eventdep^{\ctl}(\event_1, \event_2, c, D)$, we have:
%
\[
\exists \vtrace_1, \vtrace_2, \vtrace_2', \vtrace_0 \in \mathcal{T}, 
\event_1' \in \eventset^{\asn}, {c}_1.
\left(
\begin{array}{ll}   
  & \config{{c}, \vtrace_0} \rightarrow^{*} 
    \config{{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
    \config{\eskip,  \vtrace_1 \cdot \event_1 \cdot \vtrace_2} 
  \\ 
  \bigwedge &
  \config{{c}_1, \vtrace_1 \cdot \event_1'}  \rightarrow^{*} 
  \config{\eskip,  \vtrace_1 \cdot \event_1' \cdot \vtrace_2' } 
  \\
  \bigwedge &  \pi_1(\event_1) = \pi_1(\event_2) \land \pi_2(\event_1) = \pi_2(\event_2) \\
  \bigwedge & l_1 = \pi_2(\event_1) \land l_2 = \pi_2(\event_2)
  \\
  \bigwedge & \event_2 \in \trace_2 \land \vcounter(\vtrace_1 \cdot \event_1) l_1 = \vcounter(\vtrace_1 \cdot \event_1')l_1  \land \vcounter(\vtrace_2') l_2 < \vcounter(\trace_2) l_2 
\end{array}
\right)
 \]%
% %
By Inversion Lemma~\ref{lem:inv_asn} on 
 $\event_1$, $\event_2$ we know $\exists \expr_1$ or $\qexpr_1$, $\exists \expr_2$ or $\qexpr_2$ and following execution instance
 \todo{notation $\assign{x}{\expr / \query(\qexpr)}$ denotes variable $x$ is assigned by either an expression $\expr$ or query $\query(\qexpr)$} from the first execution in $\eventdep^{\ctl}(\event_1, \event_2, c, D)$.
 %
\begin{equation}
% \label{eq:ctldep_inv1}
  \begin{array}{l}   
\config{{c}, \vtrace_0} \rightarrow^{*} 
\config{[\assign{{x}_1}{\expr_1 / \query(\qexpr_1)}]^{l_1} ; {c}_1, \vtrace_0 \cdot \vtrace_1}  
\rightarrow^{assn/query}
 \config{c_1, \vtrace_0 \cdot \vtrace_1 \cdot \event_1} 
 \\ \qquad 
 \rightarrow^{*} 
  \config{[\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2};{c}_2, 
  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \cdot \vtrace_2} 
  \rightarrow^{assn/query} 
  \config{{c}_2,  \vtrace_0 \cdot \vtrace_1 \cdot \event_1 \tracecat \vtrace_3 \cdot \event_2} 
  \\ \qquad 
  \rightarrow^*
  \config{\eskip,  \vtrace_1 \cdot \event_1 \cdot \vtrace_2}
  % 
\end{array}
\end{equation}
%
where $\trace_2 = \vtrace_3 \cdot \event_2 $
%
 By {Inversion Lemma~\ref{lem:inv_ctltotest} and \ref{lem:inv_ctltoevent2}}, we have:
 \[
   \exists \event_b \in \eventset^{\test} \st \eventdep^{val}(\event_1, \event_b, c, D)
 \]
 %
 %
 Unfolding $\eventdep^{val}(\event_1, \event_b, c, D)$ by Definition~\ref{def:event_valdep}, we have:
\[
\exists \vtrace_0,
\vtrace_1, \vtrace_2, \vtrace_2' \in \mathcal{T}, \event_b' \in \eventset, \event_1' \in \eventset^{\asn}, 
{c}_1, {c}_2,  {c}_2'.
  \left(
  \begin{array}{ll}   
 & \config{{c}, \vtrace_0} \rightarrow^{*} 
\config{{c}_1, \vtrace_1 \cdot \event_1}  \rightarrow^{*} 
  \config{{c}_2,  \vtrace_1 \cdot \event_1 \cdot \vtrace_b \cdot \event_b } 
  % 
 \\ 
 \bigwedge &
  \config{{c}_1, \vtrace_1 \cdot \event_1'}  \rightarrow^{*} 
  \config{{c}_2',  \vtrace_1 \cdot \event_1' \cdot \vtrace_b' \cdot \event_b' } 
\\
\bigwedge &  \pi_1(\event_1) = \pi_1(\event_1') \land \pi_2(\event_1) = \pi_2(\event_1') \\
\bigwedge & l_1 = \pi_2(\event_1) \land l_2 = \pi_2(\event_2)
\land \vcounter(\vtrace_1 \cdot \event_1) l_1 = \vcounter(\vtrace_1 \cdot \event_1')l_1 
\\
\bigwedge & 
\diff(\event_b,\event_b' ) \land 
\vcounter(\vtrace_1 \cdot \event_1 \cdot \vtrace_b \cdot \event_b) l_b
= 
\vcounter(\vtrace_1 \cdot \event_1' \cdot \vtrace_b'\cdot \event_b') l_b\\
\end{array}
\right)
 \]
%
 Let $\event_b = (b, l_b, n_b, v_b)$, by {Inversion Lemma~\ref{lem:inv_test}},
we know $\exists  c_t, c_f$ or $c_w$ and following execution instance:
\begin{equation}
\label{eq:ctldep_inv1}
  \begin{array}{l}   
\config{{c}, \vtrace_0} \rightarrow^{*} 
\config{[\assign{{x}_1}{\expr_1 / \query(\qexpr_1)}]^{l_1} ; {c}_1, \vtrace_0 \tracecat \vtrace_1}  
\rightarrow^{assn/query}
 \config{c_1, \vtrace_0 \tracecat \vtrace_1 \cdot \event_1} 
 \\ \qquad 
 \rightarrow^{*} 
  \config{\eif([b]{}^{l_b}, c_t, c_f) / \ewhile [b]{}^{l_b} \edo c_w; {c}_2, 
  \vtrace_0 \tracecat \vtrace_1 \cdot \event_1 \tracecat \vtrace_b} 
  \rightarrow^{if-b / while-b} 
  \config{{c}_3,  \vtrace_0 \tracecat \vtrace_1 \cdot \event_1 \tracecat \vtrace_b \cdot \event_b} 
  % 
\end{array}
\end{equation}
%
By Inversion Lemma~\ref{lem:inv_ctltoevent2}, we know:
\[
  [\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_t
  \lor
  [\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_t
\]
or
\[
    [\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_w
\]
%
By definition of $\flowsto$, we know
\begin{equation}
\label{eq:ctldep_btoevent2}
 \forall z \in VAR(b) \st z^l \in \live^{l_b}(c) \implies \flowsto(z^l, x_2^{l2})
\end{equation} 
%
 %
By Inversion Lemma~\ref{lem:inv_test} on $\event_b'$, we have following execution instance: 
 \[
  \config{c_1, \vtrace_0 \tracecat \vtrace_1 \cdot \event_1'} 
  \rightarrow^{*} 
  \config{\eif([b']{}^{l_b'}, c_t', c_f') / \ewhile [b']{}^{l_b'} \edo c_w'; {c}_2',
  \vtrace_0 \tracecat \vtrace_1 \cdot \event_1' \vtrace_b'} 
  \rightarrow^{if-b / while-b} 
  \config{{c}_3',  \vtrace_0 \tracecat \vtrace_1 \cdot \event_1' \tracecat \vtrace_b' \cdot \event_b'} 
 \]
 %
 By $\diff(\event_b,\event_b' )$ from $\eventdep^{val}(\event_1, \event_b, c, D)$ definition, we know
 \[
 b = b' \land l_b = l_b'
 \]
 % 
 By uniqueness of the label, we have $c_t = c_t' \land c_f = c_f'$, or $c_w = c_w'$, i.e.,:
 %
 \begin{equation}
\label{eq:ctldep_inv2}
  \begin{array}{l}   
\config{c_1, \vtrace_0 \tracecat \vtrace_1 \cdot \event_1'} 
  \rightarrow^{*} 
  \config{\eif([b]{}^{l_b}, c_t, c_f) / \ewhile [b]{}^{l_b} \edo c_w; {c}_2',
   \vtrace_0 \tracecat \vtrace_1 \cdot \event_1' \vtrace_b'} 
   \\ \qquad
  \rightarrow^{if-b / while-b} 
  \config{{c}_3',  \vtrace_0 \tracecat \vtrace_1 \cdot \event_1' \tracecat \vtrace_b' \cdot \event_b'} 
   % 
\end{array}
\end{equation}
%
From the definition, we also have:
\[
  \vcounter(\vtrace_1 \cdot \event_1 \cdot \vtrace_b\cdot \event_b) l_b
= 
\vcounter(\vtrace_1 \cdot \event_1' \cdot \vtrace_b'\cdot \event_b') l_b
\land 
\pi_2(\event_1) = \pi_2(\event_1')
\]
%
Then we have:
 \begin{equation}
\label{eq:ctldep_invn}
  \vcounter(\vtrace_b) l_b = \vcounter(\vtrace_b') l_b
\end{equation}
 %
 \todo{
 Induction on length of $m = |\vtrace_b|$, it is sufficient to show the following proposition:
%
\[
\Big(\exists z_1^{r_1}, \cdots, z_n^{r_n} \in \lvar_{{c}} \st (0 \leq n \leq m )
 \land \flowsto(x_1^{l_1}, z_1^{r_1}) \land \cdots \land \flowsto(z_n^{r_n}, {x}_2^{l_2}) \Big)
\]
 }
 %
 \caseL{$m = 0$}
 By execution in Eq.~\ref{eq:ctldep_inv1}, we have:
\[
\config{{c}, \vtrace_0} \rightarrow^{*} 
\config{[\assign{{x}_1}{\expr_1 / \query(\qexpr_1)}]^{l_1} ; {c}_1, \vtrace_0 \tracecat \vtrace_1}  
\rightarrow^{assn/query}
 \config{c_1, \vtrace_0 \tracecat \vtrace_1 \cdot \event_1} 
 \\ \qquad 
 \rightarrow^{*} 
  \config{\eif([b]{}^{l_b}, c_t, c_f) / \ewhile [b]{}^{l_b} \edo c_w; {c}_2, 
  \vtrace_0 \tracecat \vtrace_1 \cdot \event_1} 
  \rightarrow^{if-b / while-b} 
  \config{{c}_3,  \vtrace_0 \tracecat \vtrace_1 \cdot \event_1 \cdot \event_b} 
 \]
 %
 We also have:
 \[
 c_1 = [\eskip]^*;\eif([b]{}^{l_b}, c_t, c_f) / \ewhile [b]{}^{l_b} \edo c_w; {c}_2
 \]
Substituiting $c_1$ in execution in Eq.~\ref{eq:ctldep_inv2}, by the Subproof~\ref{pf:noiteration_inv2}, 
we have the only possible execution instance satisfying 
the restriction in Eq.~\ref{eq:ctldep_invn} as follows, where $\trace_b' = \cdot$
%
 \[
  \config{c_1, \vtrace_0 \tracecat \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip^*} 
  \config{
  \eif([b]{}^{l_b}, c_t, c_f) / \ewhile [b]{}^{l_b} \edo c_w; {c}_2, 
  \vtrace_0 \tracecat \vtrace_1 \cdot \event_1'} 
  \rightarrow^{if-b / while-b} 
  \config{{c}_2,  \vtrace_0 \tracecat \vtrace_1 \cdot \event_1' \cdot \event_b'} 
 \]
By $\eventdep^{val}(\event_1, \event_2, c)$, and definition of environment, 
the environment only able to obtain different values for variable $x_1$ 
from trace $\vtrace_0 \cdot \vtrace_1 \cdot \event_1$ and 
$\vtrace_0 \cdot \vtrace_1 \cdot \event_1'$, i.e.,
\[
  \forall u \in \lvar_c \setminus \{x_1^{l_1}\} \st
  \env(\vtrace_0 \vtrace_1 \cdot \event_1') (u) =  
  \env(\vtrace_0 \vtrace_1 \cdot \event_1) (u)
\]
%
By {Inversion Lemma~\ref{lem:inv_b}} of boolean expression evaluation,
 \[
  x_1 \in VAR(b)
 \]
 %
 By Inversion Lemma~\ref{lem:inv_live} and $\llabel(\vtrace_0 \vtrace_1 \cdot \event_1') x_1 = l_1$, we know:
\[
  x_1^{l_1} \in \live^{l_b}(c)
\]
 %
 Then, by Eq.~\ref{eq:ctldep_btoevent2} we have
 \[
 \flowsto(x_1^{l_1}, x_2^{l_2})
 \]
 i.e.,
 \[
 \Big( \exists z_1, \cdots, z_n \in \lvar_{{c}}. ~ 0 \leq n \leq 0 \land
  \flowsto(x_1^{l_1}, z_1) 
  \land \cdots \land \flowsto(z_n, x_2^{l_2}) \Big)
 \]
 This case is proved.
%
 \caseL{$m = 1$}
 %
 Let $\vtrace_b = \cdot \event_{ih} \cdot$, there are 2 sub-cases: 
 \[
 \event_{ih} \in \eventset^{\test} \lor \event_{ih} \in \eventset^{\asn}
 \]
 %
 This case is proved by splitting the 2 sub-cases.
 %
 \subcaseL{$\event_{ih} \in \eventset^{\test}$}
  %
By execution in Eq.~\ref{eq:ctldep_inv1} and {Inversion Lemma~\ref{lem:inv_test}}, we have:
%
\[
  \begin{array}{l}   
  \config{{c}, \vtrace_0} 
  \rightarrow^{*} 
  \config{[\assign{{x}_1}{\expr_1 / \query(\qexpr_1)}]^{l_1} ; {c}_1, \vtrace_0 \tracecat \vtrace_1}  
  \rightarrow^{assn/query}
  \config{c_1, \vtrace_0 \tracecat \vtrace_1 \cdot \event_1} 
  \\ 
  \qquad \rightarrow^{*} 
  \config{\eif([b']{}^{l_{b'}}, c_t', c_f') / \ewhile [b']{}^{l_{b'}} \edo c_w'; {c}_3, 
  \vtrace_0 \tracecat \vtrace_1 \cdot \event_1} 
  \rightarrow^{if-b / while-b} 
  \config{{c}_4,  \vtrace_0 \tracecat \vtrace_1 \cdot \event_1 \cdot \event_{ih}} 
  \\ 
  \qquad \rightarrow^{*} 
  \config{\eif([b]{}^{l_b}, c_t, c_f) / \ewhile [b]{}^{l_b} \edo c_w; {c}_5, 
  \vtrace_0 \tracecat \vtrace_1 \cdot \event_1\cdot \event_{ih}} 
  \rightarrow^{if-b / while-b} 
  \config{{c}_6,  \vtrace_0 \tracecat \vtrace_1 \cdot \event_1 \cdot \event_{ih} \cdot \event_b} 
\end{array}
 \]
 %
 By \todo{Inversion Lemma: only skip command will not produce event}, we have:
 \[
 c_1 = [\eskip]^*;\eif([b']{}^{l_{b'}}, c_t', c_f') / \ewhile [b']{}^{l_{b'}} \edo c_w'; {c}_3
 \]
 \[
 c_4 = [\eskip]^*;\eif([b]{}^{l_b}, c^1, c^2) / \ewhile [b]{}^{l_b} \edo c'; {c}_5
 \]
 %
Substituting $c_1$ in execution in Eq.~\ref{eq:ctldep_inv2}, by the Subproof~\ref{pf:noiteration_inv2}, 
we have the only possible execution instance satisfying 
the restriction in Eq.~\ref{eq:ctldep_invn} as follows:
%
 \[
  \config{c_1, \vtrace_0 \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip^*} 
  \config{\eif([b']{}^{l_{b'}}, c_t', c_f') / \ewhile [b']{}^{l_{b'}} \edo c_w'; {c}_3, 
  \vtrace_0 \tracecat \vtrace_1 \cdot \event_1'} 
  \rightarrow^{if-b / while-b} 
  \config{{c}_4',  \vtrace_0 \tracecat \vtrace_1 \cdot \event_1' \cdot \event_{ih}'} 
  \\ 
  \qquad \rightarrow^{*} 
  \config{\eif([b]{}^{l_b}, c_t, c_f) / \ewhile [b]{}^{l_b} \edo c_w; {c}_5', 
  \vtrace_0 \tracecat \vtrace_1 \cdot \event_1' \cdot \event_{ih}' \cdot \trace_{b2}} 
  \rightarrow^{if-b / while-b} 
  \config{{c}_6',  \vtrace_0 \tracecat \vtrace_1 \cdot \event_1' \cdot \event_{ih}' \cdot \trace_{b}'' \cdot \event_b'} 
 \]
%
There are 2 subsub-cases:
\[
  \eventdep^{val}(\event_1, \event_{ih}) \lor \neg \eventdep^{val}(\event_1, \event_{ih})
\]
\subsubcaseL{$\neg \eventdep^{val}(\event_1, \event_{ih})$}.
\\
By $\neg \eventdep^{val}(\event_1, \event_{ih})$, we know:
\[
  \event_{ih} \eventeq \event_{ih}'
\]
Then, by determinism of the evaluation, we know $c_4 = c_4'$.
\\
Substituting $c_4'$ above, by the Subproof~\ref{pf:noiteration_inv2}, 
we have the only possible execution instance satisfying 
the restriction in Eq.~\ref{eq:ctldep_invn} as follows, where $\trace_b'' = \cdot$ and $\trace_b' = \event_{ih}'$.
%
 \[
  \config{c_1, \vtrace_0 \vtrace_1 \cdot \event_1'} 
  \rightarrow^{\eskip^*} 
  \config{\eif([b']{}^{l_{b'}}, c_t', c_f') / \ewhile [b']{}^{l_{b'}} \edo c_w'; {c}_3, 
  \vtrace_0 \tracecat \vtrace_1 \cdot \event_1'} 
  \rightarrow^{if-b / while-b} 
  \config{{c}_4,  \vtrace_0 \tracecat \vtrace_1 \cdot \event_1' \cdot \event_{ih}'} 
  \\ 
  \qquad \rightarrow^{\eskip*} 
  \config{\eif([b]{}^{l_b}, c_t, c_f) / \ewhile [b]{}^{l_b} \edo c_w; {c}_5, 
  \vtrace_0 \tracecat \vtrace_1 \cdot \event_1' \cdot \event_{ih}'} 
  \rightarrow^{if-b / while-b} 
  \config{{c}_6',  \vtrace_0 \tracecat \vtrace_1 \cdot \event_1' \cdot \event_{ih}' \cdot \event_b'} 
 \]
 By definition of environment, we have:
\[
  \forall u \in \lvar_c \setminus \{x_1^{l_1}\} \st
  \env(\vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event_{ih}') (u) =  
  \env(\vtrace_0 \vtrace_1 \cdot \event_1 \cdot \event_{ih}) (u)
\]
%
By {Inversion Lemma~\ref{lem:inv_b}} of boolean expression evaluation, we have:
 \[
  x_1 \in VAR(b)
 \]
 %
 We also have 
 $$
 \llabel(\vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event_{ih}') x_1 = l_2
 \land 
 \llabel(\vtrace_0 \vtrace_1 \cdot \event_1' \cdot \event_{ih}) x_1 = l_2
 $$
 %
 Then, by Eq.~\ref{eq:ctldep_btoevent2}, we have
 \[
 \flowsto(x_1^{l_1}, x_2^{l_2})
 \]
 i.e.,
 \[
 \Big( \exists z_1, \cdots, z_n \in \lvar_{{c}}. ~ 0 \leq n \leq 1 \land
  \flowsto(x_1^{l_1}, z_1) 
  \land \cdots \land \flowsto(z_n, x_2^{l_2}) \Big)
 \]
  This case is proved.
%
\subsubcaseL{$\eventdep^{val}(\event_1, \event_{ih})$}.
\\
By $\eventdep^{val}(\event_1, \event_{ih})$, we know:
\[
  (\event_{ih} \eventeq \event_{ih}') \lor \diff(\event_{ih}, \event_{ih}')
\]
Case of $\event_{ih} \eventeq \event_{ih}'$ is proved in subsub-case $\neg \eventdep^{val}(\event_1, \event_{ih})$.
%
Then, we know $\diff(\event_{ih}, \event_{ih}')$. By uniqueness, we have 2 cases:
\begin{enumerate}
  \item $\eif([b]{}^{l_b}, c_t, c_f) / \ewhile [b]{}^{l_b} \edo c_w \in_c c_f' \lor c_t' \lor c_w'$
  %
  \\
  By transitivity of $\in_c$, we know:
  \[
  [\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_t'
  \lor
  [\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_f'
\]
or
\[
    [\assign{{x}_2}{\expr_2 / \query(\qexpr_2)}]^{l_2} \in_c c_w'
\]
%
Then, by definition of $\flowsto$, we know
\begin{equation}
 \forall z \in VAR(b') \st z^l \in \live^{l_b'}(c) \implies \flowsto(z^l, x_2^{l2})
\end{equation} 

 By definition of environment, we have:
\[
  \forall u \in \lvar_c \setminus \{x_1^{l_1}\} \st
  \env(\vtrace_0 \vtrace_1 \cdot \event_1') (u) =  
  \env(\vtrace_0 \vtrace_1 \cdot \event_1) (u)
\]
%
By {Inversion Lemma~\ref{lem:inv_b}} of boolean expression evaluation on $b'$, we have:
 \[
  x_1 \in VAR(b')
 \]
 %
 We also have 
 $$
 \llabel(\vtrace_0 \vtrace_1 \cdot \event_1') x_1 = l_1
 \land 
 \llabel(\vtrace_0 \vtrace_1 \cdot \event_1') x_1 = l_1
 $$
 %
 Then, we know:
 \[
 \flowsto(x_1^{l_1}, x_2^{l2})
 \]
 This case is proved.
\item $\eif([b]{}^{l_b}, c_t, c_f) / \ewhile [b]{}^{l_b} \edo c_w \notin_c c_f' \land c_t' \land c_w'$.

\end{enumerate}
%
THis case is proved in the same way as case subsub-case $\event_{ih} \in \eventset^{test}$ in sub-case $m = 1$ in case $\eventdep^{val}(\event_1, \event_2)$.
%
  %
\subcaseL{$\event_{ih} \in \eventset^{\asn}$}
Let $\event_{ih} = (z, l', n', v')$  there are 2 cases:
$\eventdep^{val}(\event_1, \event_{ih}, c D)$ or $\neg \eventdep^{val}(\event_1, \event_{ih}, c D)$
%
\subsubcaseL{$\eventdep^{val}(\event_1, \event_{ih}, c D)$}
%
THis case is proved in the same way as case subsub-case $\event_{ih} \in \eventset^{\asn}$ in sub-case $m = 1$ in case $\eventdep^{val}(\event_1, \event_2)$.
%
\caseL{$\trace_2 = \trace_3 \cdot \event$}
Let $P(\cdot \event_1 \tracecat \trace_2 \cdot \event_2) = \exists$
By induction hypothesis on $\trace_3$,
 and $\vardep(x_1^{l_1}, x_2^{l_2}, c, D)$, 
$\vardep(x_1^{l_1}, z_1^{r_1}, c, D) \land \vardep(z^{l_z}, x_2^{l_2}, c, D)$ respectively, 
we have $\exists z_2^{r_2}, \cdots, z_n^{r_2}, 1 \leq n \leq m'+1$ s.t.:
\[
\begin{array}{ll}
      & \flowsto(x_1^{l_1}, x_2^{l_2}) \\
  \lor  & \flowsto(x_1^{l_1}, z_2^{r_2}) \land \flowsto(z_2^{r_2}, x_2^{l_2})\\
  \lor  & \flowsto(x_1^{l_1}, z_2^{r_2}) \land \flowsto(z_2^{r_2}, z_1^{r_1}) \land \flowsto(z_1^{r_1}, x_2^{l_2}) \\
  \lor  & \flowsto(x_1^{l_1}, z_1^{r_1}) \land \flowsto(z_1^{r_1}, z_2^{r_2}) \land \flowsto(z_2^{r_2}, x_2^{l_2}) \\
  \lor  & \cdots \\
  \lor  & \flowsto(x_1^{l_1}, z_2^{r_2}) \land \cdots \land \flowsto(z_n^{r_n}, z_1^{r_1}) \land \flowsto(z_1^{r_1}, x_2^{l_2}) \\
\end{array}
\]This case is proved.
\end{proof}