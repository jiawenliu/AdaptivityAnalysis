We would like to thank all the reviewers for their comments and suggestions.
We will take all of them in consideration when revising the paper. 

- Overview

We will follow the reviewer recommendations for improving the presentation
and to make the paper more accessible (using extra pages if needed).
Specifically, we will:
- expand the description of our evaluation
- simplify the notation
- summarize the notation we use in a table,


inwe used in the paper to help the understanding of
the concepts, definitions, and the running exmaples. We plan to put
more space to explain the evaluation, providing text description of
the our algorithm 1, explaining how this algorithm will handle
complicated exmaples with high level multi loops and produces
quadratic adaptivity upper bound, how will the alternative
implementation AdaptFun-I works as a complement of AdaptFun in
handling "complicated" examples.

We will also point out the location
of corresponding content in the appendix in the paper, such as the
proof of some lemma, some definitions, notations if not shown in the
paper due to space limit.
 

- Detailed Resoponse

---------------------------------------------------------------
Reviewer A

> As the authors mentioned, the paper's method works only for linear
> queries. Also, it does not seem to work on high-level multi loops.

To clarify, we consider only linear queries because it is the broader
class for which we have clear theoretical statements as the ones we
discuss in Section 2 (Theorems 2.1-3). Our system can be easily
adapted to handle also non-linear queries and we plan in the future to
explore in which situations we can control the generalization error
for this class of queries.
Our method can handle multi loops but as we discussed in Seciton 7,
our implementation does have performace issues with some examples
using high level multi-loops to estimate the weight. The bottleneck is
the reachability bound analysis. To overcome this, we implemented
another more efficient (but less precise) reachability bound analysis
(we called it AdaptFun-I) which can handle these examples more
efficiently. The results and performance of AdaptFun-I are presented
in Table 2. The evaluation shows that AdaptFun-I can be used as a
complement for AdaptFun for examples with "complicated" multi loops.

> Demonstrations in the paper are a bit confusing. For example, in
> semantics-based dependency graph, there are too much information
> packed in a small graph, and lambda tau.rho(tau)k notation is hard
> to understand at first sight.

Thanks for ponting this out, we will review our notation to make it
easier to understand (perhaps omitting some detail from the graph,
e.g. we could leave the initial trace implicit) and we will also
improve our explanations.


------------------------------------------------------------------
Reviewer B

Thanks for the suggestions. We will improve our presentation by having
a table summarizing the notation, a simpler example in the
introduction, more text description for Algorithm 1, more discussion
on the alternative implemetation AdaptFun-I, a clear claim that
AdaptFun is not path-sensitive in the general case. Thank you also for
pointing out typos, we will fix them as well.

> I appreciated the citation of differential privacy work.  Work on
> program fairness properties and differential privacy in software
> topics (e.g., profiling) is loosely related and may be worth citing
> if space allows.

Thanks for pointing this out. We will add references to those works.

> In section 2, the co-domain for AdaptFun is defined to be any of
> [-1, 1], [0, 1], or [-R, +R].  Does this choice matter, whether for
> correctness or performance?

It does not matter for correctness. It might affect performance
for some specific set of queries but it is an aspect we didn't explore. 

> When reading the definition of "well-formed" graphs (end of section
> 4.2), I was left wondering: Is this restrictive in any way for
> real-world graphs?  Does the database being defined as finite make a
> difference here?

Our definition of "well-formed" graphs rules out programs with
non-terminating behaviors, such as ones with infinite loops. We
believe for our application, adaptive data analysis, this is not too
restrictive. Most of the programs perform some recursion either on the
database structure, which is in general finite, or on some other
quantity finite quantity.
The database being finite is an essential assumption in our work, as well
as in the literature we summarized in Section 2. If we could have
an infinite number of sample data, in most situations we wouldn't need
additional method to control the generalization error since this would
be vanishing when the number of samples n tends to infinity. 

> There is no direct proof provided for Lemma 5.1 (including in the
> appendix, from what I could decipher).  Even if trivial, it would
> be helpful to note something.

Sorry for the inconvenience. The proof for Lemma 5.1 is actually in
appendix Lemma B.2 in page 44. However, we realize that the lemma
number is different and actually the lemma in the appendix uses a
slightly different notation. We will fix the notation, the theorem
number and we will add a pointer to it in the paper.

> " I wasn't sure what conclusion to draw regarding AdaptFun-I (is it
>  the best? is the one case pathological?).  More could also be said
>  regarding the claim (855) that "examples with many nested loops are
>  not common".  Are they important real-world examples, though?  What
>  type of examples would fit this profile?"

The alternative implementation AdaptFun-I is used to analyse some
examples with complex high level multi loops that AdaptFun cannot
handle due to the performance bottleneck of the underlying
implementation of reachability bound analysis (show in Table 1, 3
examples whose running time is * meaning too long). AdaptFun-I
provides a less precise but efficient analysis for these examples,
using very little time (shown in table 2). The price to pay to use
AdaptFun-I is in precision. We think about it as a complement of
AdaptFun when the latter cannot handle "complex" multi loops. We don't
expect these complex multi loops to appear in many realistic examples,
but it is still an option we have.

-------------------------------------------------------------------------
Reviewer C

Thanks for your careful review and detailed suggestions. We will work
on improving the presentation of the paper, adjusting the font of
Figure 2, fix typos, rephrase some sentences, better present the
tables in evaluation section,

> "3. Why is there an (l6, x3) edge in Figure 3b? Is the graph
>  implicitly the transitive closure of data dependencies?"

Formally, the edge (l6, x3) in Fig 3b of the semantic-based dependency
graph shows up when we follow on the definitino 3 and get the DEP
relation. That is right, this edge appears because of the transitive
clousure of data dependencies.

> "Given that the reachability bound analysis is based on difference
>  constraints, is it correct for me to assume that the algorithm can
>  at most derive linear bounds on the number of times each statement
>  may be executed? In that case, I was surprised that the algorithm
>  was able to derive quadratic adaptivity estimates (such as for
>  loop2VD in Table 1). Can the authors please clarify?"

The reachability bound analysis is based on previous work from Sinn
and Zuleger etc[37], we can assume the reachability bound analysis can
provides linear bounds or weight (the weight used in our weighted
dependency graph in Section 5.1.2). To get the estimation of
adaptivity upper bound, our algorithm estimates the length of the
longest path in the weighted depenendency graph by approximating the
local adaptivity of every Strong Connect Componenet (SCC) of the
weighted graph by the number of vertices times the minimum weight of
all the vertex in a path of this SCC. For instance, even reachability
bound analysis gives linear weight k for every statement is a loop(SCC
in the graph), then the estimated local adaptivity of this SCC is k *
[number of vertices in the path of this SCC]. If there are nested
while loops, then the estimated adaptivity for this nested while loop
will be quadratic (k*k). We should stress this in the evaluation as
well as in the adaptBD algorithm in 5.3. In table 1, loop2VD contains
a nested loop in the form of j = k; i=k; while [j>0] { j--; while [i >
0] {i--, ...} ... }  . Our adaptBD will then return a quadratic
adaptivity estimation.

> "but a more interesting question is how accurate the entire pipeline
> would have been if the ground truth adaptivity had been used instead
> of Aest? Given that the ground truth and Aest columns are identical
> in many cases in Table 1, I assume that not much accuracy is lost
> because AdaptFun is conservative?"

We think not much accuracy is lost using AdaptFun, however, as the
examples discussed in Section 6, path sensitive, Adaptfun will give
looser adaptivity Aest than the ground truch one.

> "9. Can you elaborate on why AdaptFun times out for the last three
> benchmark programs?"

These three examples have multiple nested loops, which requires very
long time to do reachanbility bound anlaysis based on [37]. This is
the motivation we simplify the reachability bound analysis in
AdaptFun-I, which is not precise as AdaptFun but will not time out, as
shown in Table 2.


---------------------------------------------------------------------------------

Reviewr D

Thanks for your suggestion on the demonstration of the paper. We will
worker harder to simplify the presentation of the paper, such as
providing a table of all the notations used in the paper, while giving
more example explanations in the introducation and the technique
parts. Due to the space limit, we remove some corresponding
explanations in Section 4, 5 into the appendix, which may affect the
understaning of these sections, we sincerely appology for the
confusion and we will add more explanation on these definitions in the
paper, such as "++" means and so on.



