 In this section, we formally present the definition of adaptivity for a given program. As we discussed in Section~\ref{sec:adaptivity-informal}, we first define a dependency relation between program variables, we then define a semantics-based dependency graph, and finally look at longest walks in this graph. 
 % We first present the construction of the semantics-based dependency graph before the introduction of the formal definition of adaptivity. 

\subsection{May-dependency between variables}
\label{sec:dep}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% The Detail Explanation of Variable May-Dependency and Motivation on How to define it %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \wq{we think the query $\query(\chi[2])$ (assigned variable $y^3$) may depend on the query $\query(\chi[1]$ (assigned variable $x^1$). 
  %  but vulnerable to queries request protected by differential privacy mechanisms. In our loop language, a query $q(e)$ represents a query request to the database through a mechanism, which add random noise to protect the return results. In this setting, the results of one query will be randomized due to the noise attached by the mechanism which fails the first candidate because witnessing the results of one query can no longer tells whether the change of the results comes from another query or the change of noise of the differential privacy mechanism. For example, suppose we have a program $p$ which requests two simple queries $q_1()$ and $q_2()$ with no arguments as follows.
%   \[
%   c_1 =\assign{x}{\query(\chi[2])} ;\assign{y}{\query(\chi[3] + x)}.
%   \]
%  $ c = \assign{x}{\query(\chi[1])} ; \assign{y}{\query(\chi[2])}$,
%  and 
% Specifically, in the {\tt Query While} language, the query request is composed by two components: a symbol $\query$ representing a linear query type and 
% % an argument
% the query expression $\qexpr$ as an argument, 
% which represents the function specifying what the query asks. 
% From our perspective, $\query(\chi[1])$ is different from $\query(\chi[2]))$. Informally,  
%
% in this example: $c_1 = \assign{x}{\query(0)}; \assign{z}{\query(\chi[x])}$.
% This candidate definition works well 
% Nevertheless, the first definition fails to catch control dependency because it just monitors the changes to a query, but misses the appearance of the query when the answers of its previous queries change. For instance, it fails to handle $}
%       c_2 = \assign{x}{\query(\chi[1])} ; \eif( x > 2 , \assign{y}{\query(\chi[2])}, \eskip )
%   $, but the second definition can. However, it only considers the control dependency and misses the data dependency. This reminds us to define a \emph{may-dependency} relation between labeled variables by combining the two definitions to capture the two situations.
%  $ p = \assign{x}{\query(\chi[1])} ; \assign{y}{\query(\chi[2])}$. 
% This candidate definition works well with respect to data dependency. However, if fails to handle control dependency since it just monitors the changes to the answer of a query when the answer of previous queries returned change. The key point is that this query may also not be asked because of an analyst decision which depend on the answers of previous queries. An example of this situation is shown in program $p_1$ as follows.
% There are two possible situations that a query will be "affected" by previous queries' results,  
% either when the query expression directly uses the results of previous queries (data dependency), or when the control flow of the program with respect to a query (whether to ask this query or not) depends on the results of previous queries (control flow dependency). To this end, our assigned variable dependency definition has the following two cases.   
% {
% \begin{enumerate}
%     \item One variable may depend on a previous variable if and only if a change of the value assigned to the previous variable may also change the value assigned to the variable.
%     \item One variable may depend on a previous variable if and only if a change of the value assigned to the previous variable may also change the appearance of the assignment command to this variable 
%     % in\wq{during?} 
%     during execution.
% \end{enumerate}
% }
%
%  The first case captures the data dependency. 
% For instance, in a simple program $c_1 =[\assign{x}{\query(\chi[2])}]^1 ;[\assign{y}{\query(\chi[3] + x)}]^2$, we think $\query(\chi[3] + x)$ (variable $y^2$) may depend on the query $\query(\chi[2]))$ (variable $x^1$), because the equipped function of the former $\chi[3] + x$ may depend on the data stored in x assigned with the result of $\query(\chi[2]))$. From our perspective, $\query(\chi[1])$ is different from $\query(\chi[2]))$. The second case captures the control dependency, for instance, in the program $
%       c_2 = [\assign{x}{\query(\chi[1])}]^1 ; \eif( [x > 2]^2 , [\assign{y}{\query(\chi[2])}]^3, [\eskip]^4 )
%
% There are two possible situations that a query will be ``influenced'' by previous queries' results,
% where either the query request is changed when the results of previous queries are changed (data dependency),
% or the  query request is disappeared when the results of previous queries are changed (control dependency). In this sense, our formal dependency definition considers both the two cases:
We are interested in defining a notion of dependencies between program variables since assigned variables are a good proxy to study dependencies between queries---we can recover query requests from variables associated with queries. We consider dependencies that can be generated by either data or control flow.
% as follows,
% \begin{enumerate}
For example, in the program 
\[c_1 =[\assign{x}{\query(\chi[2])}]^1 ;[\assign{y}{\query(\chi[3] + x)}]^2\]
the query $\query(\chi[3] + x)$  depends on the query $\query(\chi[2]))$ through a \emph{value dependency} via  $x^1$.
% ), because $\chi[3] + x$ may depend on the data stored in x assigned by the result of $\query(\chi[2]))$. 
% From our perspective, $\query(\chi[1])$ is different from $\query(\chi[2]))$.
\\
% \\
% (2). One query may depend on a previous query if and only if a change of the value returned
%     to the previous query request may also change the appearance of this query quest.
%     This captures the control influence.
Conversely, in the program
\[c_2 = [\assign{x}{\query(\chi[1])}]^1 ; \eif( [x > 2]^2 , [\assign{y}{\query(\chi[2])}]^3, [\eskip]^4 )\] 
the query $\query(\chi[2])$  depends on the query $\query(\chi[1])$ via the \emph{control dependency} of the guard of the if command involving the labeled variable $x^1$.
% \end{enumerate}
% \\
% \\
% The first case captures the data dependency. 
% For instance, in a simple program $c_1 =[\assign{x}{\query(\chi[2])}]^1 ;[\assign{y}{\query(\chi[3] + x)}]^2$, we think $\query(\chi[3] + x)$ (variable $y^2$) may depend on the query $\query(\chi[2]))$ (variable $x^1$), because the equipped function of the former $\chi[3] + x$ may depend on the data stored in x assigned with the result of $\query(\chi[2]))$. From our perspective, $\query(\chi[1])$ is different from $\query(\chi[2]))$.
% \\
% The second case captures the control dependency.
% For instance, in the program
% $c_2 = [\assign{x}{\query(\chi[1])}]^1 ; \eif( [x > 2]^2 , [\assign{y}{\query(\chi[2])}]^3, [\eskip]^4 )$, 
% we think the query $\query(\chi[2])$ ( or the labeled variable $y^3$) may depend on the query $\query(\chi[1])$ (via the labeled variable $x^1$). 
% \jl{ 
% Since both \emph{influences} are passing through variables, we choose to define the \emph{may-dependency}
% relation over all labeled variables, and then recover the query requests from query-associated variables, $\qvar(c)$.
% It relies on formal observation of the \emph{influences} via events in Def.~\ref{def:diff} and the \emph{may-dependency} between events in Def.~\ref{def:event_dep}.
% }

To define dependency between program variables we will consider two events that are generated from the same command, hence they have the same variable name or boolean expression and label, but have either different value or different query expression, captured by the following definition. 

\begin{defn}
\label{def:diff}
Two events $\event_1, \event_2 \in \eventset$ differ in their value, or query value,
denoted as $\diff(\event_1, \event_2)$, if and only if:
{\small
\begin{subequations}
\begin{align}
& \pi_1(\event_1) = \pi_1(\event_2) 
  \land  
  \pi_2(\event_1) = \pi_2(\event_2) \\
& \land  
  \big(
   (\pi_3(\event_1) \neq \pi_3(\event_2)
  \land 
  \pi_{4}(\event_1) = \pi_{4}(\event_2) = \bullet )
  \lor 
  (\pi_4(\event_1) \neq \bullet
  \land 
  \pi_4(\event_2) \neq \bullet
  \land 
  \pi_{4}(\event_1) \neq_q \pi_{4}(\event_2)) 
  \big)
\end{align}
\label{eq:diff}
\end{subequations}
}
where $\qexpr_1 =_{q} \qexpr_2$ denotes the semantics equivalence between query values\footnote{The formal definition is in the supplementary material},
and $\pi_i$ projects the $i$-th element from the quadruple of an event.
\end{defn}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% The "Detail" (I think redundant) Explanation of Variable May-Dependency and Motivation on How to define it %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% We use $\qexpr_1 =_{q} \qexpr_2$ and $\qexpr_1 \neq_{q} \qexpr_2$ to notate query expression equivalence and in-equivalence, distinct from standard equality. 
% First of all, $\diff(\event_1, \event_2)$ only compares the 'value' assigned to the same labeled variable so the two events share the same labeled variable (the first two elements of the event quadruple). If the labeled variable are not the same, it is trivially false. Next, the 'value' has different meaning according to the type of the assignment. If the two assignment events both are generated from a standard assignment command (by checking whether the fourth element of the event is $\bullet$), we think they are different up to their value if the value assigned to the variable (the third element of the event) varies. On the other hand, if they both come from query request assignment commands, we directly compare the query function (the fourth element of the event). We do not consider the case when one event is generated from the standard assignment and the other comes from the query request assignment, which will not hold. The motivation of defining  $\diff(\event_1, \event_2)$ is that it allows us to check whether the value assigned to a specific variable is changed or not in two runs, which is very important in our dependency case 1. 

%This relation captures the fact that two events are generated from the same command, since they have the same variable name and label, but have either different value or different query expression. 

% \jl{
% $\pi_1(\event_1) = \pi_1(\event_2) 
%   \land  
%   \pi_2(\event_1) = \pi_2(\event_2)$ at Eq.\ref{eq:diff}(a)
% requires that $\event_1$ and $\event_2$ have the same variable name and label, 
% to guarantee that they are from the same command.
% In Eq.\ref{eq:diff}(b),
% two kinds of comparisons between the third and fourth element are for the non-query and query assignment separately.
% For non-query events 
% ( $\pi_{4}(\event_1) =_q \pi_{4}(\event_2) = \bullet$), we only compare their assigned values through $\pi_3(\event_1) \neq \pi_3(\event_2)$.
% But for these query requests events ($\pi_{4}(\event_1) \neq \bullet \land \pi_{4}(\event_2) \neq \bullet$),
% we are comparing their query requests by $\pi_{4}(\event_1) \neq_q \pi_{4}(\event_2)$ rather than the assigned value returned from the unknown database server.
% Since one query is influenced by others as long as the query request is changed.
% }

We can now define when an event \emph{may depend} on another one\footnote{We consider here dependencies between assignment events. This simplifies the definition and is enough for the stating the following definitions. The full definition is in the supplementary material.}.
\begin{defn}[Event May-Dependency]
\label{def:event_dep}
An event $\event_2\in \eventset^{\asn}$ \emph{may-depend} on an event $\event_1 \in \eventset^{\asn}$ in a program ${c}$ denoted
$\eventdep(\event_1, \event_2, c)$, if and only if
\begin{subequations}
{\small 
\begin{align}
&  
\exists \trace, \trace_0, \trace_1, \trace' \in \mathcal{T},\event_1' \in \eventset^{\asn}, {c}_1, {c}_2  \in \cdom  \st \diff(\event_1, \event_1') \land \\
& 
\quad (\exists  \event_2' \in \eventset \st 
\left(
\begin{array}{ll}   
  & \config{{c}, \trace_0} \rightarrow^{*} 
  \config{{c}_1, \trace_1 \tracecat [\event_1]}  \rightarrow^{*} 
  \config{{c}_2,  \trace_1 \tracecat [\event_1] \tracecat \trace \tracecat [\event_2] } 
   \\ 
   \bigwedge &
   \config{{c}_1, \trace_1 \tracecat [\event_1']}  \rightarrow^{*}
    \config{{c}_2,  \trace_1 \tracecat[ \event_1'] \tracecat \trace' \tracecat [\event_2'] } 
  \\
  \bigwedge & 
  \diff(\event_2,\event_2' ) \land 
  \vcounter(\trace, \pi_2(\event_2))
  = 
  \vcounter(\trace', \pi_2(\event_2'))\\
  \end{array}
  \right)\\ 
  & 
  \quad
  \lor 
  \left(
  \begin{array}{l} 
  \exists \trace_3, \trace_3'  \in \mathcal{T}, \event_b \in \eventset^{\test} \st 
  \\
   \quad \config{{c}, \trace_0} \rightarrow^{*} \config{{c}_1, \trace_1 \tracecat [\event_1]}  \rightarrow^{*}
   \config{c_2,  \trace_1 \tracecat [\event_1] \tracecat
   \trace \tracecat [\event_b] \tracecat  \trace_3} 
\\ \quad \land
\config{{c}_1, \trace_1 \tracecat [\event_1']}  \rightarrow^{*} 
\config{c_2,  \trace_1 \tracecat [\event_1'] \tracecat \trace' \tracecat [(\neg \event_b)] \tracecat \trace_3'} 
\\
\quad \land \tlabel({\trace_3}) \cap \tlabel({\trace_3'})
= \emptyset
\land \vcounter(\trace', \pi_2(\event_b)) = \vcounter(\trace, \pi_2(\event_b)) 
    \land \event_2 \in \trace_3
    \land \event_2 \not\in \trace_3'
  \end{array}
  \right)
  ),
\end{align}
}
\label{eq:eventdep}
\end{subequations}
% , $\event_2 \in \trace_3$ or $\event_2 \notin \trace_3$ denotes that $\event_2$ belongs to $\trace_3$ or not.
\end{defn}
There are several components in this definition. The part with label (2a) requires that $\event_1$ and $\event_1$ differ in their value ($\diff(\event_1, \event_1')$).
The next two parts (2b) and (2c) capture the value dependency and control dependency, respectively.
As in the literature on non-interference, and following~\cite{Cousot19a}, we formulate these dependencies as relational properties, i.e. in terms of two different traces of execution. 
We force these two traces to differ by using the event $\event_1$ in one and $\event_1'$ in the other. 
For the value dependency we check whether the change also create a change in the value of $\event_2$ or not. We additionally check that the two events we consider appear the same number of times in the two traces - this to make sure that if the events are generated by assignments in a loop, we consider the same iterations. 
For the control dependency we check whether the change in $\event_1$ affect the appearance in the computation of $\event_2$ or not. 
For this we require the presence of a test event whose value is affected by the change in $\event_1$
% \jl{
in order to guarantee that the computation goes through a control flow guard.
% }
Similarly to the previous condition, we additionally check that the two test events we consider appear the same number of times in the two traces.
% \jl{In Eq~\ref{eq:eventdep}(b) line:2, if the newly generated trace, $\trace' ++ [\event_2']$ still contains $\event_2$ as $\event_2'$, we check the difference on their value in line:3.
% If they only differ in their assigned values, i.e., $\diff(\event_2, \event_2')$ and
% they are in the same loop iterations (via $\vcounter(\trace, \pi_2(\event_2)) = \vcounter(\trace', \pi_2(\event_2'))$),
% then we say there is a value \emph{may-dependency} relation between $\event_1$ and $\event_2$.}

% \jl{The Eq~\ref{eq:eventdep}(c) captures the control dependency through observing the disappearance $\event_2$ from newly generated traces, $\trace' \tracecat [(\neg \event_b)] \tracecat \trace_3'$ in the second execution (line:3).
% $\event_2 \in \trace_3 \land \event_2 \not\in \trace_3'$ in Eq~\ref{eq:eventdep}(c) line:4 specifies this disappearance.
% $\vcounter(\trace', \pi_2(\event_b)) = \vcounter(\trace, \pi_2(\event_b))$ is used to make sure the two executions are in the same loop iterations as well.
% Different from Eq~\ref{eq:eventdep}(b) line:3,
% we use a testing event, $\event_b$ here because
% % $\vcounter(\trace, \pi_2(\event_2)) = \vcounter(\trace', \pi_2(\event_2'))$ 
% observing $\event_2$
% cannot guarantee the disappearance if there are nested loops.
% % This is correct because the control dependency can only be passed through the guard of if or while command,
% % and this guard must be evaluated into two different values ($\event_b$ and $\neg \event_b$) in the two executions.
% }

% \jl{
We can now extend the dependency relation to variables by considering all the assignment events generated during the program’s execution. 
% as long as there is one pair, $\event_1, \event_2$  and a witness trace $\trace$ satisfies $\eventdep(\event_1, \event_2, \trace, c, D)$, 
% we say that the two labeled variables, $x_1^{l_1}$(from  $\event_1$) and 
% $x_2^{l_2}$ (from $\event_2$) in this pair satisfy the \emph{variable may-dependency} relation.
% }

\begin{defn}[Variable May-Dependency]
  \label{def:var_dep}
A variable ${x}_2^{l_2} \in \lvar(c)$  \emph{may-dependend} on the 
  variable ${x}_1^{l_1} \in \lvar(c)$ in a program ${c}$,
  %
  $\vardep({x}_1^{l_1}, {x}_2^{l_2}, {c})$, iff
\begin{center}
$
{\small   \begin{array}{l}
\exists \event_1, \event_2 \in \eventset^{\asn}, \trace \in \mathcal{T} \st
\pi_{1}{(\event_1)}^{\pi_{2}{(\event_1)}} = {x}_1^{l_1}
\land
\pi_{1}{(\event_2)}^{\pi_{2}{(\event_2)}} = {x}_2^{l_2}% \\ \quad 
\land 
\eventdep(\event_1, \event_2, \trace, c) 
  \end{array}
}%
$
\end{center}
  \end{defn}
Notice that in the definition above we can also have that the two variables are the same, this allow us to capture self-dependencies.

% \jl{From the definition, a labeled assigned variables $x_2^{l_2}$ may depend on another labeled assigned variable $x_1^{l_1}$ in a program $c$ under the hidden database $D$, 
% as long as there exist two assignment events $\event_1$ (for $x_1^{l_1}$) and $\event_2$ for $x_2^{l_2}$
% satisfy the \emph{event may-dependency} relation under a witness trace $\trace$.  
% }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Trace-Based Adaptivity%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\subsection{Semantics-based Dependency Graph}
\label{sec:design_choice}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% The Detailed Version in Introducing The Dependency Graph %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% we formally define the semantics-based dependency graph as follows. There are some notations used in the definition. The labeled variables of a program $c$  
% is a subset of the labeled  variables $\mathcal{LV}$, denoted by $\lvar(c) \in \mathcal{P}(\mathcal{VAR} \times \mathcal{L}) \subseteq \mathcal{LV}$.
% \wq{I think LV(c) means all the labeled assigned variables, because in Fig.3.b, j2 is not in the graph so j2 is not in LV(tworounds), please verify. If so, maybe LV(c) is not a good name, people may think it means all the label variables, instead of just assigned ones.}
% The set of query-associated variables (in query request assignments) for a program $c$ is denoted as $\qvar(c)$, where $\qvar: \cdom \to 
% \mathcal{P}(\mathcal{LV})$. The set of initial traces of a program $c$ is a subset of the  trace universe $\trace$, in which every initial trace contains the value for all the input variables of $c$. For instance, the initial trace $\trace_0$ contains the value of input variable $k$ in the $\kw{twoRounds(k)}$ example.

We can now define the \emph{semantics-based dependency graph} of a program $c$. We want this graph to combines quantitative reachability information with dependency information. 
% For instance, the initial trace of $\kw{twoRounds(k)}$ example contains the initial value of the input variable $k$.
\begin{defn}[Semantics-based Dependency Graph]
\label{def:trace_graph}
Given a program ${c}$,
its \emph{semantics-based dependency graph} 
$\traceG({c}) = (\traceV({c}), \traceE({c}), \traceW({c}), \traceF({c}))$ is defined as follows,
{\small
\[
\begin{array}{lll}
  \text{Vertices} &
  \traceV({c}) & := \left\{ 
  x^l
  ~ \middle\vert ~ x^l \in \lvar(c)
  \right\}
  \\
  \text{Directed Edges} &
  \traceE({c}) & := 
  \left\{ 
  (x^i, y^j) 
  ~ \middle\vert ~
  x^i, y^j \in \lvar(c) \land \vardep(x^i, y^j, c) 
  \right\}
  \\
  \text{Weights} &
  \traceW({c}) & := 
  \{ 
  (x^l, w) 
  ~ \vert ~ 
  w : \mathcal{T}_0(c) \to \mathbb{N}
  \land
  x^l \in \lvar(c) 
  \\ & &
  \quad \land
  \forall \trace_0 \in \mathcal{T}_0(c), \trace' \in \mathcal{T} \st \config{{c}, \trace_0} \to^{*} \config{\eskip, \trace_0\tracecat\trace'} 
  \land w(\trace_0) = \vcounter(\trace', l) \}
  \\
  \text{Query Annotations} &
  \traceF({c}) & := 
\left\{(x^l, n)  
~ \middle\vert ~
 x^l \in \lvar(c) \land
(n = 1 \Leftrightarrow x^l \in \qvar(c)) (\land n = 0 \Leftrightarrow  x^l \notin \qvar(c))
\right\}
\end{array},
\]
A semantics-based dependency graph $\traceG({c})= (\traceV({c}), \traceE({c}), \traceW({c}), \traceF({c}))$ is \emph{well-formed} if and only if $ \{x^l \ |\ (x^l,w)\in \traceW({c})\} = \traceV({c}) $.
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% The Detailed Version in Explaining the Trace Operators %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% There are some operators: the trace concatenation operator $\tracecat: \mathcal{T} \to \mathcal{T} \to \mathcal{T}$, combines two traces; the counting operator $\vcounter : \mathcal{T} \to \mathbb{N} \to \mathbb{N}$, 
% which counts the occurrence of of a labeled variable in the trace. The full definitions of these above operators can be found in the appendix.
% \\
% \jl{where $\tracecat: \mathcal{T} \to \mathcal{T} \to \mathcal{T}$ is the trace concatenation operator combining two traces, 
% and $\vcounter : \mathcal{T} \to \mathbb{N} \to \mathbb{N}$ is the counting operator counting the occurrence of a labeled variable in the trace.}
\end{defn}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% The Explanation of Dependency Graph %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \wq{ The occurrence time is computed by the counter operator $w(\trace) = \vcounter(\trace', l)$. As an instance, in the semantics-based dependency graph of $\kw{twoRounds}$ in Figure~\ref{fig:overview-example}(b), the weight of vertices in the while loop $w_k$ is a function which returns the value $n$ of variable $k$ in the starting trace $\tau$, and the commands in the loop are indeed executed $n$ times when starting with $\trace$.}
% Every vertex also has a query annotation, mapping each $x^l \in \traceV(c)$ to $0$ or $1$, 
% indicating whether the vertex comes from a query request assignment (1) or not (0) by checking if the labeled variable $x^l$ of the vertex is in $\qvar(c)$.
% One interesting point is that instead of building a graph whose vertices are just variables coming from query request assignments, we choose the combination of all the labeled assigned variables of the program and the query annotations. The reason is that the results of previous queries can be stored or used in variables
% which aren't associated to the query request,
% it is necessary to track the dependency between all the assigned variables of the program. 
% The main novelty is the combination of the quantitative and dependency information on the semantics-based dependency graph, which means this graph can tell both the dependency between queries and the times they depend on each other.
% The vertices $\traceV({c})$ of a program $c$ are the labeled assigned variables, which are statically collected. The weight function on every vertex $w : \mathcal{T} \to \mathbb{N}$
% mapping from a starting trace $\trace \in \mathcal{T}_0(c)$ to a natural number, tracks the occurrence times of this vertex in the newly generated trace $\trace'$ when the program $c$ is evaluated from the starting trace $\config{{c}, \trace} \to^{*} \config{\eskip, \trace\tracecat\trace'} $.
% One interesting point is that instead of building a graph whose vertices are just variables coming from query request assignments, we choose the combination of all the labeled assigned variables of the program and the query annotations. The reason is that the results of previous queries can be stored or used in variables
% % which aren't associated to the query request,
% it is necessary to track the dependency between all the assigned variables of the program.
% (1). $\traceV({c})$ is simply the $\lvar(c)$ collecting statically.
%     % \item
% %   \\  
% (2). $\traceF(c)$ is the \emph{query annotation} for 
%     every vertex $x^l \in \traceV(c)$, indicating whether $x^l$ comes from a query request (1) or not (0).
As we discussed before, vertices and query annotations are just read out from the program $c$. We have an edge in $\traceE(c)$ if we have a may dependency between two labeled variables in $c$.
A weight function $w \in \traceW(c)$ is a function that for every starting trace $\trace_0 \in \mathcal{T}_0(c)$ 
gives the number of times the assignment of the corresponding vertex $x^l$ is visited. Notice that weight functions are total and with range $\mathbb{N}$. This means that if a program $c$ has some non-terminating behavior, the set $\traceW(c)$ will be empty. To rule out this situation, we consider as well-formed only graphs which have a weight for every vertex. 
In the rest of the paper we will implicitly consider only well-formed semantics-based dependency graphs. 
% \end{enumerate}
% One interesting point is that instead of building a graph whose vertices are just variables coming from query request assignments, we choose the combination of all the labeled assigned variables of the program and the query annotations. The reason is that the results of previous queries can be stored or used in variables
% which aren't associated to the query request,
% it is necessary to track the dependency between all the assigned variables of the program.


\subsection{Trace-based Adaptivity}
We can now define the adaptivity of a program formally. This notion is formulated in terms of an initial trace, specifying the value of the input variables, as the walk on the graph $\traceG({c})$, which has the largest number of query requests.


% Given 
% the program $c$'s
% $\traceG({c})$,
% we define adaptivity 
% with respect to an initial trace $\trace_0 \in \mathcal{T}_0(c)$ via a finite walk in $\traceG({c})$, which has the most query requests.
% We show the definition of a finite walk as follows.

\begin{defn}[Walk on $\traceG({c})$]
\label{def:finitewalk}
Given the semantics-based dependency graph $\traceG({c}) = (\traceV, \traceE, \traceW, \traceF)$ of a program $c$, a \emph{walk} $k:\mathcal{T}_0(c)\to \mathbb{N}$ on $\traceG({c})$ is a function that given as input an initial trace $\trace_0$ returns a sequence of edges $(e_1 \ldots e_{n - 1})$ 
for which there is a sequence of vertices $(v_1, \ldots, v_{n})$ such that:
\begin{itemize}
\item $e_i = (v_{i},v_{i + 1}) \in \traceE$ for every $1 \leq i < n$.
\item every $v_i \in \traceV$ and $(v_i, w_i) \in \traceW$, $v_i$ appears in $(v_1, \ldots, v_{n})$ at most $w(\trace_0)$ times.  
\end{itemize}
{$(v_1, \ldots, v_{n})$ is the vertex sequence of $k(\trace_0)$ and the length of $k(\trace_0)$ is the number of vertices in its vertex sequence, i.e., $|k(\trace_0)| = n$.}
% The length of $k(\trace_0)$ is the number of vertices in its vertices sequence, i.e., $\len(k)(\trace_0) = n$.
We denote by $\walks(\traceG(c))$
the set of all the  walks $k$ in $\traceG(c)$.
\end{defn} 
Because for the adaptivity
% is intuitively 
we are interested in the dependency between queries,
we calculate a special ``length'' of a walk, the \emph{query length},  by counting only the vertices
corresponding to queries.
\begin{defn}[Query Length]
\label{def:qlen}
Given 
the semantics-based dependency graph $\traceG({c})$ of a program $c$,
 and a \emph{walk} 
 $k \in \walks(\traceG(c))$, the \emph{query length} of $k$ is a function $\qlen(k):\mathcal{T}_0(c) \to \mathbb{N}$ that given an initial trace $\trace_0$ returns
the number of vertices which correspond to query variables in the vertices sequence, $(v_1, \ldots, v_{n})$ as follows, 
\begin{center}
   $
  \qlen(k)(\trace_0) = |\big( v \mid v \in (v_1, \ldots, v_{n}) \land \qflag(v) = 1 \big)|.
$
\end{center}
% \mg{There is a problem here. The vertex sequence $(v_1, \ldots, v_{n})$ is not defined. The walk when provided with the initial trace gives you an edge sequence determining the vertex sequence but we need to do some work to extract it. In other words, this need to be rephrased, perhaps adding a definition of what is the vertex sequence associated with a walk applied to an initial state.}
\end{defn}
% Then the definition of adaptivity is presented in Def.~\ref{def:trace_adapt} below.
\begin{defn}
    [Adaptivity of a Program]
    \label{def:trace_adapt}
    Given a program ${c}$, 
    its adaptivity $A(c)$ is function 
    $A(c) : \mathcal{T}_0(c)\to \mathbb{N}$ such that for an
    initial trace $\trace_0 \in \mathcal{T}_0(c)$, 
\begin{center}
$
    A(c)(\trace_0) = \max \big 
    \{ \qlen(k)(\trace_0) \mid k \in \walks(\traceG(c)) \big \} 
$
\end{center}
\end{defn}