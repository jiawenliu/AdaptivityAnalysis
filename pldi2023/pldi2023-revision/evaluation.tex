%\subsection{Implementation Results}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Previous Version For Reference %%%%%%%%%%%%%%%%%%%%
% We implemented $\THESYSTEM$ as a tool which takes a labeled command as input  
% % labeled command 
% and outputs an upper bound on the program adaptivity and on the number of query requests.
% This implementation consists of an 
% abstract control flow graph generation, weight estimation (as presented in Section~\ref{sec:alg_weightgen}),
% edge estimation (as presented in Section~\ref{sec:alg_edgegen}) in Ocaml, 
% and the adaptivity computation algorithm shown in Section~\ref{sec:alg_adaptcompute} in Python.
% The OCaml program takes the labeled command as input and outputs the program-based dependency graph,
% feeds into the python program and the python program provides the adaptivity upper bound and the query number as the final output.

% We evaluated this implementation on $17$ example programs with the evaluation results shown  in Table~\ref{tb:adapt-imp}.
% In this table,
% the first column is the name of each program.
% For each program $c$, the second column is its intuitive adaptivity rounds,
% the third column is the adaptivity $A(c)(\trace_0)$ w.r.t an input initial trace $\trace_0 \in \mathcal{T}_0(c)$ as definition~\ref{def:trace_adapt}
% ($\env(\trace_0) k$ computes $k$'s value in $\trace_0$).
% % we defined through our formal semantic model above.
% % in Section~\ref{sec:dep_adaptivity}.
% % % In the third column, we use $k$ represent the weight function $w_k$ 
% % $A(c)$ is a function takes an initial trace $\trace_0 \in \mathcal{T}_0(c)$, 
% % the adaptivity w.r.t. $\trace_0$ is represented in this column.
% % (in program's execution-based dependency graph) which return value of variable $k$ 
% % from an initial trace $\trace_0$, same for natural numbers.
% The last column is the output of the $\THESYSTEM$ implementation, which consists of two expressions.
% The first one is the upper bound for adaptivity and the second one is the 
% upper bound for the total number of query requests in the program.

% The first 3 programs we evaluated are $\kw{twoRounds(k)}$, $ \kw{multiRounds(k)}$, 
% and the $\kw{linearRegressGD(k, r)}$ which we discussed in overview and above section.
% % Section~\ref{sec:examples}.
% % The same for the third programprograms in the table row 
% For these examples, $A(c)$ 
% % based dynamic analysis 
% gives the accurate adaptivity definition, 
% simultaneously the $\THESYSTEM$ outputs the tight bounds for both of the adaptivity and query requesting number as expected.
% % Look at 
% % the $ \kw{linearRegressionGD(k)}$ which we discussed in Section~\ref{sec:examples}, the $\THESYSTEM$ outputs the accurate bound $k$ as expected.
% But for the forth program $\kw{multiRoundOdd(k)}$, $\THESYSTEM$ outputs an over-approximated upper bound $1 + 2*k$ for the $A(c)$, 
% which is consistent with our expectation as discussed in Example~\ref{ex:multipleRoundSingle}. 
% The fifth program is the evaluation results for the example in Example~\ref{ex:multipleRoundSingle}, where $\THESYSTEM$ outputs
% the tight bound for $A(c)$ but $A(c)$ is a loose definition of the program's actual adaptivity rounds.
% %
% The programs in the table from  $\kw{seq()}$ to $ \kw{nestedWhileMPRV(k)}$ are 
% designed for testing the programs under different possible situations.
% These programs contain control dependency, data value dependency,
% the nested while, dependency through multiple variables, dependency across nested loops, and so on. 
% Overall for these examples, our system gives both the accurate adaptivity definition and 
% adaptivity upper bound simultaneously through the dynamic analysis and 
% static analysis.
% %
% For the other programs, the complete program can be found in Appendix, and the implementation on GitHub.
% \begin {table}[H]
%     \caption{Experimental results of {\THESYSTEM} implementation}
%         \label{tb:adapt-imp}
%         \begin{center}
%         \centering
% {\footnotesize
%         \begin{tabular}{ r | p{12mm} | c | p{25mm} | l}
%          Program $c$ & adaptive \newline rounds 
%          & $A(c) (\trace_0)$ 
%          & $\THESYSTEM$ \newline $\progA(c)$, $\# \query$ 
%          & performance \\ 
%          \hline
%          \hline
%          $  \kw{twoRounds(k)}$ & $2$ & $2$ & $2$, $k$ &  \\
%          $  \kw{multiRounds(k)}$ & $k$ & $ \env(\trace_0) k $ & $k$, $k$  &    \\
%          $  \kw{linearRegressGD(k, r)}$ & $k$ & $\env(\trace_0) k$ & $k$, $2 * \env(\trace_0) k$  &    \\
%          $  \kw{multiRoundsO(k)}$ & $1 + k$ & $1 + (\env(\trace_0) k) $  & $1 +2 * k$, $1 + 2*k$  &    \\
%          $  \kw{multiRoundsS(k)}$    & $2$ & $2 + (\env(\trace_0) k) $ & $2 + k$, $2 + k$  &    \\
%          $\kw{seq()}$ & $4$ & $4$ & $4$, $4$  \\ 
%          $\kw{seqRV()}$ & $4$ & $4$ & $4$, $4$ \\  
%          $ \kw{ifVD}$ & $3$ & $3$ & $3$, $3$ \\
%          $\kw{ifCD()}$ & $3$ & $3$ & $3$, $3$  &    \\
%          $ \kw{whileNested(k)}$ & $1+k$ & $1+ (\env(\trace_0) k)$ & $1+k$  &    \\
%          $ \kw{whileM(k)}$ & $1 + k$ & $1 +2 * \lfloor \frac{\env(\trace_0) k}{2} \rfloor$ & $1 +2 * \lfloor \frac{k}{2} \rfloor$, $1 + 2 * k$  &    \\
%          $ \kw{whileRV(k)}$ & $1 + 2*k$ & $1 + 2*(\env(\trace_0) k)$ & $1 + 2*k$, $2 + 3 * k$  &    \\
%          $ \kw{whileVCD(k)}$ & $1 + 2*k$ & $1 + 2*(\env(\trace_0) k)$ & $1 + 2 * k$, $2 + 2 * k$  &    \\
%          $ \kw{whileMPVCD(k)}$ & $2 + k$ & $2 + (\env(\trace_0) k)$  & $2 + k$, $1 + 2 * k$   &    \\
%          $ \kw{nestWhileVD(k)}$ & $2 + k^2$ & $2 + (\env(\trace_0) k)^2$  & $2 + k^2$, $1 + k + k^2$   &    \\
%          $ \kw{nestedWhileRV(k)}$ & $1 + 2*k$ & $1 + 2*(\env(\trace_0) k)$ & $1 + 2*k$,  $1 + k + k^2$   &    \\
%          $ \kw{nestedWhileMR(k)}$ & $1 + k + k^2$ & $1 + (\env(\trace_0) k) + (\env(\trace_0) k)^2$  & $1 + k + k^2$,  $2 + k + k^2$  &    \\
%          $ \kw{nestedWhileMPRV(k)}$ & $1 + k + k^2$ & $1 + (\env(\trace_0) k) + (\env(\trace_0) k)^2$  & $1 + k + k^2$,  $2 + k + k^2$  &    \\
%         \end{tabular}
% }        
% \end{center}
% \end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Previous Version Above %%%%%%%%%%%%%%%%%%%%

We implemented $\THESYSTEM$ as a tool which takes a labeled program as input
and outputs the upper bound on the program adaptivity and the total number of queries that the program runs.
This implementation consists of a module written in OCaml for the generation of the estimated graph $\progG$, and a module written in Python for the weight estimation algorithm (Section~\ref{sec:alg_weightgen}) and the algorithm $\pathsearch$ (Section~\ref{sec:alg_adaptcompute}).
The OCaml program takes the labeled program as input and outputs a version of the graph $\progG$ (without weights) and the abstract transition graph $\absG$ for the program. These two objects are then
fed into the python program which computes the weights, and outputs the adaptivity bound and the query number.
%
We evaluated this implementation on $25$ examples with performances summarized in Tab.~\ref{tb:adapt-imp}.
The $1^{st}$ column is the example name.
For each example $c$, the $2^{nd}$ column is its adaptivity rounds,
$\THESYSTEM$ outputs are in the the $3^{rd}$ and $4^{th}$ columns. They are
% two expressions.
% The first one is 
the adaptivity upper bound and
% the second one is the 
% upper bound for
$c$'s total query requests \#. 
The last $4$ columns are {\THESYSTEM}'s performance w.r.t. the program lines.
We track the running time of the OCaml code for parsing the program and generating the $\progG(c)$,
and the running times of the weight analysis
and the $\pathsearch(c)$ in Python.
We implemented two weight estimation methods. The first one (referred as I in Tab.\ref{tb:adapt-imp}) is the one we presented formally in Section~\ref{sec:alg_weightedgegen}. Unfortunately, this method is accurate but slow, it doesn't performs well with big program. The second one (referred as II) is a relaxation of the first one. It is more  efficient but it over-approximate complicated loops. Based on the two implementations, our $\THESYSTEM$ produces two bounds on the adaptivity, corresponding to the left and right side (I | II) in the $3^{rd}$, $4^{th}$ and $6^{th}$ columns\footnote{When the method II produces the same results as I, we omit them and use the symbol $-$.}.
%
The first $5$ programs are adapted from classical data analysis algorithms.
$\THESYSTEM$ computes tight adaptivity bound for the first 3.
For the forth program $\kw{multiRoundsO(k)}$, $\THESYSTEM$ over-approximates the adaptivity as $1 + 2*k$ because of its path-insensitivity.
The fifth program is the one in Example~\ref{ex:multiRoundsS}, where $\THESYSTEM$ outputs the tight bound but we give a loose definition for its actual adaptivity.
%
% The first two examples $\kw{twoRounds(k)}$, $ \kw{multiRounds(k)}$ are the same as Figure~\ref{fig:overview-example}(a) and Figure~\ref{fig:multipleRounds}(a).
The programs from Tab.~\ref{tb:adapt-imp} line:6-17 all have small size but complex structures, to test the programs under different situations including
data, control dependency,
the multiple paths nested loop with related counters, etc.
Both implementations compute tight bounds for examples in line:6-14
and over-approximate the adaptivities for $15^{th}$ and $16^{th}$ due to path-insensitivity.
For the $17^{th}$ one, implementation I gives tight bound bound while II gives loose bound, so we keep both implementations.
The last six programs are big but simple,
to test the performance limitation. 
From the evaluation results, the performance bottleneck is the weight estimation algorithm.
The implementation I
% By implementing the bound analysis algorithm in Section~\ref{sec:alg_weightgen} (adapted from \cite{sinn2017complexity}), we are 
is unable to evaluate them in a reasonable time period, denoted by $*$ on the left side.
While the implementation II computes the \emph{adaptivity} for
them effectively on the right side. 
% Overall for these examples, our system gives both the accurate adaptivity definition and estimated
% adaptivity upper bound through our formalization and analysis framework $\THESYSTEM$.
% The complete programs can be found in the Appendix.

\input{table}